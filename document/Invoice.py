#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jun  5 12:23:02 2024 by generateDS.py version 2.43.3.
# Python 3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'invoice.py')
#   ('-s', 'sub_classes.py')
#
# Command line arguments:
#   C:\Users\1\PythonApp\generateDS-2.43.3\customs\Schemas_out_5_23_0\Invoice.xsd
#
# Command line:
#   C:\Users\1\PythonApp\generateDS-2.43.3\generateDS.py -o "invoice.py" -s "sub_classes.py" C:\Users\1\PythonApp\generateDS-2.43.3\customs\Schemas_out_5_23_0\Invoice.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.43.3
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_



Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class TransportCategoryCodeType(str, Enum):
    """TransportCategoryCodeType -- К
    а
    т
    е
    г
    о
    р
    и
    я
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    .
    Д
    о
    п
    у
    с
    т
    и
    м
    ы
    е
    з
    н
    а
    ч
    е
    н
    и
    я
    : A,B,C,D,E (
    л
    а
    т
    и
    н
    с
    к
    и
    е
    с
    и
    м
    в
    о
    л
    ы
    ). 1
    с
    и
    м
    в
    о
    л
    
    """
    A='A'
    B='B'
    C='C'
    D='D'
    E='E'


#
# Start data representation classes
#
class AddressType(GeneratedsSuper):
    """AddressType -- А
    д
    р
    е
    с
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    /
    ф
    и
    з
    и
    ч
    е
    с
    к
    о
    г
    о
    л
    и
    ц
    а
    PostalCode -- П
    о
    ч
    т
    о
    в
    ы
    й
    и
    н
    д
    е
    к
    с
    CountryCode -- Б
    у
    к
    в
    е
    н
    н
    ы
    й
    к
    о
    д
    с
    т
    р
    а
    н
    ы
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    с
    т
    р
    а
    н
    м
    и
    р
    а
    CounryName -- К
    р
    а
    т
    к
    о
    е
    н
    а
    з
    в
    а
    н
    и
    е
    с
    т
    р
    а
    н
    ы
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    с
    т
    р
    а
    н
    м
    и
    р
    а
    Region -- О
    б
    л
    а
    с
    т
    ь
    (
    р
    е
    г
    и
    о
    н
    ,
    ш
    т
    а
    т
    ,
    п
    р
    о
    в
    и
    н
    ц
    и
    я
    и
    т
    .
    п
    .)
    City -- Н
    а
    с
    е
    л
    е
    н
    н
    ы
    й
    п
    у
    н
    к
    т
    StreetHouse -- У
    л
    и
    ц
    а
    ,
    н
    о
    м
    е
    р
    д
    о
    м
    а
    ,
    н
    о
    м
    е
    р
    о
    ф
    и
    с
    а
    TerritoryCode -- К
    о
    д
    а
    д
    м
    и
    н
    и
    с
    т
    р
    а
    т
    и
    в
    н
    о
    -
    т
    е
    р
    р
    и
    т
    о
    р
    и
    а
    л
    ь
    н
    о
    й
    е
    д
    и
    н
    и
    ц
    ы
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    Г
    К
    С
    О
    А
    Т
    Е
    (
    д
    л
    я
    К
    ы
    р
    г
    ы
    з
    с
    к
    о
    й
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PostalCode=None, CountryCode=None, CounryName=None, Region=None, City=None, StreetHouse=None, TerritoryCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.PostalCode = PostalCode
        self.validate_PostalCodeType(self.PostalCode)
        self.PostalCode_nsprefix_ = "clt_ru"
        self.CountryCode = CountryCode
        self.validate_CountryA2CodeType(self.CountryCode)
        self.CountryCode_nsprefix_ = "clt_ru"
        self.CounryName = CounryName
        self.validate_CountryNameType(self.CounryName)
        self.CounryName_nsprefix_ = "clt_ru"
        self.Region = Region
        self.validate_RegionType(self.Region)
        self.Region_nsprefix_ = "clt_ru"
        self.City = City
        self.validate_CityNameType(self.City)
        self.City_nsprefix_ = "clt_ru"
        self.StreetHouse = StreetHouse
        self.validate_StreetHouseType(self.StreetHouse)
        self.StreetHouse_nsprefix_ = "clt_ru"
        self.TerritoryCode = TerritoryCode
        self.validate_TerritoryCodeType(self.TerritoryCode)
        self.TerritoryCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PostalCode(self):
        return self.PostalCode
    def set_PostalCode(self, PostalCode):
        self.PostalCode = PostalCode
    def get_CountryCode(self):
        return self.CountryCode
    def set_CountryCode(self, CountryCode):
        self.CountryCode = CountryCode
    def get_CounryName(self):
        return self.CounryName
    def set_CounryName(self, CounryName):
        self.CounryName = CounryName
    def get_Region(self):
        return self.Region
    def set_Region(self, Region):
        self.Region = Region
    def get_City(self):
        return self.City
    def set_City(self, City):
        self.City = City
    def get_StreetHouse(self):
        return self.StreetHouse
    def set_StreetHouse(self, StreetHouse):
        self.StreetHouse = StreetHouse
    def get_TerritoryCode(self):
        return self.TerritoryCode
    def set_TerritoryCode(self, TerritoryCode):
        self.TerritoryCode = TerritoryCode
    def validate_PostalCodeType(self, value):
        result = True
        # Validate type PostalCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PostalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PostalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CountryA2CodeType(self, value):
        result = True
        # Validate type CountryA2CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryA2CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryA2CodeType_patterns_, ))
                result = False
        return result
    validate_CountryA2CodeType_patterns_ = [['^([A-Z]{2}|[0]{2}|[9]{2})$']]
    def validate_CountryNameType(self, value):
        result = True
        # Validate type CountryNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CountryNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CountryNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_RegionType(self, value):
        result = True
        # Validate type RegionType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on RegionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on RegionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CityNameType(self, value):
        result = True
        # Validate type CityNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 35:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CityNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CityNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_StreetHouseType(self, value):
        result = True
        # Validate type StreetHouseType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on StreetHouseType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on StreetHouseType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TerritoryCodeType(self, value):
        result = True
        # Validate type TerritoryCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TerritoryCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TerritoryCodeType_patterns_, ))
                result = False
        return result
    validate_TerritoryCodeType_patterns_ = [['^(\\d{8,17})$']]
    def has__content(self):
        if (
            self.PostalCode is not None or
            self.CountryCode is not None or
            self.CounryName is not None or
            self.Region is not None or
            self.City is not None or
            self.StreetHouse is not None or
            self.TerritoryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='AddressType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PostalCode is not None:
            namespaceprefix_ = self.PostalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.PostalCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostalCode>%s</%sPostalCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), namespaceprefix_ , eol_))
        if self.CountryCode is not None:
            namespaceprefix_ = self.CountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCountryCode>%s</%sCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), namespaceprefix_ , eol_))
        if self.CounryName is not None:
            namespaceprefix_ = self.CounryName_nsprefix_ + ':' if (UseCapturedNS_ and self.CounryName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCounryName>%s</%sCounryName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CounryName), input_name='CounryName')), namespaceprefix_ , eol_))
        if self.Region is not None:
            namespaceprefix_ = self.Region_nsprefix_ + ':' if (UseCapturedNS_ and self.Region_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegion>%s</%sRegion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Region), input_name='Region')), namespaceprefix_ , eol_))
        if self.City is not None:
            namespaceprefix_ = self.City_nsprefix_ + ':' if (UseCapturedNS_ and self.City_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCity>%s</%sCity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), namespaceprefix_ , eol_))
        if self.StreetHouse is not None:
            namespaceprefix_ = self.StreetHouse_nsprefix_ + ':' if (UseCapturedNS_ and self.StreetHouse_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetHouse>%s</%sStreetHouse>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.StreetHouse), input_name='StreetHouse')), namespaceprefix_ , eol_))
        if self.TerritoryCode is not None:
            namespaceprefix_ = self.TerritoryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TerritoryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerritoryCode>%s</%sTerritoryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TerritoryCode), input_name='TerritoryCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PostalCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PostalCode')
            value_ = self.gds_validate_string(value_, node, 'PostalCode')
            self.PostalCode = value_
            self.PostalCode_nsprefix_ = child_.prefix
            # validate type PostalCodeType
            self.validate_PostalCodeType(self.PostalCode)
        elif nodeName_ == 'CountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CountryCode')
            value_ = self.gds_validate_string(value_, node, 'CountryCode')
            self.CountryCode = value_
            self.CountryCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.CountryCode)
        elif nodeName_ == 'CounryName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CounryName')
            value_ = self.gds_validate_string(value_, node, 'CounryName')
            self.CounryName = value_
            self.CounryName_nsprefix_ = child_.prefix
            # validate type CountryNameType
            self.validate_CountryNameType(self.CounryName)
        elif nodeName_ == 'Region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Region')
            value_ = self.gds_validate_string(value_, node, 'Region')
            self.Region = value_
            self.Region_nsprefix_ = child_.prefix
            # validate type RegionType
            self.validate_RegionType(self.Region)
        elif nodeName_ == 'City':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'City')
            value_ = self.gds_validate_string(value_, node, 'City')
            self.City = value_
            self.City_nsprefix_ = child_.prefix
            # validate type CityNameType
            self.validate_CityNameType(self.City)
        elif nodeName_ == 'StreetHouse':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'StreetHouse')
            value_ = self.gds_validate_string(value_, node, 'StreetHouse')
            self.StreetHouse = value_
            self.StreetHouse_nsprefix_ = child_.prefix
            # validate type StreetHouseType
            self.validate_StreetHouseType(self.StreetHouse)
        elif nodeName_ == 'TerritoryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TerritoryCode')
            value_ = self.gds_validate_string(value_, node, 'TerritoryCode')
            self.TerritoryCode = value_
            self.TerritoryCode_nsprefix_ = child_.prefix
            # validate type TerritoryCodeType
            self.validate_TerritoryCodeType(self.TerritoryCode)
# end class AddressType


class AutomobileBaseType(GeneratedsSuper):
    """AutomobileBaseType -- Д
    а
    н
    н
    ы
    е
    о
    б
    а
    в
    т
    о
    м
    о
    б
    и
    л
    я
    х
    .
    Б
    а
    з
    о
    в
    ы
    й
    к
    л
    а
    с
    с
    д
    л
    я
    31
    й
    г
    р
    .
    и
    К
    а
    р
    т
    о
    ч
    к
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    Model -- М
    а
    р
    к
    а
    ,
    м
    о
    д
    е
    л
    ь
    Mark -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    м
    а
    р
    к
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    м
    а
    р
    о
    к
    д
    о
    р
    о
    ж
    н
    ы
    х
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    ы
    х
    с
    р
    е
    д
    с
    т
    в
    MarkCode -- К
    о
    д
    м
    а
    р
    к
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    м
    а
    р
    о
    к
    д
    о
    р
    о
    ж
    н
    ы
    х
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    ы
    х
    с
    р
    е
    д
    с
    т
    в
    OfftakeYear -- Г
    о
    д
    и
    з
    г
    о
    т
    о
    в
    л
    е
    н
    и
    я
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    EngineVolumeQuanity -- Р
    а
    б
    о
    ч
    и
    й
    о
    б
    ъ
    е
    м
    д
    в
    и
    г
    а
    т
    е
    л
    я
    ,
    к
    у
    б
    .
    с
    м
    VINID -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    (VIN)
    BodyID -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    к
    у
    з
    о
    в
    а
    (
    п
    р
    и
    ц
    е
    п
    а
    ),
    п
    р
    и
    с
    в
    о
    е
    н
    н
    ы
    й
    и
    н
    а
    н
    е
    с
    е
    н
    н
    ы
    й
    н
    а
    н
    е
    г
    о
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    е
    й
    -
    и
    з
    г
    о
    т
    о
    в
    и
    т
    е
    л
    е
    м
    EngineID -- П
    р
    и
    с
    в
    о
    е
    н
    н
    ы
    й
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    е
    й
    -
    и
    з
    г
    о
    т
    о
    в
    и
    т
    е
    л
    е
    м
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    д
    в
    и
    г
    а
    т
    е
    л
    я
    ,
    н
    а
    н
    е
    с
    е
    н
    н
    ы
    й
    н
    а
    б
    л
    о
    к
    е
    д
    в
    и
    г
    а
    т
    е
    л
    я
    .
    И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    м
    о
    ж
    е
    т
    с
    о
    с
    т
    о
    я
    т
    ь
    и
    з
    г
    р
    у
    п
    п
    р
    а
    з
    д
    е
    л
    ь
    н
    ы
    х
    ц
    и
    ф
    р
    ,
    и
    з
    к
    о
    т
    о
    р
    ы
    х
    п
    о
    с
    л
    е
    д
    н
    я
    я
    г
    р
    у
    п
    п
    а
    ,
    с
    о
    с
    т
    о
    я
    щ
    а
    я
    и
    з
    д
    в
    у
    х
    ц
    и
    ф
    р
    ,
    у
    к
    а
    з
    ы
    в
    а
    е
    т
    г
    о
    д
    в
    ы
    п
    у
    с
    к
    а
    д
    в
    и
    г
    а
    т
    е
    л
    я
    ChassisID -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    ш
    а
    с
    с
    и
    (
    р
    а
    м
    ы
    ),
    п
    р
    и
    с
    в
    о
    е
    н
    н
    ы
    е
    и
    н
    а
    н
    е
    с
    е
    н
    н
    ы
    е
    н
    а
    н
    и
    х
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    е
    й
    -
    и
    з
    г
    о
    т
    о
    в
    и
    т
    е
    л
    е
    м
    CabID -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    к
    а
    б
    и
    н
    ы
    EmergencyDeviceID -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    у
    с
    т
    р
    о
    й
    с
    т
    в
    а
    и
    л
    и
    с
    и
    с
    т
    е
    м
    ы
    в
    ы
    з
    о
    в
    а
    э
    к
    с
    т
    р
    е
    н
    н
    ы
    х
    о
    п
    е
    р
    а
    т
    и
    в
    н
    ы
    х
    с
    л
    у
    ж
    б
    ,
    к
    о
    т
    о
    р
    ы
    м
    и
    о
    б
    о
    р
    у
    д
    о
    в
    а
    н
    о
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    е
    с
    р
    е
    д
    с
    т
    в
    о
    .
    Д
    л
    я
    Р
    Ф
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Model=None, Mark=None, MarkCode=None, OfftakeYear=None, EngineVolumeQuanity=None, VINID=None, BodyID=None, EngineID=None, ChassisID=None, CabID=None, EmergencyDeviceID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.Model = Model
        self.validate_TransportNameType(self.Model)
        self.Model_nsprefix_ = "clt_ru"
        self.Mark = Mark
        self.validate_MarkCarNameType(self.Mark)
        self.Mark_nsprefix_ = "clt_ru"
        self.MarkCode = MarkCode
        self.validate_MarkCarCodeType(self.MarkCode)
        self.MarkCode_nsprefix_ = "clt_ru"
        self.OfftakeYear = OfftakeYear
        self.validate_DateYearCustType(self.OfftakeYear)
        self.OfftakeYear_nsprefix_ = "clt_ru"
        self.EngineVolumeQuanity = EngineVolumeQuanity
        self.validate_EngineVolumeType(self.EngineVolumeQuanity)
        self.EngineVolumeQuanity_nsprefix_ = "clt_ru"
        self.VINID = VINID
        self.validate_VINIDType(self.VINID)
        self.VINID_nsprefix_ = "clt_ru"
        self.BodyID = BodyID
        self.validate_VINIDType(self.BodyID)
        self.BodyID_nsprefix_ = "clt_ru"
        self.EngineID = EngineID
        self.validate_EngineIDType(self.EngineID)
        self.EngineID_nsprefix_ = "clt_ru"
        self.ChassisID = ChassisID
        self.validate_VINIDType(self.ChassisID)
        self.ChassisID_nsprefix_ = "clt_ru"
        self.CabID = CabID
        self.validate_VINIDType(self.CabID)
        self.CabID_nsprefix_ = "clt_ru"
        self.EmergencyDeviceID = EmergencyDeviceID
        self.validate_Text50Type(self.EmergencyDeviceID)
        self.EmergencyDeviceID_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutomobileBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutomobileBaseType.subclass:
            return AutomobileBaseType.subclass(*args_, **kwargs_)
        else:
            return AutomobileBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Model(self):
        return self.Model
    def set_Model(self, Model):
        self.Model = Model
    def get_Mark(self):
        return self.Mark
    def set_Mark(self, Mark):
        self.Mark = Mark
    def get_MarkCode(self):
        return self.MarkCode
    def set_MarkCode(self, MarkCode):
        self.MarkCode = MarkCode
    def get_OfftakeYear(self):
        return self.OfftakeYear
    def set_OfftakeYear(self, OfftakeYear):
        self.OfftakeYear = OfftakeYear
    def get_EngineVolumeQuanity(self):
        return self.EngineVolumeQuanity
    def set_EngineVolumeQuanity(self, EngineVolumeQuanity):
        self.EngineVolumeQuanity = EngineVolumeQuanity
    def get_VINID(self):
        return self.VINID
    def set_VINID(self, VINID):
        self.VINID = VINID
    def get_BodyID(self):
        return self.BodyID
    def set_BodyID(self, BodyID):
        self.BodyID = BodyID
    def get_EngineID(self):
        return self.EngineID
    def set_EngineID(self, EngineID):
        self.EngineID = EngineID
    def get_ChassisID(self):
        return self.ChassisID
    def set_ChassisID(self, ChassisID):
        self.ChassisID = ChassisID
    def get_CabID(self):
        return self.CabID
    def set_CabID(self, CabID):
        self.CabID = CabID
    def get_EmergencyDeviceID(self):
        return self.EmergencyDeviceID
    def set_EmergencyDeviceID(self, EmergencyDeviceID):
        self.EmergencyDeviceID = EmergencyDeviceID
    def validate_TransportNameType(self, value):
        result = True
        # Validate type TransportNameType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TransportNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TransportNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MarkCarNameType(self, value):
        result = True
        # Validate type MarkCarNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MarkCarNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MarkCarNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MarkCarCodeType(self, value):
        result = True
        # Validate type MarkCarCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on MarkCarCodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_DateYearCustType(self, value):
        result = True
        # Validate type DateYearCustType, a restriction on CategoryCust:YearCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_EngineVolumeType(self, value):
        result = True
        # Validate type EngineVolumeType, a restriction on CategoryCust:QuantityCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on EngineVolumeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on EngineVolumeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_VINIDType(self, value):
        result = True
        # Validate type VINIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on VINIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on VINIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_EngineIDType(self, value):
        result = True
        # Validate type EngineIDType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EngineIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EngineIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Model is not None or
            self.Mark is not None or
            self.MarkCode is not None or
            self.OfftakeYear is not None or
            self.EngineVolumeQuanity is not None or
            self.VINID is not None or
            self.BodyID is not None or
            self.EngineID is not None or
            self.ChassisID is not None or
            self.CabID is not None or
            self.EmergencyDeviceID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AutomobileBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AutomobileBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AutomobileBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AutomobileBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AutomobileBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='AutomobileBaseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AutomobileBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Model is not None:
            namespaceprefix_ = self.Model_nsprefix_ + ':' if (UseCapturedNS_ and self.Model_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModel>%s</%sModel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Model), input_name='Model')), namespaceprefix_ , eol_))
        if self.Mark is not None:
            namespaceprefix_ = self.Mark_nsprefix_ + ':' if (UseCapturedNS_ and self.Mark_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMark>%s</%sMark>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Mark), input_name='Mark')), namespaceprefix_ , eol_))
        if self.MarkCode is not None:
            namespaceprefix_ = self.MarkCode_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMarkCode>%s</%sMarkCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MarkCode), input_name='MarkCode')), namespaceprefix_ , eol_))
        if self.OfftakeYear is not None:
            namespaceprefix_ = self.OfftakeYear_nsprefix_ + ':' if (UseCapturedNS_ and self.OfftakeYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOfftakeYear>%s</%sOfftakeYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OfftakeYear), input_name='OfftakeYear')), namespaceprefix_ , eol_))
        if self.EngineVolumeQuanity is not None:
            namespaceprefix_ = self.EngineVolumeQuanity_nsprefix_ + ':' if (UseCapturedNS_ and self.EngineVolumeQuanity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEngineVolumeQuanity>%s</%sEngineVolumeQuanity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.EngineVolumeQuanity, input_name='EngineVolumeQuanity'), namespaceprefix_ , eol_))
        if self.VINID is not None:
            namespaceprefix_ = self.VINID_nsprefix_ + ':' if (UseCapturedNS_ and self.VINID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVINID>%s</%sVINID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VINID), input_name='VINID')), namespaceprefix_ , eol_))
        if self.BodyID is not None:
            namespaceprefix_ = self.BodyID_nsprefix_ + ':' if (UseCapturedNS_ and self.BodyID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBodyID>%s</%sBodyID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BodyID), input_name='BodyID')), namespaceprefix_ , eol_))
        if self.EngineID is not None:
            namespaceprefix_ = self.EngineID_nsprefix_ + ':' if (UseCapturedNS_ and self.EngineID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEngineID>%s</%sEngineID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EngineID), input_name='EngineID')), namespaceprefix_ , eol_))
        if self.ChassisID is not None:
            namespaceprefix_ = self.ChassisID_nsprefix_ + ':' if (UseCapturedNS_ and self.ChassisID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChassisID>%s</%sChassisID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ChassisID), input_name='ChassisID')), namespaceprefix_ , eol_))
        if self.CabID is not None:
            namespaceprefix_ = self.CabID_nsprefix_ + ':' if (UseCapturedNS_ and self.CabID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCabID>%s</%sCabID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CabID), input_name='CabID')), namespaceprefix_ , eol_))
        if self.EmergencyDeviceID is not None:
            namespaceprefix_ = self.EmergencyDeviceID_nsprefix_ + ':' if (UseCapturedNS_ and self.EmergencyDeviceID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmergencyDeviceID>%s</%sEmergencyDeviceID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EmergencyDeviceID), input_name='EmergencyDeviceID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Model':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'Model')
            value_ = self.gds_validate_string(value_, node, 'Model')
            self.Model = value_
            self.Model_nsprefix_ = child_.prefix
            # validate type TransportNameType
            self.validate_TransportNameType(self.Model)
        elif nodeName_ == 'Mark':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Mark')
            value_ = self.gds_validate_string(value_, node, 'Mark')
            self.Mark = value_
            self.Mark_nsprefix_ = child_.prefix
            # validate type MarkCarNameType
            self.validate_MarkCarNameType(self.Mark)
        elif nodeName_ == 'MarkCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'MarkCode')
            value_ = self.gds_validate_string(value_, node, 'MarkCode')
            self.MarkCode = value_
            self.MarkCode_nsprefix_ = child_.prefix
            # validate type MarkCarCodeType
            self.validate_MarkCarCodeType(self.MarkCode)
        elif nodeName_ == 'OfftakeYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OfftakeYear')
            value_ = self.gds_validate_string(value_, node, 'OfftakeYear')
            self.OfftakeYear = value_
            self.OfftakeYear_nsprefix_ = child_.prefix
            # validate type DateYearCustType
            self.validate_DateYearCustType(self.OfftakeYear)
        elif nodeName_ == 'EngineVolumeQuanity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'EngineVolumeQuanity')
            fval_ = self.gds_validate_decimal(fval_, node, 'EngineVolumeQuanity')
            self.EngineVolumeQuanity = fval_
            self.EngineVolumeQuanity_nsprefix_ = child_.prefix
            # validate type EngineVolumeType
            self.validate_EngineVolumeType(self.EngineVolumeQuanity)
        elif nodeName_ == 'VINID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'VINID')
            value_ = self.gds_validate_string(value_, node, 'VINID')
            self.VINID = value_
            self.VINID_nsprefix_ = child_.prefix
            # validate type VINIDType
            self.validate_VINIDType(self.VINID)
        elif nodeName_ == 'BodyID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BodyID')
            value_ = self.gds_validate_string(value_, node, 'BodyID')
            self.BodyID = value_
            self.BodyID_nsprefix_ = child_.prefix
            # validate type VINIDType
            self.validate_VINIDType(self.BodyID)
        elif nodeName_ == 'EngineID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'EngineID')
            value_ = self.gds_validate_string(value_, node, 'EngineID')
            self.EngineID = value_
            self.EngineID_nsprefix_ = child_.prefix
            # validate type EngineIDType
            self.validate_EngineIDType(self.EngineID)
        elif nodeName_ == 'ChassisID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ChassisID')
            value_ = self.gds_validate_string(value_, node, 'ChassisID')
            self.ChassisID = value_
            self.ChassisID_nsprefix_ = child_.prefix
            # validate type VINIDType
            self.validate_VINIDType(self.ChassisID)
        elif nodeName_ == 'CabID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CabID')
            value_ = self.gds_validate_string(value_, node, 'CabID')
            self.CabID = value_
            self.CabID_nsprefix_ = child_.prefix
            # validate type VINIDType
            self.validate_VINIDType(self.CabID)
        elif nodeName_ == 'EmergencyDeviceID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EmergencyDeviceID')
            value_ = self.gds_validate_string(value_, node, 'EmergencyDeviceID')
            self.EmergencyDeviceID = value_
            self.EmergencyDeviceID_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.EmergencyDeviceID)
# end class AutomobileBaseType


class BankInformationType(GeneratedsSuper):
    """BankInformationType -- И
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    о
    б
    а
    н
    к
    о
    в
    с
    к
    и
    х
    с
    ч
    е
    т
    а
    х
    BankAccount -- Н
    о
    м
    е
    р
    б
    а
    н
    к
    о
    в
    с
    к
    о
    г
    о
    с
    ч
    е
    т
    а
    BankAccountDescription -- О
    п
    и
    с
    а
    н
    и
    е
    т
    и
    п
    а
    с
    ч
    е
    т
    а
    :
    р
    а
    с
    ч
    е
    т
    н
    ы
    й
    ,
    в
    а
    л
    ю
    т
    н
    ы
    й
    BankName -- Н
    а
    з
    в
    а
    н
    и
    е
    б
    а
    н
    к
    а
    BankMFO -- М
    Ф
    О
    б
    а
    н
    к
    а
    OKPOID -- К
    о
    д
    б
    а
    н
    к
    а
    п
    о
    О
    К
    П
    О
    BICID -- Б
    И
    К
    б
    а
    н
    к
    а
    SWIFTID -- SWIFT
    к
    о
    д
    б
    а
    н
    к
    а
    CorrAccount -- Н
    о
    м
    е
    р
    к
    о
    р
    р
    е
    с
    п
    о
    н
    д
    е
    н
    т
    с
    к
    о
    г
    о
    с
    ч
    е
    т
    а
    б
    а
    н
    к
    а
    TransitCurrencyAccount -- В
    а
    л
    ю
    т
    н
    ы
    й
    с
    ч
    е
    т
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    (
    т
    р
    а
    н
    з
    и
    т
    н
    ы
    й
    )
    SpecialTransitCurrencyAccount -- В
    а
    л
    ю
    т
    н
    ы
    й
    с
    ч
    е
    т
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    (
    с
    п
    е
    ц
    и
    а
    л
    ь
    н
    ы
    й
    т
    р
    а
    н
    з
    и
    т
    н
    ы
    й
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BankAccount=None, BankAccountDescription=None, BankName=None, BankMFO=None, OKPOID=None, BICID=None, SWIFTID=None, CorrAccount=None, TransitCurrencyAccount=None, SpecialTransitCurrencyAccount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        if BankAccount is None:
            self.BankAccount = []
        else:
            self.BankAccount = BankAccount
        self.BankAccount_nsprefix_ = "clt_ru"
        if BankAccountDescription is None:
            self.BankAccountDescription = []
        else:
            self.BankAccountDescription = BankAccountDescription
        self.BankAccountDescription_nsprefix_ = "clt_ru"
        self.BankName = BankName
        self.validate_NameType(self.BankName)
        self.BankName_nsprefix_ = "clt_ru"
        self.BankMFO = BankMFO
        self.validate_BankMFOType(self.BankMFO)
        self.BankMFO_nsprefix_ = "clt_ru"
        self.OKPOID = OKPOID
        self.validate_OKPOIDType(self.OKPOID)
        self.OKPOID_nsprefix_ = "clt_ru"
        self.BICID = BICID
        self.validate_BICIDType(self.BICID)
        self.BICID_nsprefix_ = "clt_ru"
        self.SWIFTID = SWIFTID
        self.validate_SWIFTIDType(self.SWIFTID)
        self.SWIFTID_nsprefix_ = "clt_ru"
        self.CorrAccount = CorrAccount
        self.validate_ForeignAccountType(self.CorrAccount)
        self.CorrAccount_nsprefix_ = "clt_ru"
        if TransitCurrencyAccount is None:
            self.TransitCurrencyAccount = []
        else:
            self.TransitCurrencyAccount = TransitCurrencyAccount
        self.TransitCurrencyAccount_nsprefix_ = "clt_ru"
        if SpecialTransitCurrencyAccount is None:
            self.SpecialTransitCurrencyAccount = []
        else:
            self.SpecialTransitCurrencyAccount = SpecialTransitCurrencyAccount
        self.SpecialTransitCurrencyAccount_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BankInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BankInformationType.subclass:
            return BankInformationType.subclass(*args_, **kwargs_)
        else:
            return BankInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BankAccount(self):
        return self.BankAccount
    def set_BankAccount(self, BankAccount):
        self.BankAccount = BankAccount
    def add_BankAccount(self, value):
        self.BankAccount.append(value)
    def insert_BankAccount_at(self, index, value):
        self.BankAccount.insert(index, value)
    def replace_BankAccount_at(self, index, value):
        self.BankAccount[index] = value
    def get_BankAccountDescription(self):
        return self.BankAccountDescription
    def set_BankAccountDescription(self, BankAccountDescription):
        self.BankAccountDescription = BankAccountDescription
    def add_BankAccountDescription(self, value):
        self.BankAccountDescription.append(value)
    def insert_BankAccountDescription_at(self, index, value):
        self.BankAccountDescription.insert(index, value)
    def replace_BankAccountDescription_at(self, index, value):
        self.BankAccountDescription[index] = value
    def get_BankName(self):
        return self.BankName
    def set_BankName(self, BankName):
        self.BankName = BankName
    def get_BankMFO(self):
        return self.BankMFO
    def set_BankMFO(self, BankMFO):
        self.BankMFO = BankMFO
    def get_OKPOID(self):
        return self.OKPOID
    def set_OKPOID(self, OKPOID):
        self.OKPOID = OKPOID
    def get_BICID(self):
        return self.BICID
    def set_BICID(self, BICID):
        self.BICID = BICID
    def get_SWIFTID(self):
        return self.SWIFTID
    def set_SWIFTID(self, SWIFTID):
        self.SWIFTID = SWIFTID
    def get_CorrAccount(self):
        return self.CorrAccount
    def set_CorrAccount(self, CorrAccount):
        self.CorrAccount = CorrAccount
    def get_TransitCurrencyAccount(self):
        return self.TransitCurrencyAccount
    def set_TransitCurrencyAccount(self, TransitCurrencyAccount):
        self.TransitCurrencyAccount = TransitCurrencyAccount
    def add_TransitCurrencyAccount(self, value):
        self.TransitCurrencyAccount.append(value)
    def insert_TransitCurrencyAccount_at(self, index, value):
        self.TransitCurrencyAccount.insert(index, value)
    def replace_TransitCurrencyAccount_at(self, index, value):
        self.TransitCurrencyAccount[index] = value
    def get_SpecialTransitCurrencyAccount(self):
        return self.SpecialTransitCurrencyAccount
    def set_SpecialTransitCurrencyAccount(self, SpecialTransitCurrencyAccount):
        self.SpecialTransitCurrencyAccount = SpecialTransitCurrencyAccount
    def add_SpecialTransitCurrencyAccount(self, value):
        self.SpecialTransitCurrencyAccount.append(value)
    def insert_SpecialTransitCurrencyAccount_at(self, index, value):
        self.SpecialTransitCurrencyAccount.insert(index, value)
    def replace_SpecialTransitCurrencyAccount_at(self, index, value):
        self.SpecialTransitCurrencyAccount[index] = value
    def validate_ForeignAccountType(self, value):
        result = True
        # Validate type ForeignAccountType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ForeignAccountType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ForeignAccountType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_BankMFOType(self, value):
        result = True
        # Validate type BankMFOType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankMFOType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankMFOType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_OKPOIDType(self, value):
        result = True
        # Validate type OKPOIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OKPOIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OKPOIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_BICIDType(self, value):
        result = True
        # Validate type BICIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BICIDType_patterns_, ))
                result = False
        return result
    validate_BICIDType_patterns_ = [['^(\\d{9})$']]
    def validate_SWIFTIDType(self, value):
        result = True
        # Validate type SWIFTIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SWIFTIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SWIFTIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.BankAccount or
            self.BankAccountDescription or
            self.BankName is not None or
            self.BankMFO is not None or
            self.OKPOID is not None or
            self.BICID is not None or
            self.SWIFTID is not None or
            self.CorrAccount is not None or
            self.TransitCurrencyAccount or
            self.SpecialTransitCurrencyAccount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='BankInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BankInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BankInformationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BankInformationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BankInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='BankInformationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='BankInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BankAccount_ in self.BankAccount:
            namespaceprefix_ = self.BankAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.BankAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankAccount>%s</%sBankAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(BankAccount_), input_name='BankAccount')), namespaceprefix_ , eol_))
        for BankAccountDescription_ in self.BankAccountDescription:
            namespaceprefix_ = self.BankAccountDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.BankAccountDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankAccountDescription>%s</%sBankAccountDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(BankAccountDescription_), input_name='BankAccountDescription')), namespaceprefix_ , eol_))
        if self.BankName is not None:
            namespaceprefix_ = self.BankName_nsprefix_ + ':' if (UseCapturedNS_ and self.BankName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankName>%s</%sBankName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BankName), input_name='BankName')), namespaceprefix_ , eol_))
        if self.BankMFO is not None:
            namespaceprefix_ = self.BankMFO_nsprefix_ + ':' if (UseCapturedNS_ and self.BankMFO_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankMFO>%s</%sBankMFO>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BankMFO), input_name='BankMFO')), namespaceprefix_ , eol_))
        if self.OKPOID is not None:
            namespaceprefix_ = self.OKPOID_nsprefix_ + ':' if (UseCapturedNS_ and self.OKPOID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOKPOID>%s</%sOKPOID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OKPOID), input_name='OKPOID')), namespaceprefix_ , eol_))
        if self.BICID is not None:
            namespaceprefix_ = self.BICID_nsprefix_ + ':' if (UseCapturedNS_ and self.BICID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBICID>%s</%sBICID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BICID), input_name='BICID')), namespaceprefix_ , eol_))
        if self.SWIFTID is not None:
            namespaceprefix_ = self.SWIFTID_nsprefix_ + ':' if (UseCapturedNS_ and self.SWIFTID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSWIFTID>%s</%sSWIFTID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SWIFTID), input_name='SWIFTID')), namespaceprefix_ , eol_))
        if self.CorrAccount is not None:
            namespaceprefix_ = self.CorrAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.CorrAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrAccount>%s</%sCorrAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CorrAccount), input_name='CorrAccount')), namespaceprefix_ , eol_))
        for TransitCurrencyAccount_ in self.TransitCurrencyAccount:
            namespaceprefix_ = self.TransitCurrencyAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.TransitCurrencyAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransitCurrencyAccount>%s</%sTransitCurrencyAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(TransitCurrencyAccount_), input_name='TransitCurrencyAccount')), namespaceprefix_ , eol_))
        for SpecialTransitCurrencyAccount_ in self.SpecialTransitCurrencyAccount:
            namespaceprefix_ = self.SpecialTransitCurrencyAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.SpecialTransitCurrencyAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialTransitCurrencyAccount>%s</%sSpecialTransitCurrencyAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SpecialTransitCurrencyAccount_), input_name='SpecialTransitCurrencyAccount')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BankAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BankAccount')
            value_ = self.gds_validate_string(value_, node, 'BankAccount')
            self.BankAccount.append(value_)
            self.BankAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.BankAccount[-1])
        elif nodeName_ == 'BankAccountDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankAccountDescription')
            value_ = self.gds_validate_string(value_, node, 'BankAccountDescription')
            self.BankAccountDescription.append(value_)
            self.BankAccountDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.BankAccountDescription[-1])
        elif nodeName_ == 'BankName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankName')
            value_ = self.gds_validate_string(value_, node, 'BankName')
            self.BankName = value_
            self.BankName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.BankName)
        elif nodeName_ == 'BankMFO':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankMFO')
            value_ = self.gds_validate_string(value_, node, 'BankMFO')
            self.BankMFO = value_
            self.BankMFO_nsprefix_ = child_.prefix
            # validate type BankMFOType
            self.validate_BankMFOType(self.BankMFO)
        elif nodeName_ == 'OKPOID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OKPOID')
            value_ = self.gds_validate_string(value_, node, 'OKPOID')
            self.OKPOID = value_
            self.OKPOID_nsprefix_ = child_.prefix
            # validate type OKPOIDType
            self.validate_OKPOIDType(self.OKPOID)
        elif nodeName_ == 'BICID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BICID')
            value_ = self.gds_validate_string(value_, node, 'BICID')
            self.BICID = value_
            self.BICID_nsprefix_ = child_.prefix
            # validate type BICIDType
            self.validate_BICIDType(self.BICID)
        elif nodeName_ == 'SWIFTID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SWIFTID')
            value_ = self.gds_validate_string(value_, node, 'SWIFTID')
            self.SWIFTID = value_
            self.SWIFTID_nsprefix_ = child_.prefix
            # validate type SWIFTIDType
            self.validate_SWIFTIDType(self.SWIFTID)
        elif nodeName_ == 'CorrAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CorrAccount')
            value_ = self.gds_validate_string(value_, node, 'CorrAccount')
            self.CorrAccount = value_
            self.CorrAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.CorrAccount)
        elif nodeName_ == 'TransitCurrencyAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransitCurrencyAccount')
            value_ = self.gds_validate_string(value_, node, 'TransitCurrencyAccount')
            self.TransitCurrencyAccount.append(value_)
            self.TransitCurrencyAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.TransitCurrencyAccount[-1])
        elif nodeName_ == 'SpecialTransitCurrencyAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SpecialTransitCurrencyAccount')
            value_ = self.gds_validate_string(value_, node, 'SpecialTransitCurrencyAccount')
            self.SpecialTransitCurrencyAccount.append(value_)
            self.SpecialTransitCurrencyAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.SpecialTransitCurrencyAccount[-1])
# end class BankInformationType


class BaseDocType(GeneratedsSuper):
    """BaseDocType -- Б
    а
    з
    о
    в
    ы
    й
    т
    и
    п
    д
    л
    я
    э
    л
    е
    к
    т
    р
    о
    н
    н
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    DocumentID -- У
    н
    и
    к
    а
    л
    ь
    н
    ы
    й
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    т
    о
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    RefDocumentID -- У
    н
    и
    к
    а
    л
    ь
    н
    ы
    й
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    т
    о
    р
    и
    с
    х
    о
    д
    н
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    INNSign -- И
    Н
    Н
    в
    л
    а
    д
    е
    л
    ь
    ц
    а
    М
    Ч
    Д
    MCD_ID -- Е
    д
    и
    н
    ы
    й
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    д
    о
    в
    е
    р
    е
    н
    н
    о
    с
    т
    и
    в
    ф
    о
    р
    м
    а
    т
    е
    М
    Ч
    Д
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DocumentID=None, RefDocumentID=None, INNSign=None, MCD_ID=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.DocumentID = DocumentID
        self.validate_DocumentIDType(self.DocumentID)
        self.DocumentID_nsprefix_ = "clt_ru"
        self.RefDocumentID = RefDocumentID
        self.validate_DocumentIDType(self.RefDocumentID)
        self.RefDocumentID_nsprefix_ = "clt_ru"
        self.INNSign = INNSign
        self.validate_INNIDType(self.INNSign)
        self.INNSign_nsprefix_ = "clt_ru"
        self.MCD_ID = MCD_ID
        self.validate_DocumentIDType(self.MCD_ID)
        self.MCD_ID_nsprefix_ = "clt_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseDocType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseDocType.subclass:
            return BaseDocType.subclass(*args_, **kwargs_)
        else:
            return BaseDocType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DocumentID(self):
        return self.DocumentID
    def set_DocumentID(self, DocumentID):
        self.DocumentID = DocumentID
    def get_RefDocumentID(self):
        return self.RefDocumentID
    def set_RefDocumentID(self, RefDocumentID):
        self.RefDocumentID = RefDocumentID
    def get_INNSign(self):
        return self.INNSign
    def set_INNSign(self, INNSign):
        self.INNSign = INNSign
    def get_MCD_ID(self):
        return self.MCD_ID
    def set_MCD_ID(self, MCD_ID):
        self.MCD_ID = MCD_ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DocumentIDType(self, value):
        result = True
        # Validate type DocumentIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DocumentIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DocumentIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_INNIDType(self, value):
        result = True
        # Validate type INNIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INNIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on INNIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.DocumentID is not None or
            self.RefDocumentID is not None or
            self.INNSign is not None or
            self.MCD_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='BaseDocType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseDocType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseDocType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseDocType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseDocType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='BaseDocType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='BaseDocType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentID is not None:
            namespaceprefix_ = self.DocumentID_nsprefix_ + ':' if (UseCapturedNS_ and self.DocumentID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDocumentID>%s</%sDocumentID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DocumentID), input_name='DocumentID')), namespaceprefix_ , eol_))
        if self.RefDocumentID is not None:
            namespaceprefix_ = self.RefDocumentID_nsprefix_ + ':' if (UseCapturedNS_ and self.RefDocumentID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefDocumentID>%s</%sRefDocumentID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RefDocumentID), input_name='RefDocumentID')), namespaceprefix_ , eol_))
        if self.INNSign is not None:
            namespaceprefix_ = self.INNSign_nsprefix_ + ':' if (UseCapturedNS_ and self.INNSign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINNSign>%s</%sINNSign>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INNSign), input_name='INNSign')), namespaceprefix_ , eol_))
        if self.MCD_ID is not None:
            namespaceprefix_ = self.MCD_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.MCD_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMCD_ID>%s</%sMCD_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MCD_ID), input_name='MCD_ID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DocumentID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DocumentID')
            value_ = self.gds_validate_string(value_, node, 'DocumentID')
            self.DocumentID = value_
            self.DocumentID_nsprefix_ = child_.prefix
            # validate type DocumentIDType
            self.validate_DocumentIDType(self.DocumentID)
        elif nodeName_ == 'RefDocumentID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'RefDocumentID')
            value_ = self.gds_validate_string(value_, node, 'RefDocumentID')
            self.RefDocumentID = value_
            self.RefDocumentID_nsprefix_ = child_.prefix
            # validate type DocumentIDType
            self.validate_DocumentIDType(self.RefDocumentID)
        elif nodeName_ == 'INNSign':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'INNSign')
            value_ = self.gds_validate_string(value_, node, 'INNSign')
            self.INNSign = value_
            self.INNSign_nsprefix_ = child_.prefix
            # validate type INNIDType
            self.validate_INNIDType(self.INNSign)
        elif nodeName_ == 'MCD_ID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'MCD_ID')
            value_ = self.gds_validate_string(value_, node, 'MCD_ID')
            self.MCD_ID = value_
            self.MCD_ID_nsprefix_ = child_.prefix
            # validate type DocumentIDType
            self.validate_DocumentIDType(self.MCD_ID)
# end class BaseDocType


class CUBranchDescriptionType(GeneratedsSuper):
    """CUBranchDescriptionType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    б
    о
    с
    о
    б
    л
    е
    н
    н
    о
    м
    п
    о
    д
    р
    а
    з
    д
    е
    л
    е
    н
    и
    и
    OrganizationName -- К
    р
    а
    т
    к
    о
    е
    н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    о
    б
    о
    с
    о
    б
    л
    е
    н
    н
    о
    г
    о
    п
    о
    д
    р
    а
    з
    д
    е
    л
    е
    н
    и
    я
    Address -- А
    д
    р
    е
    с
    о
    б
    о
    с
    о
    б
    л
    е
    н
    н
    о
    г
    о
    п
    о
    д
    р
    а
    з
    д
    е
    л
    е
    н
    и
    я
    RFOrganizationFeatures -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    о
    с
    с
    и
    й
    с
    к
    о
    й
    Ф
    е
    д
    е
    р
    а
    ц
    и
    и
    RKOrganizationFeatures -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    К
    а
    з
    а
    х
    с
    т
    а
    н
    RBOrganizationFeatures -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    Б
    е
    л
    а
    р
    у
    с
    ь
    RAOrganizationFeatures -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    А
    р
    м
    е
    н
    и
    я
    KGOrganizationFeatures -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    К
    ы
    р
    г
    ы
    з
    с
    к
    о
    й
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OrganizationName=None, Address=None, RFOrganizationFeatures=None, RKOrganizationFeatures=None, RBOrganizationFeatures=None, RAOrganizationFeatures=None, KGOrganizationFeatures=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.OrganizationName = OrganizationName
        self.validate_ShortNameType(self.OrganizationName)
        self.OrganizationName_nsprefix_ = "clt_ru"
        self.Address = Address
        self.Address_nsprefix_ = "cat_ru"
        self.RFOrganizationFeatures = RFOrganizationFeatures
        self.RFOrganizationFeatures_nsprefix_ = "cat_ru"
        self.RKOrganizationFeatures = RKOrganizationFeatures
        self.RKOrganizationFeatures_nsprefix_ = "cat_ru"
        self.RBOrganizationFeatures = RBOrganizationFeatures
        self.RBOrganizationFeatures_nsprefix_ = "cat_ru"
        self.RAOrganizationFeatures = RAOrganizationFeatures
        self.RAOrganizationFeatures_nsprefix_ = "cat_ru"
        self.KGOrganizationFeatures = KGOrganizationFeatures
        self.KGOrganizationFeatures_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUBranchDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUBranchDescriptionType.subclass:
            return CUBranchDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CUBranchDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OrganizationName(self):
        return self.OrganizationName
    def set_OrganizationName(self, OrganizationName):
        self.OrganizationName = OrganizationName
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def get_RFOrganizationFeatures(self):
        return self.RFOrganizationFeatures
    def set_RFOrganizationFeatures(self, RFOrganizationFeatures):
        self.RFOrganizationFeatures = RFOrganizationFeatures
    def get_RKOrganizationFeatures(self):
        return self.RKOrganizationFeatures
    def set_RKOrganizationFeatures(self, RKOrganizationFeatures):
        self.RKOrganizationFeatures = RKOrganizationFeatures
    def get_RBOrganizationFeatures(self):
        return self.RBOrganizationFeatures
    def set_RBOrganizationFeatures(self, RBOrganizationFeatures):
        self.RBOrganizationFeatures = RBOrganizationFeatures
    def get_RAOrganizationFeatures(self):
        return self.RAOrganizationFeatures
    def set_RAOrganizationFeatures(self, RAOrganizationFeatures):
        self.RAOrganizationFeatures = RAOrganizationFeatures
    def get_KGOrganizationFeatures(self):
        return self.KGOrganizationFeatures
    def set_KGOrganizationFeatures(self, KGOrganizationFeatures):
        self.KGOrganizationFeatures = KGOrganizationFeatures
    def validate_ShortNameType(self, value):
        result = True
        # Validate type ShortNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 120:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ShortNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ShortNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.OrganizationName is not None or
            self.Address is not None or
            self.RFOrganizationFeatures is not None or
            self.RKOrganizationFeatures is not None or
            self.RBOrganizationFeatures is not None or
            self.RAOrganizationFeatures is not None or
            self.KGOrganizationFeatures is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CUBranchDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CUBranchDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CUBranchDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUBranchDescriptionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CUBranchDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CUBranchDescriptionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CUBranchDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganizationName is not None:
            namespaceprefix_ = self.OrganizationName_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganizationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationName>%s</%sOrganizationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganizationName), input_name='OrganizationName')), namespaceprefix_ , eol_))
        if self.Address is not None:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            self.Address.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        if self.RFOrganizationFeatures is not None:
            namespaceprefix_ = self.RFOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RFOrganizationFeatures_nsprefix_) else ''
            self.RFOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RFOrganizationFeatures', pretty_print=pretty_print)
        if self.RKOrganizationFeatures is not None:
            namespaceprefix_ = self.RKOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RKOrganizationFeatures_nsprefix_) else ''
            self.RKOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RKOrganizationFeatures', pretty_print=pretty_print)
        if self.RBOrganizationFeatures is not None:
            namespaceprefix_ = self.RBOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RBOrganizationFeatures_nsprefix_) else ''
            self.RBOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RBOrganizationFeatures', pretty_print=pretty_print)
        if self.RAOrganizationFeatures is not None:
            namespaceprefix_ = self.RAOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RAOrganizationFeatures_nsprefix_) else ''
            self.RAOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RAOrganizationFeatures', pretty_print=pretty_print)
        if self.KGOrganizationFeatures is not None:
            namespaceprefix_ = self.KGOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.KGOrganizationFeatures_nsprefix_) else ''
            self.KGOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KGOrganizationFeatures', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OrganizationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationName')
            value_ = self.gds_validate_string(value_, node, 'OrganizationName')
            self.OrganizationName = value_
            self.OrganizationName_nsprefix_ = child_.prefix
            # validate type ShortNameType
            self.validate_ShortNameType(self.OrganizationName)
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'RFOrganizationFeatures':
            obj_ = RFOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RFOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RFOrganizationFeatures'
        elif nodeName_ == 'RKOrganizationFeatures':
            obj_ = RKOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RKOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RKOrganizationFeatures'
        elif nodeName_ == 'RBOrganizationFeatures':
            obj_ = RBOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RBOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RBOrganizationFeatures'
        elif nodeName_ == 'RAOrganizationFeatures':
            obj_ = RAOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RAOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RAOrganizationFeatures'
        elif nodeName_ == 'KGOrganizationFeatures':
            obj_ = KGOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KGOrganizationFeatures = obj_
            obj_.original_tagname_ = 'KGOrganizationFeatures'
# end class CUBranchDescriptionType


class CUTransportMeansType(GeneratedsSuper):
    """CUTransportMeansType -- Т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    ы
    е
    с
    р
    е
    д
    с
    т
    в
    а
    н
    а
    г
    р
    а
    н
    и
    ц
    е
    /
    в
    н
    у
    т
    р
    и
    с
    т
    р
    а
    н
    ы
    TransportModeCode -- К
    о
    д
    в
    и
    д
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    п
    о
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    у
    в
    и
    д
    о
    в
    т
    р
    а
    н
    с
    п
    о
    р
    т
    а
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    и
    р
    о
    в
    к
    и
    т
    о
    в
    а
    р
    о
    в
    TransportNationalityCode -- Б
    у
    к
    в
    е
    н
    н
    ы
    й
    к
    о
    д
    с
    т
    р
    а
    н
    ы
    п
    р
    и
    н
    а
    д
    л
    е
    ж
    н
    о
    с
    т
    и
    (
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    )
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    ы
    х
    с
    р
    е
    д
    с
    т
    в
    п
    о
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    у
    с
    т
    р
    а
    н
    м
    и
    р
    а
    . 99-
    р
    а
    з
    н
    ы
    е
    , 00-
    н
    е
    и
    з
    в
    е
    с
    т
    н
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TransportModeCode=None, TransportNationalityCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.TransportModeCode = TransportModeCode
        self.validate_TransportModeCodeType(self.TransportModeCode)
        self.TransportModeCode_nsprefix_ = "clt_ru"
        self.TransportNationalityCode = TransportNationalityCode
        self.validate_CountryA2CodeType(self.TransportNationalityCode)
        self.TransportNationalityCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUTransportMeansType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUTransportMeansType.subclass:
            return CUTransportMeansType.subclass(*args_, **kwargs_)
        else:
            return CUTransportMeansType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TransportModeCode(self):
        return self.TransportModeCode
    def set_TransportModeCode(self, TransportModeCode):
        self.TransportModeCode = TransportModeCode
    def get_TransportNationalityCode(self):
        return self.TransportNationalityCode
    def set_TransportNationalityCode(self, TransportNationalityCode):
        self.TransportNationalityCode = TransportNationalityCode
    def validate_TransportModeCodeType(self, value):
        result = True
        # Validate type TransportModeCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TransportModeCodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_CountryA2CodeType(self, value):
        result = True
        # Validate type CountryA2CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryA2CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryA2CodeType_patterns_, ))
                result = False
        return result
    validate_CountryA2CodeType_patterns_ = [['^([A-Z]{2}|[0]{2}|[9]{2})$']]
    def has__content(self):
        if (
            self.TransportModeCode is not None or
            self.TransportNationalityCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CUTransportMeansType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CUTransportMeansType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CUTransportMeansType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUTransportMeansType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CUTransportMeansType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CUTransportMeansType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CUTransportMeansType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TransportModeCode is not None:
            namespaceprefix_ = self.TransportModeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportModeCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportModeCode>%s</%sTransportModeCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportModeCode), input_name='TransportModeCode')), namespaceprefix_ , eol_))
        if self.TransportNationalityCode is not None:
            namespaceprefix_ = self.TransportNationalityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportNationalityCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportNationalityCode>%s</%sTransportNationalityCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportNationalityCode), input_name='TransportNationalityCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TransportModeCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportModeCode')
            value_ = self.gds_validate_string(value_, node, 'TransportModeCode')
            self.TransportModeCode = value_
            self.TransportModeCode_nsprefix_ = child_.prefix
            # validate type TransportModeCodeType
            self.validate_TransportModeCodeType(self.TransportModeCode)
        elif nodeName_ == 'TransportNationalityCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportNationalityCode')
            value_ = self.gds_validate_string(value_, node, 'TransportNationalityCode')
            self.TransportNationalityCode = value_
            self.TransportNationalityCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.TransportNationalityCode)
# end class CUTransportMeansType


class CargoBaseType(GeneratedsSuper):
    """CargoBaseType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    г
    р
    у
    з
    е
    CargoDescription -- О
    п
    и
    с
    а
    н
    и
    е
    г
    р
    у
    з
    а
    GrossWeightQuantity -- В
    е
    с
    т
    о
    в
    а
    р
    а
    б
    р
    у
    т
    т
    о
    (
    к
    г
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CargoDescription=None, GrossWeightQuantity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        if CargoDescription is None:
            self.CargoDescription = []
        else:
            self.CargoDescription = CargoDescription
        self.CargoDescription_nsprefix_ = "clt_ru"
        self.GrossWeightQuantity = GrossWeightQuantity
        self.validate_QuantityBasisType(self.GrossWeightQuantity)
        self.GrossWeightQuantity_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CargoBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CargoBaseType.subclass:
            return CargoBaseType.subclass(*args_, **kwargs_)
        else:
            return CargoBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CargoDescription(self):
        return self.CargoDescription
    def set_CargoDescription(self, CargoDescription):
        self.CargoDescription = CargoDescription
    def add_CargoDescription(self, value):
        self.CargoDescription.append(value)
    def insert_CargoDescription_at(self, index, value):
        self.CargoDescription.insert(index, value)
    def replace_CargoDescription_at(self, index, value):
        self.CargoDescription[index] = value
    def get_GrossWeightQuantity(self):
        return self.GrossWeightQuantity
    def set_GrossWeightQuantity(self, GrossWeightQuantity):
        self.GrossWeightQuantity = GrossWeightQuantity
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CargoDescription or
            self.GrossWeightQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CargoBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CargoBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CargoBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CargoBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CargoBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CargoBaseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CargoBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CargoDescription_ in self.CargoDescription:
            namespaceprefix_ = self.CargoDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.CargoDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCargoDescription>%s</%sCargoDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(CargoDescription_), input_name='CargoDescription')), namespaceprefix_ , eol_))
        if self.GrossWeightQuantity is not None:
            namespaceprefix_ = self.GrossWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GrossWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGrossWeightQuantity>%s</%sGrossWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GrossWeightQuantity, input_name='GrossWeightQuantity'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CargoDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CargoDescription')
            value_ = self.gds_validate_string(value_, node, 'CargoDescription')
            self.CargoDescription.append(value_)
            self.CargoDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.CargoDescription[-1])
        elif nodeName_ == 'GrossWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GrossWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GrossWeightQuantity')
            self.GrossWeightQuantity = fval_
            self.GrossWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GrossWeightQuantity)
# end class CargoBaseType


class ContactType(GeneratedsSuper):
    """ContactType -- К
    о
    н
    т
    а
    к
    т
    н
    а
    я
    и
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    Phone -- Н
    о
    м
    е
    р
    т
    е
    л
    е
    ф
    о
    н
    а
    Fax -- Н
    о
    м
    е
    р
    ф
    а
    к
    с
    а
    Telex -- Н
    о
    м
    е
    р
    т
    е
    л
    е
    к
    с
    а
    E_mail -- А
    д
    р
    е
    с
    э
    л
    е
    к
    т
    р
    о
    н
    н
    о
    й
    п
    о
    ч
    т
    ы
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Phone=None, Fax=None, Telex=None, E_mail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        if Phone is None:
            self.Phone = []
        else:
            self.Phone = Phone
        self.Phone_nsprefix_ = "clt_ru"
        self.Fax = Fax
        self.validate_PhoneNumberType(self.Fax)
        self.Fax_nsprefix_ = "clt_ru"
        self.Telex = Telex
        self.validate_PhoneNumberType(self.Telex)
        self.Telex_nsprefix_ = "clt_ru"
        if E_mail is None:
            self.E_mail = []
        else:
            self.E_mail = E_mail
        self.E_mail_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactType.subclass:
            return ContactType.subclass(*args_, **kwargs_)
        else:
            return ContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Phone(self):
        return self.Phone
    def set_Phone(self, Phone):
        self.Phone = Phone
    def add_Phone(self, value):
        self.Phone.append(value)
    def insert_Phone_at(self, index, value):
        self.Phone.insert(index, value)
    def replace_Phone_at(self, index, value):
        self.Phone[index] = value
    def get_Fax(self):
        return self.Fax
    def set_Fax(self, Fax):
        self.Fax = Fax
    def get_Telex(self):
        return self.Telex
    def set_Telex(self, Telex):
        self.Telex = Telex
    def get_E_mail(self):
        return self.E_mail
    def set_E_mail(self, E_mail):
        self.E_mail = E_mail
    def add_E_mail(self, value):
        self.E_mail.append(value)
    def insert_E_mail_at(self, index, value):
        self.E_mail.insert(index, value)
    def replace_E_mail_at(self, index, value):
        self.E_mail[index] = value
    def validate_PhoneNumberType(self, value):
        result = True
        # Validate type PhoneNumberType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PhoneNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PhoneNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Phone or
            self.Fax is not None or
            self.Telex is not None or
            self.E_mail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContactType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='ContactType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContactType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Phone_ in self.Phone:
            namespaceprefix_ = self.Phone_nsprefix_ + ':' if (UseCapturedNS_ and self.Phone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhone>%s</%sPhone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Phone_), input_name='Phone')), namespaceprefix_ , eol_))
        if self.Fax is not None:
            namespaceprefix_ = self.Fax_nsprefix_ + ':' if (UseCapturedNS_ and self.Fax_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFax>%s</%sFax>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Fax), input_name='Fax')), namespaceprefix_ , eol_))
        if self.Telex is not None:
            namespaceprefix_ = self.Telex_nsprefix_ + ':' if (UseCapturedNS_ and self.Telex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTelex>%s</%sTelex>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Telex), input_name='Telex')), namespaceprefix_ , eol_))
        for E_mail_ in self.E_mail:
            namespaceprefix_ = self.E_mail_nsprefix_ + ':' if (UseCapturedNS_ and self.E_mail_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sE_mail>%s</%sE_mail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(E_mail_), input_name='E_mail')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Phone')
            value_ = self.gds_validate_string(value_, node, 'Phone')
            self.Phone.append(value_)
            self.Phone_nsprefix_ = child_.prefix
            # validate type PhoneNumberType
            self.validate_PhoneNumberType(self.Phone[-1])
        elif nodeName_ == 'Fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Fax')
            value_ = self.gds_validate_string(value_, node, 'Fax')
            self.Fax = value_
            self.Fax_nsprefix_ = child_.prefix
            # validate type PhoneNumberType
            self.validate_PhoneNumberType(self.Fax)
        elif nodeName_ == 'Telex':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Telex')
            value_ = self.gds_validate_string(value_, node, 'Telex')
            self.Telex = value_
            self.Telex_nsprefix_ = child_.prefix
            # validate type PhoneNumberType
            self.validate_PhoneNumberType(self.Telex)
        elif nodeName_ == 'E_mail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'E_mail')
            value_ = self.gds_validate_string(value_, node, 'E_mail')
            self.E_mail.append(value_)
            self.E_mail_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.E_mail[-1])
# end class ContactType


class CustomsPersonType(GeneratedsSuper):
    """CustomsPersonType -- Д
    о
    л
    ж
    н
    о
    с
    т
    н
    о
    е
    л
    и
    ц
    о
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    PersonName -- Ф
    И
    О
    д
    о
    л
    ж
    н
    о
    с
    т
    н
    о
    г
    о
    л
    и
    ц
    а
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    LNP -- Л
    Н
    П
    д
    о
    л
    ж
    н
    о
    с
    т
    н
    о
    г
    о
    л
    и
    ц
    а
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    CustomsCode -- К
    о
    д
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    ,
    у
    к
    а
    з
    а
    н
    н
    ы
    й
    н
    а
    о
    т
    т
    и
    с
    к
    е
    Л
    Н
    П
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PersonName=None, LNP=None, CustomsCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.PersonName = PersonName
        self.validate_NameType(self.PersonName)
        self.PersonName_nsprefix_ = "clt_ru"
        self.LNP = LNP
        self.validate_LNPIDType(self.LNP)
        self.LNP_nsprefix_ = "clt_ru"
        self.CustomsCode = CustomsCode
        self.validate_CustomsCodeType(self.CustomsCode)
        self.CustomsCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomsPersonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomsPersonType.subclass:
            return CustomsPersonType.subclass(*args_, **kwargs_)
        else:
            return CustomsPersonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PersonName(self):
        return self.PersonName
    def set_PersonName(self, PersonName):
        self.PersonName = PersonName
    def get_LNP(self):
        return self.LNP
    def set_LNP(self, LNP):
        self.LNP = LNP
    def get_CustomsCode(self):
        return self.CustomsCode
    def set_CustomsCode(self, CustomsCode):
        self.CustomsCode = CustomsCode
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_LNPIDType(self, value):
        result = True
        # Validate type LNPIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LNPIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LNPIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CustomsCodeType(self, value):
        result = True
        # Validate type CustomsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CustomsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CustomsCodeType_patterns_, ))
                result = False
        return result
    validate_CustomsCodeType_patterns_ = [['^([0-9]{2}|[0-9]{5}|[0-9]{8})$']]
    def has__content(self):
        if (
            self.PersonName is not None or
            self.LNP is not None or
            self.CustomsCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CustomsPersonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomsPersonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomsPersonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomsPersonType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomsPersonType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CustomsPersonType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CustomsPersonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PersonName is not None:
            namespaceprefix_ = self.PersonName_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonName>%s</%sPersonName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonName), input_name='PersonName')), namespaceprefix_ , eol_))
        if self.LNP is not None:
            namespaceprefix_ = self.LNP_nsprefix_ + ':' if (UseCapturedNS_ and self.LNP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLNP>%s</%sLNP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LNP), input_name='LNP')), namespaceprefix_ , eol_))
        if self.CustomsCode is not None:
            namespaceprefix_ = self.CustomsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomsCode>%s</%sCustomsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CustomsCode), input_name='CustomsCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PersonName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonName')
            value_ = self.gds_validate_string(value_, node, 'PersonName')
            self.PersonName = value_
            self.PersonName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.PersonName)
        elif nodeName_ == 'LNP':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'LNP')
            value_ = self.gds_validate_string(value_, node, 'LNP')
            self.LNP = value_
            self.LNP_nsprefix_ = child_.prefix
            # validate type LNPIDType
            self.validate_LNPIDType(self.LNP)
        elif nodeName_ == 'CustomsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CustomsCode')
            value_ = self.gds_validate_string(value_, node, 'CustomsCode')
            self.CustomsCode = value_
            self.CustomsCode_nsprefix_ = child_.prefix
            # validate type CustomsCodeType
            self.validate_CustomsCodeType(self.CustomsCode)
# end class CustomsPersonType


class CustomsType(GeneratedsSuper):
    """CustomsType -- К
    о
    д
    и
    н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    Code -- К
    о
    д
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    OfficeName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Code=None, OfficeName=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.Code = Code
        self.validate_CustomsCodeType(self.Code)
        self.Code_nsprefix_ = "clt_ru"
        self.OfficeName = OfficeName
        self.validate_CustomsOfficeNameType(self.OfficeName)
        self.OfficeName_nsprefix_ = "clt_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomsType.subclass:
            return CustomsType.subclass(*args_, **kwargs_)
        else:
            return CustomsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Code(self):
        return self.Code
    def set_Code(self, Code):
        self.Code = Code
    def get_OfficeName(self):
        return self.OfficeName
    def set_OfficeName(self, OfficeName):
        self.OfficeName = OfficeName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_CustomsCodeType(self, value):
        result = True
        # Validate type CustomsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CustomsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CustomsCodeType_patterns_, ))
                result = False
        return result
    validate_CustomsCodeType_patterns_ = [['^([0-9]{2}|[0-9]{5}|[0-9]{8})$']]
    def validate_CustomsOfficeNameType(self, value):
        result = True
        # Validate type CustomsOfficeNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CustomsOfficeNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CustomsOfficeNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Code is not None or
            self.OfficeName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CustomsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CustomsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CustomsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ':' if (UseCapturedNS_ and self.Code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode>%s</%sCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), namespaceprefix_ , eol_))
        if self.OfficeName is not None:
            namespaceprefix_ = self.OfficeName_nsprefix_ + ':' if (UseCapturedNS_ and self.OfficeName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOfficeName>%s</%sOfficeName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OfficeName), input_name='OfficeName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Code':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'Code')
            value_ = self.gds_validate_string(value_, node, 'Code')
            self.Code = value_
            self.Code_nsprefix_ = child_.prefix
            # validate type CustomsCodeType
            self.validate_CustomsCodeType(self.Code)
        elif nodeName_ == 'OfficeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OfficeName')
            value_ = self.gds_validate_string(value_, node, 'OfficeName')
            self.OfficeName = value_
            self.OfficeName_nsprefix_ = child_.prefix
            # validate type CustomsOfficeNameType
            self.validate_CustomsOfficeNameType(self.OfficeName)
# end class CustomsType


class DeliveryTermsRUType(GeneratedsSuper):
    """DeliveryTermsRUType -- У
    с
    л
    о
    в
    и
    е
    п
    о
    с
    т
    а
    в
    к
    и
    т
    о
    в
    а
    р
    о
    в
    .
    Д
    л
    я
    Р
    о
    с
    с
    и
    и
    DeliveryPlace -- О
    п
    и
    с
    а
    н
    и
    е
    /
    Н
    а
    з
    в
    а
    н
    и
    е
    г
    е
    о
    г
    р
    а
    ф
    и
    ч
    е
    с
    к
    о
    г
    о
    п
    у
    н
    к
    т
    а
    DeliveryTermsStringCode -- К
    о
    д
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DeliveryPlace=None, DeliveryTermsStringCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.DeliveryPlace = DeliveryPlace
        self.validate_Text50Type(self.DeliveryPlace)
        self.DeliveryPlace_nsprefix_ = "clt_ru"
        self.DeliveryTermsStringCode = DeliveryTermsStringCode
        self.validate_IncotermsDeliveryStringCodeType(self.DeliveryTermsStringCode)
        self.DeliveryTermsStringCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryTermsRUType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryTermsRUType.subclass:
            return DeliveryTermsRUType.subclass(*args_, **kwargs_)
        else:
            return DeliveryTermsRUType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DeliveryPlace(self):
        return self.DeliveryPlace
    def set_DeliveryPlace(self, DeliveryPlace):
        self.DeliveryPlace = DeliveryPlace
    def get_DeliveryTermsStringCode(self):
        return self.DeliveryTermsStringCode
    def set_DeliveryTermsStringCode(self, DeliveryTermsStringCode):
        self.DeliveryTermsStringCode = DeliveryTermsStringCode
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_IncotermsDeliveryStringCodeType(self, value):
        result = True
        # Validate type IncotermsDeliveryStringCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IncotermsDeliveryStringCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IncotermsDeliveryStringCodeType_patterns_, ))
                result = False
        return result
    validate_IncotermsDeliveryStringCodeType_patterns_ = [['^(\\D{3})$']]
    def has__content(self):
        if (
            self.DeliveryPlace is not None or
            self.DeliveryTermsStringCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DeliveryTermsRUType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryTermsRUType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeliveryTermsRUType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeliveryTermsRUType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeliveryTermsRUType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='DeliveryTermsRUType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DeliveryTermsRUType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeliveryPlace is not None:
            namespaceprefix_ = self.DeliveryPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryPlace>%s</%sDeliveryPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryPlace), input_name='DeliveryPlace')), namespaceprefix_ , eol_))
        if self.DeliveryTermsStringCode is not None:
            namespaceprefix_ = self.DeliveryTermsStringCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryTermsStringCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryTermsStringCode>%s</%sDeliveryTermsStringCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTermsStringCode), input_name='DeliveryTermsStringCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DeliveryPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DeliveryPlace')
            value_ = self.gds_validate_string(value_, node, 'DeliveryPlace')
            self.DeliveryPlace = value_
            self.DeliveryPlace_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.DeliveryPlace)
        elif nodeName_ == 'DeliveryTermsStringCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DeliveryTermsStringCode')
            value_ = self.gds_validate_string(value_, node, 'DeliveryTermsStringCode')
            self.DeliveryTermsStringCode = value_
            self.DeliveryTermsStringCode_nsprefix_ = child_.prefix
            # validate type IncotermsDeliveryStringCodeType
            self.validate_IncotermsDeliveryStringCodeType(self.DeliveryTermsStringCode)
# end class DeliveryTermsRUType


class DeliveryTermsType(GeneratedsSuper):
    """DeliveryTermsType -- У
    с
    л
    о
    в
    и
    е
    п
    о
    с
    т
    а
    в
    к
    и
    т
    о
    в
    а
    р
    о
    в
    DeliveryPlace -- О
    п
    и
    с
    а
    н
    и
    е
    /
    Н
    а
    з
    в
    а
    н
    и
    е
    г
    е
    о
    г
    р
    а
    ф
    и
    ч
    е
    с
    к
    о
    г
    о
    п
    у
    н
    к
    т
    а
    DeliveryTermsStringCode -- К
    о
    д
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    DeliveryTermsRBCode -- К
    о
    д
    в
    и
    д
    а
    п
    о
    с
    т
    а
    в
    к
    и
    т
    о
    в
    а
    р
    о
    в
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    в
    и
    д
    о
    в
    п
    о
    с
    т
    а
    в
    о
    к
    т
    о
    в
    а
    р
    о
    в
    ,
    п
    о
    д
    л
    е
    ж
    а
    щ
    и
    х
    у
    ч
    е
    т
    у
    п
    р
    и
    о
    с
    у
    щ
    е
    с
    т
    в
    л
    е
    н
    и
    и
    э
    к
    с
    п
    о
    р
    т
    н
    ы
    х
    о
    п
    е
    р
    а
    ц
    и
    й
    ,
    п
    р
    и
    м
    е
    н
    я
    е
    м
    ы
    м
    в
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    е
    Б
    е
    л
    а
    р
    у
    с
    ь
    TransferPlace -- М
    е
    с
    т
    о
    п
    е
    р
    е
    д
    а
    ч
    и
    т
    о
    в
    а
    р
    а
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    у
    с
    л
    о
    в
    и
    я
    м
    и
    д
    о
    г
    о
    в
    о
    р
    а
    (
    к
    о
    н
    т
    р
    а
    к
    т
    а
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DeliveryPlace=None, DeliveryTermsStringCode=None, DeliveryTermsRBCode=None, TransferPlace=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.DeliveryPlace = DeliveryPlace
        self.validate_Text50Type(self.DeliveryPlace)
        self.DeliveryPlace_nsprefix_ = "clt_ru"
        self.DeliveryTermsStringCode = DeliveryTermsStringCode
        self.validate_IncotermsDeliveryStringCodeType(self.DeliveryTermsStringCode)
        self.DeliveryTermsStringCode_nsprefix_ = "clt_ru"
        self.DeliveryTermsRBCode = DeliveryTermsRBCode
        self.validate_Code2Type(self.DeliveryTermsRBCode)
        self.DeliveryTermsRBCode_nsprefix_ = "clt_ru"
        self.TransferPlace = TransferPlace
        self.validate_FreeText250Type(self.TransferPlace)
        self.TransferPlace_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryTermsType.subclass:
            return DeliveryTermsType.subclass(*args_, **kwargs_)
        else:
            return DeliveryTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DeliveryPlace(self):
        return self.DeliveryPlace
    def set_DeliveryPlace(self, DeliveryPlace):
        self.DeliveryPlace = DeliveryPlace
    def get_DeliveryTermsStringCode(self):
        return self.DeliveryTermsStringCode
    def set_DeliveryTermsStringCode(self, DeliveryTermsStringCode):
        self.DeliveryTermsStringCode = DeliveryTermsStringCode
    def get_DeliveryTermsRBCode(self):
        return self.DeliveryTermsRBCode
    def set_DeliveryTermsRBCode(self, DeliveryTermsRBCode):
        self.DeliveryTermsRBCode = DeliveryTermsRBCode
    def get_TransferPlace(self):
        return self.TransferPlace
    def set_TransferPlace(self, TransferPlace):
        self.TransferPlace = TransferPlace
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_IncotermsDeliveryStringCodeType(self, value):
        result = True
        # Validate type IncotermsDeliveryStringCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IncotermsDeliveryStringCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IncotermsDeliveryStringCodeType_patterns_, ))
                result = False
        return result
    validate_IncotermsDeliveryStringCodeType_patterns_ = [['^(\\D{3})$']]
    def validate_Code2Type(self, value):
        result = True
        # Validate type Code2Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on Code2Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.DeliveryPlace is not None or
            self.DeliveryTermsStringCode is not None or
            self.DeliveryTermsRBCode is not None or
            self.TransferPlace is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DeliveryTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeliveryTermsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeliveryTermsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeliveryTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='DeliveryTermsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DeliveryTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeliveryPlace is not None:
            namespaceprefix_ = self.DeliveryPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryPlace>%s</%sDeliveryPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryPlace), input_name='DeliveryPlace')), namespaceprefix_ , eol_))
        if self.DeliveryTermsStringCode is not None:
            namespaceprefix_ = self.DeliveryTermsStringCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryTermsStringCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryTermsStringCode>%s</%sDeliveryTermsStringCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTermsStringCode), input_name='DeliveryTermsStringCode')), namespaceprefix_ , eol_))
        if self.DeliveryTermsRBCode is not None:
            namespaceprefix_ = self.DeliveryTermsRBCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryTermsRBCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryTermsRBCode>%s</%sDeliveryTermsRBCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTermsRBCode), input_name='DeliveryTermsRBCode')), namespaceprefix_ , eol_))
        if self.TransferPlace is not None:
            namespaceprefix_ = self.TransferPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.TransferPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransferPlace>%s</%sTransferPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransferPlace), input_name='TransferPlace')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DeliveryPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DeliveryPlace')
            value_ = self.gds_validate_string(value_, node, 'DeliveryPlace')
            self.DeliveryPlace = value_
            self.DeliveryPlace_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.DeliveryPlace)
        elif nodeName_ == 'DeliveryTermsStringCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DeliveryTermsStringCode')
            value_ = self.gds_validate_string(value_, node, 'DeliveryTermsStringCode')
            self.DeliveryTermsStringCode = value_
            self.DeliveryTermsStringCode_nsprefix_ = child_.prefix
            # validate type IncotermsDeliveryStringCodeType
            self.validate_IncotermsDeliveryStringCodeType(self.DeliveryTermsStringCode)
        elif nodeName_ == 'DeliveryTermsRBCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DeliveryTermsRBCode')
            value_ = self.gds_validate_string(value_, node, 'DeliveryTermsRBCode')
            self.DeliveryTermsRBCode = value_
            self.DeliveryTermsRBCode_nsprefix_ = child_.prefix
            # validate type Code2Type
            self.validate_Code2Type(self.DeliveryTermsRBCode)
        elif nodeName_ == 'TransferPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TransferPlace')
            value_ = self.gds_validate_string(value_, node, 'TransferPlace')
            self.TransferPlace = value_
            self.TransferPlace_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.TransferPlace)
# end class DeliveryTermsType


class DimensionsType(GeneratedsSuper):
    """DimensionsType -- Г
    а
    б
    а
    р
    и
    т
    ы
    DimensionsCode -- К
    о
    д
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
      
    * Lenght -- Д
      л
      и
      н
      а
    * Wight -- Ш
      и
      р
      и
      н
      а
    * Height -- В
      ы
      с
      о
      т
      а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DimensionsCode=None, Lenght=None, Wight=None, Height=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.DimensionsCode = DimensionsCode
        self.validate_CodeVariable3Type(self.DimensionsCode)
        self.DimensionsCode_nsprefix_ = "clt_ru"
        self.Lenght = Lenght
        self.validate_Quantity5Type(self.Lenght)
        self.Lenght_nsprefix_ = "clt_ru"
        self.Wight = Wight
        self.validate_Quantity5Type(self.Wight)
        self.Wight_nsprefix_ = "clt_ru"
        self.Height = Height
        self.validate_Quantity5Type(self.Height)
        self.Height_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionsType.subclass:
            return DimensionsType.subclass(*args_, **kwargs_)
        else:
            return DimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DimensionsCode(self):
        return self.DimensionsCode
    def set_DimensionsCode(self, DimensionsCode):
        self.DimensionsCode = DimensionsCode
    def get_Lenght(self):
        return self.Lenght
    def set_Lenght(self, Lenght):
        self.Lenght = Lenght
    def get_Wight(self):
        return self.Wight
    def set_Wight(self, Wight):
        self.Wight = Wight
    def get_Height(self):
        return self.Height
    def set_Height(self, Height):
        self.Height = Height
    def validate_CodeVariable3Type(self, value):
        result = True
        # Validate type CodeVariable3Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CodeVariable3Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CodeVariable3Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_Quantity5Type(self, value):
        result = True
        # Validate type Quantity5Type, a restriction on CategoryCust:IntegerCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Quantity5Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Quantity5Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.DimensionsCode is not None or
            self.Lenght is not None or
            self.Wight is not None or
            self.Height is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DimensionsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DimensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='DimensionsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DimensionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DimensionsCode is not None:
            namespaceprefix_ = self.DimensionsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DimensionsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDimensionsCode>%s</%sDimensionsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DimensionsCode), input_name='DimensionsCode')), namespaceprefix_ , eol_))
        if self.Lenght is not None:
            namespaceprefix_ = self.Lenght_nsprefix_ + ':' if (UseCapturedNS_ and self.Lenght_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLenght>%s</%sLenght>%s' % (namespaceprefix_ , self.gds_format_integer(self.Lenght, input_name='Lenght'), namespaceprefix_ , eol_))
        if self.Wight is not None:
            namespaceprefix_ = self.Wight_nsprefix_ + ':' if (UseCapturedNS_ and self.Wight_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWight>%s</%sWight>%s' % (namespaceprefix_ , self.gds_format_integer(self.Wight, input_name='Wight'), namespaceprefix_ , eol_))
        if self.Height is not None:
            namespaceprefix_ = self.Height_nsprefix_ + ':' if (UseCapturedNS_ and self.Height_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeight>%s</%sHeight>%s' % (namespaceprefix_ , self.gds_format_integer(self.Height, input_name='Height'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DimensionsCode')
            value_ = self.gds_validate_string(value_, node, 'DimensionsCode')
            self.DimensionsCode = value_
            self.DimensionsCode_nsprefix_ = child_.prefix
            # validate type CodeVariable3Type
            self.validate_CodeVariable3Type(self.DimensionsCode)
        elif nodeName_ == 'Lenght' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Lenght')
            ival_ = self.gds_validate_integer(ival_, node, 'Lenght')
            self.Lenght = ival_
            self.Lenght_nsprefix_ = child_.prefix
            # validate type Quantity5Type
            self.validate_Quantity5Type(self.Lenght)
        elif nodeName_ == 'Wight' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Wight')
            ival_ = self.gds_validate_integer(ival_, node, 'Wight')
            self.Wight = ival_
            self.Wight_nsprefix_ = child_.prefix
            # validate type Quantity5Type
            self.validate_Quantity5Type(self.Wight)
        elif nodeName_ == 'Height' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Height')
            ival_ = self.gds_validate_integer(ival_, node, 'Height')
            self.Height = ival_
            self.Height_nsprefix_ = child_.prefix
            # validate type Quantity5Type
            self.validate_Quantity5Type(self.Height)
# end class DimensionsType


class DocumentBaseType(GeneratedsSuper):
    """DocumentBaseType -- Б
    а
    з
    о
    в
    ы
    й
    к
    л
    а
    с
    с
    д
    л
    я
    у
    к
    а
    з
    а
    н
    и
    я
    д
    о
    к
    у
    м
    е
    н
    т
    о
    в
    .
    Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    ,
    н
    о
    м
    е
    р
    ,
    д
    а
    т
    а
    PrDocumentName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    д
    о
    к
    у
    м
    е
    н
    т
    а
    PrDocumentNumber -- Н
    о
    м
    е
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    PrDocumentDate -- Д
    а
    т
    а
    д
    о
    к
    у
    м
    е
    н
    т
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PrDocumentName=None, PrDocumentNumber=None, PrDocumentDate=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.PrDocumentName = PrDocumentName
        self.validate_DocumentNameType(self.PrDocumentName)
        self.PrDocumentName_nsprefix_ = "clt_ru"
        self.PrDocumentNumber = PrDocumentNumber
        self.validate_DocumentNumberType(self.PrDocumentNumber)
        self.PrDocumentNumber_nsprefix_ = "clt_ru"
        if isinstance(PrDocumentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PrDocumentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PrDocumentDate
        self.PrDocumentDate = initvalue_
        self.PrDocumentDate_nsprefix_ = "clt_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentBaseType.subclass:
            return DocumentBaseType.subclass(*args_, **kwargs_)
        else:
            return DocumentBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PrDocumentName(self):
        return self.PrDocumentName
    def set_PrDocumentName(self, PrDocumentName):
        self.PrDocumentName = PrDocumentName
    def get_PrDocumentNumber(self):
        return self.PrDocumentNumber
    def set_PrDocumentNumber(self, PrDocumentNumber):
        self.PrDocumentNumber = PrDocumentNumber
    def get_PrDocumentDate(self):
        return self.PrDocumentDate
    def set_PrDocumentDate(self, PrDocumentDate):
        self.PrDocumentDate = PrDocumentDate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DocumentNameType(self, value):
        result = True
        # Validate type DocumentNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DocumentNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DocumentNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DocumentNumberType(self, value):
        result = True
        # Validate type DocumentNumberType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DocumentNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DocumentNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.PrDocumentName is not None or
            self.PrDocumentNumber is not None or
            self.PrDocumentDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DocumentBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='DocumentBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DocumentBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrDocumentName is not None:
            namespaceprefix_ = self.PrDocumentName_nsprefix_ + ':' if (UseCapturedNS_ and self.PrDocumentName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrDocumentName>%s</%sPrDocumentName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PrDocumentName), input_name='PrDocumentName')), namespaceprefix_ , eol_))
        if self.PrDocumentNumber is not None:
            namespaceprefix_ = self.PrDocumentNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.PrDocumentNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrDocumentNumber>%s</%sPrDocumentNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PrDocumentNumber), input_name='PrDocumentNumber')), namespaceprefix_ , eol_))
        if self.PrDocumentDate is not None:
            namespaceprefix_ = self.PrDocumentDate_nsprefix_ + ':' if (UseCapturedNS_ and self.PrDocumentDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrDocumentDate>%s</%sPrDocumentDate>%s' % (namespaceprefix_ , self.gds_format_date(self.PrDocumentDate, input_name='PrDocumentDate'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PrDocumentName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PrDocumentName')
            value_ = self.gds_validate_string(value_, node, 'PrDocumentName')
            self.PrDocumentName = value_
            self.PrDocumentName_nsprefix_ = child_.prefix
            # validate type DocumentNameType
            self.validate_DocumentNameType(self.PrDocumentName)
        elif nodeName_ == 'PrDocumentNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PrDocumentNumber')
            value_ = self.gds_validate_string(value_, node, 'PrDocumentNumber')
            self.PrDocumentNumber = value_
            self.PrDocumentNumber_nsprefix_ = child_.prefix
            # validate type DocumentNumberType
            self.validate_DocumentNumberType(self.PrDocumentNumber)
        elif nodeName_ == 'PrDocumentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PrDocumentDate = dval_
            self.PrDocumentDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.PrDocumentDate)
# end class DocumentBaseType


class GTDID5Type(GeneratedsSuper):
    """GTDID5Type -- Р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    .
    П
    р
    и
    м
    е
    н
    я
    е
    т
    с
    я
    д
    л
    я
    в
    с
    е
    х
    д
    о
    к
    у
    м
    е
    н
    т
    о
    в
    ,
    и
    м
    е
    ю
    щ
    и
    х
    с
    т
    р
    у
    к
    т
    у
    р
    у
    н
    о
    м
    е
    р
    а
    ,
    а
    н
    а
    л
    о
    г
    и
    ч
    н
    у
    ю
    с
    т
    р
    у
    к
    т
    у
    р
    е
    н
    о
    м
    е
    р
    а
    Д
    Т
    .
    П
    о
    с
    л
    е
    д
    н
    и
    й
    э
    л
    е
    м
    е
    н
    т
    5
    з
    н
    а
    к
    о
    в
    CustomsCode -- К
    о
    д
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    ,
    з
    а
    р
    е
    г
    и
    с
    т
    р
    и
    р
    о
    в
    а
    в
    ш
    е
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    RegistrationDate -- Д
    а
    т
    а
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    д
    о
    к
    у
    м
    е
    н
    т
    а
    SerialNumber -- П
    о
    р
    я
    д
    к
    о
    в
    ы
    й
    н
    о
    м
    е
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    п
    о
    ж
    у
    р
    н
    а
    л
    у
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CustomsCode=None, RegistrationDate=None, SerialNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.CustomsCode = CustomsCode
        self.validate_CustomsCodeType(self.CustomsCode)
        self.CustomsCode_nsprefix_ = "clt_ru"
        if isinstance(RegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RegistrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RegistrationDate
        self.RegistrationDate = initvalue_
        self.RegistrationDate_nsprefix_ = "clt_ru"
        self.SerialNumber = SerialNumber
        self.validate_Code5Type(self.SerialNumber)
        self.SerialNumber_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GTDID5Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GTDID5Type.subclass:
            return GTDID5Type.subclass(*args_, **kwargs_)
        else:
            return GTDID5Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomsCode(self):
        return self.CustomsCode
    def set_CustomsCode(self, CustomsCode):
        self.CustomsCode = CustomsCode
    def get_RegistrationDate(self):
        return self.RegistrationDate
    def set_RegistrationDate(self, RegistrationDate):
        self.RegistrationDate = RegistrationDate
    def get_SerialNumber(self):
        return self.SerialNumber
    def set_SerialNumber(self, SerialNumber):
        self.SerialNumber = SerialNumber
    def validate_CustomsCodeType(self, value):
        result = True
        # Validate type CustomsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CustomsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CustomsCodeType_patterns_, ))
                result = False
        return result
    validate_CustomsCodeType_patterns_ = [['^([0-9]{2}|[0-9]{5}|[0-9]{8})$']]
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Code5Type(self, value):
        result = True
        # Validate type Code5Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on Code5Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CustomsCode is not None or
            self.RegistrationDate is not None or
            self.SerialNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GTDID5Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GTDID5Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GTDID5Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GTDID5Type')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GTDID5Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='GTDID5Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GTDID5Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomsCode is not None:
            namespaceprefix_ = self.CustomsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomsCode>%s</%sCustomsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CustomsCode), input_name='CustomsCode')), namespaceprefix_ , eol_))
        if self.RegistrationDate is not None:
            namespaceprefix_ = self.RegistrationDate_nsprefix_ + ':' if (UseCapturedNS_ and self.RegistrationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegistrationDate>%s</%sRegistrationDate>%s' % (namespaceprefix_ , self.gds_format_date(self.RegistrationDate, input_name='RegistrationDate'), namespaceprefix_ , eol_))
        if self.SerialNumber is not None:
            namespaceprefix_ = self.SerialNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.SerialNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSerialNumber>%s</%sSerialNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SerialNumber), input_name='SerialNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CustomsCode')
            value_ = self.gds_validate_string(value_, node, 'CustomsCode')
            self.CustomsCode = value_
            self.CustomsCode_nsprefix_ = child_.prefix
            # validate type CustomsCodeType
            self.validate_CustomsCodeType(self.CustomsCode)
        elif nodeName_ == 'RegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RegistrationDate = dval_
            self.RegistrationDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.RegistrationDate)
        elif nodeName_ == 'SerialNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SerialNumber')
            value_ = self.gds_validate_string(value_, node, 'SerialNumber')
            self.SerialNumber = value_
            self.SerialNumber_nsprefix_ = child_.prefix
            # validate type Code5Type
            self.validate_Code5Type(self.SerialNumber)
# end class GTDID5Type


class GTDID6Type(GeneratedsSuper):
    """GTDID6Type -- Р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    .
    П
    р
    и
    м
    е
    н
    я
    е
    т
    с
    я
    д
    л
    я
    в
    с
    е
    х
    д
    о
    к
    у
    м
    е
    н
    т
    о
    в
    ,
    и
    м
    е
    ю
    щ
    и
    х
    с
    т
    р
    у
    к
    т
    у
    р
    у
    н
    о
    м
    е
    р
    а
    ,
    а
    н
    а
    л
    о
    г
    и
    ч
    н
    у
    ю
    с
    т
    р
    у
    к
    т
    у
    р
    е
    н
    о
    м
    е
    р
    а
    Д
    Т
    .
    П
    о
    с
    л
    е
    д
    н
    и
    й
    э
    л
    е
    м
    е
    н
    т
    6
    з
    н
    а
    к
    о
    в
    CustomsCode -- К
    о
    д
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    ,
    з
    а
    р
    е
    г
    и
    с
    т
    р
    и
    р
    о
    в
    а
    в
    ш
    е
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    RegistrationDate -- Д
    а
    т
    а
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    д
    о
    к
    у
    м
    е
    н
    т
    а
    SerialNumber -- П
    о
    р
    я
    д
    к
    о
    в
    ы
    й
    н
    о
    м
    е
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    п
    о
    ж
    у
    р
    н
    а
    л
    у
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CustomsCode=None, RegistrationDate=None, SerialNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.CustomsCode = CustomsCode
        self.validate_CustomsCodeType(self.CustomsCode)
        self.CustomsCode_nsprefix_ = "clt_ru"
        if isinstance(RegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RegistrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RegistrationDate
        self.RegistrationDate = initvalue_
        self.RegistrationDate_nsprefix_ = "clt_ru"
        self.SerialNumber = SerialNumber
        self.validate_Code6Type(self.SerialNumber)
        self.SerialNumber_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GTDID6Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GTDID6Type.subclass:
            return GTDID6Type.subclass(*args_, **kwargs_)
        else:
            return GTDID6Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomsCode(self):
        return self.CustomsCode
    def set_CustomsCode(self, CustomsCode):
        self.CustomsCode = CustomsCode
    def get_RegistrationDate(self):
        return self.RegistrationDate
    def set_RegistrationDate(self, RegistrationDate):
        self.RegistrationDate = RegistrationDate
    def get_SerialNumber(self):
        return self.SerialNumber
    def set_SerialNumber(self, SerialNumber):
        self.SerialNumber = SerialNumber
    def validate_CustomsCodeType(self, value):
        result = True
        # Validate type CustomsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CustomsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CustomsCodeType_patterns_, ))
                result = False
        return result
    validate_CustomsCodeType_patterns_ = [['^([0-9]{2}|[0-9]{5}|[0-9]{8})$']]
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Code6Type(self, value):
        result = True
        # Validate type Code6Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on Code6Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CustomsCode is not None or
            self.RegistrationDate is not None or
            self.SerialNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GTDID6Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GTDID6Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GTDID6Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GTDID6Type')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GTDID6Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='GTDID6Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GTDID6Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomsCode is not None:
            namespaceprefix_ = self.CustomsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomsCode>%s</%sCustomsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CustomsCode), input_name='CustomsCode')), namespaceprefix_ , eol_))
        if self.RegistrationDate is not None:
            namespaceprefix_ = self.RegistrationDate_nsprefix_ + ':' if (UseCapturedNS_ and self.RegistrationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegistrationDate>%s</%sRegistrationDate>%s' % (namespaceprefix_ , self.gds_format_date(self.RegistrationDate, input_name='RegistrationDate'), namespaceprefix_ , eol_))
        if self.SerialNumber is not None:
            namespaceprefix_ = self.SerialNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.SerialNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSerialNumber>%s</%sSerialNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SerialNumber), input_name='SerialNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CustomsCode')
            value_ = self.gds_validate_string(value_, node, 'CustomsCode')
            self.CustomsCode = value_
            self.CustomsCode_nsprefix_ = child_.prefix
            # validate type CustomsCodeType
            self.validate_CustomsCodeType(self.CustomsCode)
        elif nodeName_ == 'RegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RegistrationDate = dval_
            self.RegistrationDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.RegistrationDate)
        elif nodeName_ == 'SerialNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SerialNumber')
            value_ = self.gds_validate_string(value_, node, 'SerialNumber')
            self.SerialNumber = value_
            self.SerialNumber_nsprefix_ = child_.prefix
            # validate type Code6Type
            self.validate_Code6Type(self.SerialNumber)
# end class GTDID6Type


class GTDIDType1(GeneratedsSuper):
    """GTDIDType1 -- Р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    .
    П
    р
    и
    м
    е
    н
    я
    е
    т
    с
    я
    д
    л
    я
    в
    с
    е
    х
    д
    о
    к
    у
    м
    е
    н
    т
    о
    в
    ,
    и
    м
    е
    ю
    щ
    и
    х
    с
    т
    р
    у
    к
    т
    у
    р
    у
    н
    о
    м
    е
    р
    а
    ,
    с
    о
    в
    п
    а
    д
    а
    ю
    щ
    у
    ю
    с
    о
    с
    т
    р
    у
    к
    т
    у
    р
    о
    й
    н
    о
    м
    е
    р
    а
    Д
    Т
    CustomsCode -- К
    о
    д
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    ,
    з
    а
    р
    е
    г
    и
    с
    т
    р
    и
    р
    о
    в
    а
    в
    ш
    е
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    RegistrationDate -- Д
    а
    т
    а
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    д
    о
    к
    у
    м
    е
    н
    т
    а
    GTDNumber -- П
    о
    р
    я
    д
    к
    о
    в
    ы
    й
    н
    о
    м
    е
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    п
    о
    ж
    у
    р
    н
    а
    л
    у
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CustomsCode=None, RegistrationDate=None, GTDNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.CustomsCode = CustomsCode
        self.validate_CustomsCodeType(self.CustomsCode)
        self.CustomsCode_nsprefix_ = "clt_ru"
        if isinstance(RegistrationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RegistrationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RegistrationDate
        self.RegistrationDate = initvalue_
        self.RegistrationDate_nsprefix_ = "clt_ru"
        self.GTDNumber = GTDNumber
        self.validate_GTDIDType(self.GTDNumber)
        self.GTDNumber_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GTDIDType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GTDIDType1.subclass:
            return GTDIDType1.subclass(*args_, **kwargs_)
        else:
            return GTDIDType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomsCode(self):
        return self.CustomsCode
    def set_CustomsCode(self, CustomsCode):
        self.CustomsCode = CustomsCode
    def get_RegistrationDate(self):
        return self.RegistrationDate
    def set_RegistrationDate(self, RegistrationDate):
        self.RegistrationDate = RegistrationDate
    def get_GTDNumber(self):
        return self.GTDNumber
    def set_GTDNumber(self, GTDNumber):
        self.GTDNumber = GTDNumber
    def validate_CustomsCodeType(self, value):
        result = True
        # Validate type CustomsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CustomsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CustomsCodeType_patterns_, ))
                result = False
        return result
    validate_CustomsCodeType_patterns_ = [['^([0-9]{2}|[0-9]{5}|[0-9]{8})$']]
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_GTDIDType(self, value):
        result = True
        # Validate type GTDIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GTDIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on GTDIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CustomsCode is not None or
            self.RegistrationDate is not None or
            self.GTDNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GTDIDType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GTDIDType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GTDIDType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GTDIDType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GTDIDType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='GTDIDType1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GTDIDType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomsCode is not None:
            namespaceprefix_ = self.CustomsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomsCode>%s</%sCustomsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CustomsCode), input_name='CustomsCode')), namespaceprefix_ , eol_))
        if self.RegistrationDate is not None:
            namespaceprefix_ = self.RegistrationDate_nsprefix_ + ':' if (UseCapturedNS_ and self.RegistrationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegistrationDate>%s</%sRegistrationDate>%s' % (namespaceprefix_ , self.gds_format_date(self.RegistrationDate, input_name='RegistrationDate'), namespaceprefix_ , eol_))
        if self.GTDNumber is not None:
            namespaceprefix_ = self.GTDNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.GTDNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGTDNumber>%s</%sGTDNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GTDNumber), input_name='GTDNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CustomsCode')
            value_ = self.gds_validate_string(value_, node, 'CustomsCode')
            self.CustomsCode = value_
            self.CustomsCode_nsprefix_ = child_.prefix
            # validate type CustomsCodeType
            self.validate_CustomsCodeType(self.CustomsCode)
        elif nodeName_ == 'RegistrationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RegistrationDate = dval_
            self.RegistrationDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.RegistrationDate)
        elif nodeName_ == 'GTDNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'GTDNumber')
            value_ = self.gds_validate_string(value_, node, 'GTDNumber')
            self.GTDNumber = value_
            self.GTDNumber_nsprefix_ = child_.prefix
            # validate type GTDIDType
            self.validate_GTDIDType(self.GTDNumber)
# end class GTDIDType1


class GoodsBaseType(GeneratedsSuper):
    """GoodsBaseType -- Б
    а
    з
    о
    в
    ы
    й
    т
    и
    п
    о
    п
    и
    с
    а
    н
    и
    я
    т
    о
    в
    а
    р
    а
    GoodsNumeric -- Н
    о
    м
    е
    р
    т
    о
    в
    а
    р
    а
    п
    о
    п
    о
    р
    я
    д
    к
    у
    GoodsTNVEDCode -- К
    о
    д
    т
    о
    в
    а
    р
    а
    п
    о
    Т
    Н
    В
    Э
    Д
    Е
    А
    Э
    С
    GoodsDescription -- О
    п
    и
    с
    а
    н
    и
    е
    т
    о
    в
    а
    р
    а
    GrossWeightQuantity -- В
    е
    с
    т
    о
    в
    а
    р
    а
    б
    р
    у
    т
    т
    о
    (
    к
    г
    )
    NetWeightQuantity -- В
    е
    с
    т
    о
    в
    а
    р
    а
    н
    е
    т
    т
    о
    (
    к
    г
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GoodsNumeric=None, GoodsTNVEDCode=None, GoodsDescription=None, GrossWeightQuantity=None, NetWeightQuantity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.GoodsNumeric = GoodsNumeric
        self.validate_Count5Type(self.GoodsNumeric)
        self.GoodsNumeric_nsprefix_ = "clt_ru"
        self.GoodsTNVEDCode = GoodsTNVEDCode
        self.validate_GoodsNomenclatureCodeType(self.GoodsTNVEDCode)
        self.GoodsTNVEDCode_nsprefix_ = "clt_ru"
        if GoodsDescription is None:
            self.GoodsDescription = []
        else:
            self.GoodsDescription = GoodsDescription
        self.GoodsDescription_nsprefix_ = "clt_ru"
        self.GrossWeightQuantity = GrossWeightQuantity
        self.validate_QuantityBasisType(self.GrossWeightQuantity)
        self.GrossWeightQuantity_nsprefix_ = "clt_ru"
        self.NetWeightQuantity = NetWeightQuantity
        self.validate_QuantityBasisType(self.NetWeightQuantity)
        self.NetWeightQuantity_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GoodsBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GoodsBaseType.subclass:
            return GoodsBaseType.subclass(*args_, **kwargs_)
        else:
            return GoodsBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GoodsNumeric(self):
        return self.GoodsNumeric
    def set_GoodsNumeric(self, GoodsNumeric):
        self.GoodsNumeric = GoodsNumeric
    def get_GoodsTNVEDCode(self):
        return self.GoodsTNVEDCode
    def set_GoodsTNVEDCode(self, GoodsTNVEDCode):
        self.GoodsTNVEDCode = GoodsTNVEDCode
    def get_GoodsDescription(self):
        return self.GoodsDescription
    def set_GoodsDescription(self, GoodsDescription):
        self.GoodsDescription = GoodsDescription
    def add_GoodsDescription(self, value):
        self.GoodsDescription.append(value)
    def insert_GoodsDescription_at(self, index, value):
        self.GoodsDescription.insert(index, value)
    def replace_GoodsDescription_at(self, index, value):
        self.GoodsDescription[index] = value
    def get_GrossWeightQuantity(self):
        return self.GrossWeightQuantity
    def set_GrossWeightQuantity(self, GrossWeightQuantity):
        self.GrossWeightQuantity = GrossWeightQuantity
    def get_NetWeightQuantity(self):
        return self.NetWeightQuantity
    def set_NetWeightQuantity(self, NetWeightQuantity):
        self.NetWeightQuantity = NetWeightQuantity
    def validate_Count5Type(self, value):
        result = True
        # Validate type Count5Type, a restriction on CategoryCust:IntegerCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Count5Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Count5Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_GoodsNomenclatureCodeType(self, value):
        result = True
        # Validate type GoodsNomenclatureCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_GoodsNomenclatureCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_GoodsNomenclatureCodeType_patterns_, ))
                result = False
        return result
    validate_GoodsNomenclatureCodeType_patterns_ = [['^(\\d{4,10})$']]
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.GoodsNumeric is not None or
            self.GoodsTNVEDCode is not None or
            self.GoodsDescription or
            self.GrossWeightQuantity is not None or
            self.NetWeightQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GoodsBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GoodsBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GoodsBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GoodsBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GoodsBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='GoodsBaseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GoodsBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GoodsNumeric is not None:
            namespaceprefix_ = self.GoodsNumeric_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsNumeric_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsNumeric>%s</%sGoodsNumeric>%s' % (namespaceprefix_ , self.gds_format_integer(self.GoodsNumeric, input_name='GoodsNumeric'), namespaceprefix_ , eol_))
        if self.GoodsTNVEDCode is not None:
            namespaceprefix_ = self.GoodsTNVEDCode_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsTNVEDCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsTNVEDCode>%s</%sGoodsTNVEDCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsTNVEDCode), input_name='GoodsTNVEDCode')), namespaceprefix_ , eol_))
        for GoodsDescription_ in self.GoodsDescription:
            namespaceprefix_ = self.GoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsDescription>%s</%sGoodsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(GoodsDescription_), input_name='GoodsDescription')), namespaceprefix_ , eol_))
        if self.GrossWeightQuantity is not None:
            namespaceprefix_ = self.GrossWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GrossWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGrossWeightQuantity>%s</%sGrossWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GrossWeightQuantity, input_name='GrossWeightQuantity'), namespaceprefix_ , eol_))
        if self.NetWeightQuantity is not None:
            namespaceprefix_ = self.NetWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.NetWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetWeightQuantity>%s</%sNetWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NetWeightQuantity, input_name='NetWeightQuantity'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GoodsNumeric' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'GoodsNumeric')
            ival_ = self.gds_validate_integer(ival_, node, 'GoodsNumeric')
            self.GoodsNumeric = ival_
            self.GoodsNumeric_nsprefix_ = child_.prefix
            # validate type Count5Type
            self.validate_Count5Type(self.GoodsNumeric)
        elif nodeName_ == 'GoodsTNVEDCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'GoodsTNVEDCode')
            value_ = self.gds_validate_string(value_, node, 'GoodsTNVEDCode')
            self.GoodsTNVEDCode = value_
            self.GoodsTNVEDCode_nsprefix_ = child_.prefix
            # validate type GoodsNomenclatureCodeType
            self.validate_GoodsNomenclatureCodeType(self.GoodsTNVEDCode)
        elif nodeName_ == 'GoodsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsDescription')
            value_ = self.gds_validate_string(value_, node, 'GoodsDescription')
            self.GoodsDescription.append(value_)
            self.GoodsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.GoodsDescription[-1])
        elif nodeName_ == 'GrossWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GrossWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GrossWeightQuantity')
            self.GrossWeightQuantity = fval_
            self.GrossWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GrossWeightQuantity)
        elif nodeName_ == 'NetWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NetWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'NetWeightQuantity')
            self.NetWeightQuantity = fval_
            self.NetWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.NetWeightQuantity)
# end class GoodsBaseType


class ITNKZType(GeneratedsSuper):
    """ITNKZType -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    т
    а
    м
    о
    ж
    е
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    (
    И
    Т
    Н
    )
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    а
    К
    а
    з
    а
    х
    с
    т
    а
    н
    CategoryCode -- К
    а
    т
    е
    г
    о
    р
    и
    я
    л
    и
    ц
    а
    .
    Д
    в
    у
    х
    з
    н
    а
    ч
    н
    ы
    й
    ц
    и
    ф
    р
    о
    в
    о
    й
    к
    о
    д
    к
    а
    т
    е
    г
    о
    р
    и
    и
    л
    и
    ц
    а
    с
    о
    г
    л
    а
    с
    н
    о
    у
    ч
    р
    е
    д
    и
    т
    е
    л
    ь
    н
    ы
    м
    д
    о
    к
    у
    м
    е
    н
    т
    а
    м
    и
    л
    и
    с
    в
    и
    д
    е
    т
    е
    л
    ь
    с
    т
    в
    у
    о
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    в
    к
    а
    ч
    е
    с
    т
    в
    е
    и
    н
    д
    и
    в
    и
    д
    у
    а
    л
    ь
    н
    о
    г
    о
    п
    р
    е
    д
    п
    р
    и
    н
    и
    м
    а
    т
    е
    л
    я
    KATOCode -- К
    о
    д
    К
    А
    Т
    О
    .
    Д
    в
    у
    х
    з
    н
    а
    ч
    н
    ы
    й
    к
    о
    д
    К
    А
    Т
    О
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    о
    м
    к
    о
    д
    о
    в
    а
    д
    м
    и
    н
    и
    с
    т
    р
    а
    т
    и
    в
    н
    о
    -
    т
    е
    р
    р
    и
    т
    о
    р
    и
    а
    л
    ь
    н
    ы
    х
    о
    б
    ъ
    е
    к
    т
    о
    в
    RNN -- Р
    Н
    Н
    .
    Р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    а
    л
    о
    г
    о
    в
    ы
    й
    н
    о
    м
    е
    р
    ,
    п
    р
    и
    с
    в
    а
    и
    в
    а
    е
    м
    ы
    й
    н
    а
    л
    о
    г
    о
    в
    ы
    м
    и
    о
    р
    г
    а
    н
    а
    м
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    К
    а
    з
    а
    х
    с
    т
    а
    н
    ITNReserv -- Р
    е
    з
    е
    р
    в
    д
    л
    я
    И
    Т
    Н
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CategoryCode=None, KATOCode=None, RNN=None, ITNReserv=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.CategoryCode = CategoryCode
        self.validate_Code2Type(self.CategoryCode)
        self.CategoryCode_nsprefix_ = "clt_ru"
        self.KATOCode = KATOCode
        self.validate_Code2Type(self.KATOCode)
        self.KATOCode_nsprefix_ = "clt_ru"
        self.RNN = RNN
        self.validate_RNNIDType(self.RNN)
        self.RNN_nsprefix_ = "clt_ru"
        self.ITNReserv = ITNReserv
        self.validate_ITNReservType(self.ITNReserv)
        self.ITNReserv_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ITNKZType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ITNKZType.subclass:
            return ITNKZType.subclass(*args_, **kwargs_)
        else:
            return ITNKZType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CategoryCode(self):
        return self.CategoryCode
    def set_CategoryCode(self, CategoryCode):
        self.CategoryCode = CategoryCode
    def get_KATOCode(self):
        return self.KATOCode
    def set_KATOCode(self, KATOCode):
        self.KATOCode = KATOCode
    def get_RNN(self):
        return self.RNN
    def set_RNN(self, RNN):
        self.RNN = RNN
    def get_ITNReserv(self):
        return self.ITNReserv
    def set_ITNReserv(self, ITNReserv):
        self.ITNReserv = ITNReserv
    def validate_Code2Type(self, value):
        result = True
        # Validate type Code2Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on Code2Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_RNNIDType(self, value):
        result = True
        # Validate type RNNIDType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on RNNIDType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ITNReservType(self, value):
        result = True
        # Validate type ITNReservType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 36:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ITNReservType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ITNReservType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CategoryCode is not None or
            self.KATOCode is not None or
            self.RNN is not None or
            self.ITNReserv is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ITNKZType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ITNKZType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ITNKZType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ITNKZType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ITNKZType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='ITNKZType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ITNKZType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CategoryCode is not None:
            namespaceprefix_ = self.CategoryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CategoryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategoryCode>%s</%sCategoryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CategoryCode), input_name='CategoryCode')), namespaceprefix_ , eol_))
        if self.KATOCode is not None:
            namespaceprefix_ = self.KATOCode_nsprefix_ + ':' if (UseCapturedNS_ and self.KATOCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKATOCode>%s</%sKATOCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KATOCode), input_name='KATOCode')), namespaceprefix_ , eol_))
        if self.RNN is not None:
            namespaceprefix_ = self.RNN_nsprefix_ + ':' if (UseCapturedNS_ and self.RNN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRNN>%s</%sRNN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RNN), input_name='RNN')), namespaceprefix_ , eol_))
        if self.ITNReserv is not None:
            namespaceprefix_ = self.ITNReserv_nsprefix_ + ':' if (UseCapturedNS_ and self.ITNReserv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sITNReserv>%s</%sITNReserv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ITNReserv), input_name='ITNReserv')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CategoryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CategoryCode')
            value_ = self.gds_validate_string(value_, node, 'CategoryCode')
            self.CategoryCode = value_
            self.CategoryCode_nsprefix_ = child_.prefix
            # validate type Code2Type
            self.validate_Code2Type(self.CategoryCode)
        elif nodeName_ == 'KATOCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'KATOCode')
            value_ = self.gds_validate_string(value_, node, 'KATOCode')
            self.KATOCode = value_
            self.KATOCode_nsprefix_ = child_.prefix
            # validate type Code2Type
            self.validate_Code2Type(self.KATOCode)
        elif nodeName_ == 'RNN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'RNN')
            value_ = self.gds_validate_string(value_, node, 'RNN')
            self.RNN = value_
            self.RNN_nsprefix_ = child_.prefix
            # validate type RNNIDType
            self.validate_RNNIDType(self.RNN)
        elif nodeName_ == 'ITNReserv':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ITNReserv')
            value_ = self.gds_validate_string(value_, node, 'ITNReserv')
            self.ITNReserv = value_
            self.ITNReserv_nsprefix_ = child_.prefix
            # validate type ITNReservType
            self.validate_ITNReservType(self.ITNReserv)
# end class ITNKZType


class IdentityCardType(GeneratedsSuper):
    """IdentityCardType -- Д
    о
    к
    у
    м
    е
    н
    т
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    и
    й
    л
    и
    ч
    н
    о
    с
    т
    ь
    (
    и
    с
    п
    о
    л
    ь
    з
    у
    е
    т
    с
    я
    д
    о
    в
    е
    р
    с
    и
    и
    А
    Ф
    5.14.3)
    IdentityCardCode -- К
    о
    д
    в
    и
    д
    а
    д
    о
    к
    у
    м
    е
    н
    т
    а
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    е
    г
    о
    л
    и
    ч
    н
    о
    с
    т
    ь
    .
    Д
    л
    я
    Р
    Ф
    IdentityCardName -- К
    р
    а
    т
    к
    о
    е
    н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    д
    о
    к
    у
    м
    е
    н
    т
    а
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    е
    г
    о
    л
    и
    ч
    н
    о
    с
    т
    ь
    IdentityCardSeries -- С
    е
    р
    и
    я
    д
    о
    к
    у
    м
    е
    н
    т
    а
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    е
    г
    о
    л
    и
    ч
    н
    о
    с
    т
    ь
    IdentityCardNumber -- Н
    о
    м
    е
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    е
    г
    о
    л
    и
    ч
    н
    о
    с
    т
    ь
    IdentityCardDate -- Д
    а
    т
    а
    в
    ы
    д
    а
    ч
    и
    д
    о
    к
    у
    м
    е
    н
    т
    а
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    е
    г
    о
    л
    и
    ч
    н
    о
    с
    т
    ь
    OrganizationName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    ,
    в
    ы
    д
    а
    в
    ш
    е
    й
    д
    о
    к
    у
    м
    е
    н
    т
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IdentityCardCode=None, IdentityCardName=None, IdentityCardSeries=None, IdentityCardNumber=None, IdentityCardDate=None, OrganizationName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.IdentityCardCode = IdentityCardCode
        self.validate_IdentityCardCodeType(self.IdentityCardCode)
        self.IdentityCardCode_nsprefix_ = "clt_ru"
        self.IdentityCardName = IdentityCardName
        self.validate_IdentityCardNameType(self.IdentityCardName)
        self.IdentityCardName_nsprefix_ = "clt_ru"
        self.IdentityCardSeries = IdentityCardSeries
        self.validate_IdentityCardSeriesType(self.IdentityCardSeries)
        self.IdentityCardSeries_nsprefix_ = "clt_ru"
        self.IdentityCardNumber = IdentityCardNumber
        self.validate_IdentityCardNumberType(self.IdentityCardNumber)
        self.IdentityCardNumber_nsprefix_ = "clt_ru"
        if isinstance(IdentityCardDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(IdentityCardDate, '%Y-%m-%d').date()
        else:
            initvalue_ = IdentityCardDate
        self.IdentityCardDate = initvalue_
        self.IdentityCardDate_nsprefix_ = "clt_ru"
        self.OrganizationName = OrganizationName
        self.validate_NameType(self.OrganizationName)
        self.OrganizationName_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentityCardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentityCardType.subclass:
            return IdentityCardType.subclass(*args_, **kwargs_)
        else:
            return IdentityCardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IdentityCardCode(self):
        return self.IdentityCardCode
    def set_IdentityCardCode(self, IdentityCardCode):
        self.IdentityCardCode = IdentityCardCode
    def get_IdentityCardName(self):
        return self.IdentityCardName
    def set_IdentityCardName(self, IdentityCardName):
        self.IdentityCardName = IdentityCardName
    def get_IdentityCardSeries(self):
        return self.IdentityCardSeries
    def set_IdentityCardSeries(self, IdentityCardSeries):
        self.IdentityCardSeries = IdentityCardSeries
    def get_IdentityCardNumber(self):
        return self.IdentityCardNumber
    def set_IdentityCardNumber(self, IdentityCardNumber):
        self.IdentityCardNumber = IdentityCardNumber
    def get_IdentityCardDate(self):
        return self.IdentityCardDate
    def set_IdentityCardDate(self, IdentityCardDate):
        self.IdentityCardDate = IdentityCardDate
    def get_OrganizationName(self):
        return self.OrganizationName
    def set_OrganizationName(self, OrganizationName):
        self.OrganizationName = OrganizationName
    def validate_IdentityCardCodeType(self, value):
        result = True
        # Validate type IdentityCardCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IdentityCardCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IdentityCardCodeType_patterns_, ))
                result = False
        return result
    validate_IdentityCardCodeType_patterns_ = [['^(\\d{2})$']]
    def validate_IdentityCardNameType(self, value):
        result = True
        # Validate type IdentityCardNameType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IdentityCardNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on IdentityCardNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_IdentityCardSeriesType(self, value):
        result = True
        # Validate type IdentityCardSeriesType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IdentityCardSeriesType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on IdentityCardSeriesType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_IdentityCardNumberType(self, value):
        result = True
        # Validate type IdentityCardNumberType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IdentityCardNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on IdentityCardNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.IdentityCardCode is not None or
            self.IdentityCardName is not None or
            self.IdentityCardSeries is not None or
            self.IdentityCardNumber is not None or
            self.IdentityCardDate is not None or
            self.OrganizationName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='IdentityCardType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentityCardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentityCardType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentityCardType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentityCardType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='IdentityCardType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='IdentityCardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IdentityCardCode is not None:
            namespaceprefix_ = self.IdentityCardCode_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCardCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentityCardCode>%s</%sIdentityCardCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IdentityCardCode), input_name='IdentityCardCode')), namespaceprefix_ , eol_))
        if self.IdentityCardName is not None:
            namespaceprefix_ = self.IdentityCardName_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCardName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentityCardName>%s</%sIdentityCardName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IdentityCardName), input_name='IdentityCardName')), namespaceprefix_ , eol_))
        if self.IdentityCardSeries is not None:
            namespaceprefix_ = self.IdentityCardSeries_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCardSeries_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentityCardSeries>%s</%sIdentityCardSeries>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IdentityCardSeries), input_name='IdentityCardSeries')), namespaceprefix_ , eol_))
        if self.IdentityCardNumber is not None:
            namespaceprefix_ = self.IdentityCardNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCardNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentityCardNumber>%s</%sIdentityCardNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IdentityCardNumber), input_name='IdentityCardNumber')), namespaceprefix_ , eol_))
        if self.IdentityCardDate is not None:
            namespaceprefix_ = self.IdentityCardDate_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCardDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentityCardDate>%s</%sIdentityCardDate>%s' % (namespaceprefix_ , self.gds_format_date(self.IdentityCardDate, input_name='IdentityCardDate'), namespaceprefix_ , eol_))
        if self.OrganizationName is not None:
            namespaceprefix_ = self.OrganizationName_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganizationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationName>%s</%sOrganizationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganizationName), input_name='OrganizationName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IdentityCardCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'IdentityCardCode')
            value_ = self.gds_validate_string(value_, node, 'IdentityCardCode')
            self.IdentityCardCode = value_
            self.IdentityCardCode_nsprefix_ = child_.prefix
            # validate type IdentityCardCodeType
            self.validate_IdentityCardCodeType(self.IdentityCardCode)
        elif nodeName_ == 'IdentityCardName':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'IdentityCardName')
            value_ = self.gds_validate_string(value_, node, 'IdentityCardName')
            self.IdentityCardName = value_
            self.IdentityCardName_nsprefix_ = child_.prefix
            # validate type IdentityCardNameType
            self.validate_IdentityCardNameType(self.IdentityCardName)
        elif nodeName_ == 'IdentityCardSeries':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'IdentityCardSeries')
            value_ = self.gds_validate_string(value_, node, 'IdentityCardSeries')
            self.IdentityCardSeries = value_
            self.IdentityCardSeries_nsprefix_ = child_.prefix
            # validate type IdentityCardSeriesType
            self.validate_IdentityCardSeriesType(self.IdentityCardSeries)
        elif nodeName_ == 'IdentityCardNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'IdentityCardNumber')
            value_ = self.gds_validate_string(value_, node, 'IdentityCardNumber')
            self.IdentityCardNumber = value_
            self.IdentityCardNumber_nsprefix_ = child_.prefix
            # validate type IdentityCardNumberType
            self.validate_IdentityCardNumberType(self.IdentityCardNumber)
        elif nodeName_ == 'IdentityCardDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.IdentityCardDate = dval_
            self.IdentityCardDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.IdentityCardDate)
        elif nodeName_ == 'OrganizationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationName')
            value_ = self.gds_validate_string(value_, node, 'OrganizationName')
            self.OrganizationName = value_
            self.OrganizationName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.OrganizationName)
# end class IdentityCardType


class KGOrganizationFeaturesType(GeneratedsSuper):
    """KGOrganizationFeaturesType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    К
    ы
    р
    г
    ы
    з
    с
    к
    о
    й
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    KGINN -- И
    Н
    Н
    -
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    а
    л
    о
    г
    о
    в
    ы
    й
    н
    о
    м
    е
    р
    н
    а
    л
    о
    г
    о
    п
    л
    а
    т
    е
    л
    ь
    щ
    и
    к
    а
    ,
    П
    И
    Н
    -
    п
    е
    р
    с
    о
    н
    а
    л
    ь
    н
    ы
    й
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    KGOKPO -- К
    о
    д
    О
    б
    щ
    е
    р
    е
    с
    п
    у
    б
    л
    и
    к
    а
    н
    с
    к
    о
    г
    о
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    а
    п
    р
    е
    д
    п
    р
    и
    я
    т
    и
    й
    и
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    й
    (
    О
    К
    П
    О
    )
    д
    л
    я
    ю
    р
    и
    д
    и
    ч
    е
    с
    к
    и
    х
    л
    и
    ц
    и
    и
    н
    д
    и
    в
    и
    д
    у
    а
    л
    ь
    н
    ы
    х
    п
    р
    е
    д
    п
    р
    и
    н
    и
    м
    а
    т
    е
    л
    е
    й
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, KGINN=None, KGOKPO=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.KGINN = KGINN
        self.validate_KGINNIDType(self.KGINN)
        self.KGINN_nsprefix_ = "clt_ru"
        self.KGOKPO = KGOKPO
        self.validate_KGOKPOIDType(self.KGOKPO)
        self.KGOKPO_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KGOrganizationFeaturesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KGOrganizationFeaturesType.subclass:
            return KGOrganizationFeaturesType.subclass(*args_, **kwargs_)
        else:
            return KGOrganizationFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_KGINN(self):
        return self.KGINN
    def set_KGINN(self, KGINN):
        self.KGINN = KGINN
    def get_KGOKPO(self):
        return self.KGOKPO
    def set_KGOKPO(self, KGOKPO):
        self.KGOKPO = KGOKPO
    def validate_KGINNIDType(self, value):
        result = True
        # Validate type KGINNIDType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_KGINNIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_KGINNIDType_patterns_, ))
                result = False
        return result
    validate_KGINNIDType_patterns_ = [['^(\\d{14})$']]
    def validate_KGOKPOIDType(self, value):
        result = True
        # Validate type KGOKPOIDType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_KGOKPOIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_KGOKPOIDType_patterns_, ))
                result = False
        return result
    validate_KGOKPOIDType_patterns_ = [['^(\\d{8})$']]
    def has__content(self):
        if (
            self.KGINN is not None or
            self.KGOKPO is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='KGOrganizationFeaturesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KGOrganizationFeaturesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KGOrganizationFeaturesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KGOrganizationFeaturesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KGOrganizationFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='KGOrganizationFeaturesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='KGOrganizationFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KGINN is not None:
            namespaceprefix_ = self.KGINN_nsprefix_ + ':' if (UseCapturedNS_ and self.KGINN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKGINN>%s</%sKGINN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KGINN), input_name='KGINN')), namespaceprefix_ , eol_))
        if self.KGOKPO is not None:
            namespaceprefix_ = self.KGOKPO_nsprefix_ + ':' if (UseCapturedNS_ and self.KGOKPO_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKGOKPO>%s</%sKGOKPO>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KGOKPO), input_name='KGOKPO')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'KGINN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'KGINN')
            value_ = self.gds_validate_string(value_, node, 'KGINN')
            self.KGINN = value_
            self.KGINN_nsprefix_ = child_.prefix
            # validate type KGINNIDType
            self.validate_KGINNIDType(self.KGINN)
        elif nodeName_ == 'KGOKPO':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'KGOKPO')
            value_ = self.gds_validate_string(value_, node, 'KGOKPO')
            self.KGOKPO = value_
            self.KGOKPO_nsprefix_ = child_.prefix
            # validate type KGOKPOIDType
            self.validate_KGOKPOIDType(self.KGOKPO)
# end class KGOrganizationFeaturesType


class OrganizationBaseType(GeneratedsSuper):
    """OrganizationBaseType -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    Б
    а
    з
    о
    в
    ы
    й
    к
    л
    а
    с
    с
    OrganizationName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    /
    Ф
    И
    О
    ф
    и
    з
    и
    ч
    е
    с
    к
    о
    г
    о
    л
    и
    ц
    а
    ShortName -- К
    р
    а
    т
    к
    о
    е
    н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    OrganizationLanguage -- К
    о
    д
    я
    з
    ы
    к
    а
    д
    л
    я
    з
    а
    п
    о
    л
    н
    е
    н
    и
    я
    н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    я
      
    * RFOrganizationFeatures -- С
      в
      е
      д
      е
      н
      и
      я
      о
      б
      о
      р
      г
      а
      н
      и
      з
      а
      ц
      и
      и
      .
      О
      с
      о
      б
      е
      н
      н
      о
      с
      т
      и
      Р
      о
      с
      с
      и
      й
      с
      к
      о
      й
      Ф
      е
      д
      е
      р
      а
      ц
      и
      и
    * RKOrganizationFeatures -- С
      в
      е
      д
      е
      н
      и
      я
      о
      б
      о
      р
      г
      а
      н
      и
      з
      а
      ц
      и
      и
      .
      О
      с
      о
      б
      е
      н
      н
      о
      с
      т
      и
      Р
      е
      с
      п
      у
      б
      л
      и
      к
      и
      К
      а
      з
      а
      х
      с
      т
      а
      н
    * RBOrganizationFeatures -- С
      в
      е
      д
      е
      н
      и
      я
      о
      б
      о
      р
      г
      а
      н
      и
      з
      а
      ц
      и
      и
      .
      О
      с
      о
      б
      е
      н
      н
      о
      с
      т
      и
      Р
      е
      с
      п
      у
      б
      л
      и
      к
      и
      Б
      е
      л
      а
      р
      у
      с
      ь
    * RAOrganizationFeatures -- С
      в
      е
      д
      е
      н
      и
      я
      о
      б
      о
      р
      г
      а
      н
      и
      з
      а
      ц
      и
      и
      .
      О
      с
      о
      б
      е
      н
      н
      о
      с
      т
      и
      Р
      е
      с
      п
      у
      б
      л
      и
      к
      и
      А
      р
      м
      е
      н
      и
      я
    * KGOrganizationFeatures -- С
      в
      е
      д
      е
      н
      и
      я
      о
      б
      о
      р
      г
      а
      н
      и
      з
      а
      ц
      и
      и
      .
      О
      с
      о
      б
      е
      н
      н
      о
      с
      т
      и
      К
      ы
      р
      г
      ы
      з
      с
      к
      о
      й
      Р
      е
      с
      п
      у
      б
      л
      и
      к
      и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OrganizationName=None, ShortName=None, OrganizationLanguage=None, RFOrganizationFeatures=None, RKOrganizationFeatures=None, RBOrganizationFeatures=None, RAOrganizationFeatures=None, KGOrganizationFeatures=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.OrganizationName = OrganizationName
        self.validate_NameType(self.OrganizationName)
        self.OrganizationName_nsprefix_ = "clt_ru"
        self.ShortName = ShortName
        self.validate_ShortNameType(self.ShortName)
        self.ShortName_nsprefix_ = "clt_ru"
        self.OrganizationLanguage = OrganizationLanguage
        self.validate_LanguageCodeType(self.OrganizationLanguage)
        self.OrganizationLanguage_nsprefix_ = "clt_ru"
        self.RFOrganizationFeatures = RFOrganizationFeatures
        self.RFOrganizationFeatures_nsprefix_ = "cat_ru"
        self.RKOrganizationFeatures = RKOrganizationFeatures
        self.RKOrganizationFeatures_nsprefix_ = "cat_ru"
        self.RBOrganizationFeatures = RBOrganizationFeatures
        self.RBOrganizationFeatures_nsprefix_ = "cat_ru"
        self.RAOrganizationFeatures = RAOrganizationFeatures
        self.RAOrganizationFeatures_nsprefix_ = "cat_ru"
        self.KGOrganizationFeatures = KGOrganizationFeatures
        self.KGOrganizationFeatures_nsprefix_ = "cat_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationBaseType.subclass:
            return OrganizationBaseType.subclass(*args_, **kwargs_)
        else:
            return OrganizationBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OrganizationName(self):
        return self.OrganizationName
    def set_OrganizationName(self, OrganizationName):
        self.OrganizationName = OrganizationName
    def get_ShortName(self):
        return self.ShortName
    def set_ShortName(self, ShortName):
        self.ShortName = ShortName
    def get_OrganizationLanguage(self):
        return self.OrganizationLanguage
    def set_OrganizationLanguage(self, OrganizationLanguage):
        self.OrganizationLanguage = OrganizationLanguage
    def get_RFOrganizationFeatures(self):
        return self.RFOrganizationFeatures
    def set_RFOrganizationFeatures(self, RFOrganizationFeatures):
        self.RFOrganizationFeatures = RFOrganizationFeatures
    def get_RKOrganizationFeatures(self):
        return self.RKOrganizationFeatures
    def set_RKOrganizationFeatures(self, RKOrganizationFeatures):
        self.RKOrganizationFeatures = RKOrganizationFeatures
    def get_RBOrganizationFeatures(self):
        return self.RBOrganizationFeatures
    def set_RBOrganizationFeatures(self, RBOrganizationFeatures):
        self.RBOrganizationFeatures = RBOrganizationFeatures
    def get_RAOrganizationFeatures(self):
        return self.RAOrganizationFeatures
    def set_RAOrganizationFeatures(self, RAOrganizationFeatures):
        self.RAOrganizationFeatures = RAOrganizationFeatures
    def get_KGOrganizationFeatures(self):
        return self.KGOrganizationFeatures
    def set_KGOrganizationFeatures(self, KGOrganizationFeatures):
        self.KGOrganizationFeatures = KGOrganizationFeatures
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ShortNameType(self, value):
        result = True
        # Validate type ShortNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 120:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ShortNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ShortNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_LanguageCodeType(self, value):
        result = True
        # Validate type LanguageCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_LanguageCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LanguageCodeType_patterns_, ))
                result = False
        return result
    validate_LanguageCodeType_patterns_ = [['^([A-Z]{2})$']]
    def has__content(self):
        if (
            self.OrganizationName is not None or
            self.ShortName is not None or
            self.OrganizationLanguage is not None or
            self.RFOrganizationFeatures is not None or
            self.RKOrganizationFeatures is not None or
            self.RBOrganizationFeatures is not None or
            self.RAOrganizationFeatures is not None or
            self.KGOrganizationFeatures is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='OrganizationBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganizationBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='OrganizationBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='OrganizationBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganizationName is not None:
            namespaceprefix_ = self.OrganizationName_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganizationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationName>%s</%sOrganizationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganizationName), input_name='OrganizationName')), namespaceprefix_ , eol_))
        if self.ShortName is not None:
            namespaceprefix_ = self.ShortName_nsprefix_ + ':' if (UseCapturedNS_ and self.ShortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShortName>%s</%sShortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ShortName), input_name='ShortName')), namespaceprefix_ , eol_))
        if self.OrganizationLanguage is not None:
            namespaceprefix_ = self.OrganizationLanguage_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganizationLanguage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationLanguage>%s</%sOrganizationLanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganizationLanguage), input_name='OrganizationLanguage')), namespaceprefix_ , eol_))
        if self.RFOrganizationFeatures is not None:
            namespaceprefix_ = self.RFOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RFOrganizationFeatures_nsprefix_) else ''
            self.RFOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RFOrganizationFeatures', pretty_print=pretty_print)
        if self.RKOrganizationFeatures is not None:
            namespaceprefix_ = self.RKOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RKOrganizationFeatures_nsprefix_) else ''
            self.RKOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RKOrganizationFeatures', pretty_print=pretty_print)
        if self.RBOrganizationFeatures is not None:
            namespaceprefix_ = self.RBOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RBOrganizationFeatures_nsprefix_) else ''
            self.RBOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RBOrganizationFeatures', pretty_print=pretty_print)
        if self.RAOrganizationFeatures is not None:
            namespaceprefix_ = self.RAOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.RAOrganizationFeatures_nsprefix_) else ''
            self.RAOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RAOrganizationFeatures', pretty_print=pretty_print)
        if self.KGOrganizationFeatures is not None:
            namespaceprefix_ = self.KGOrganizationFeatures_nsprefix_ + ':' if (UseCapturedNS_ and self.KGOrganizationFeatures_nsprefix_) else ''
            self.KGOrganizationFeatures.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KGOrganizationFeatures', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OrganizationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationName')
            value_ = self.gds_validate_string(value_, node, 'OrganizationName')
            self.OrganizationName = value_
            self.OrganizationName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.OrganizationName)
        elif nodeName_ == 'ShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ShortName')
            value_ = self.gds_validate_string(value_, node, 'ShortName')
            self.ShortName = value_
            self.ShortName_nsprefix_ = child_.prefix
            # validate type ShortNameType
            self.validate_ShortNameType(self.ShortName)
        elif nodeName_ == 'OrganizationLanguage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OrganizationLanguage')
            value_ = self.gds_validate_string(value_, node, 'OrganizationLanguage')
            self.OrganizationLanguage = value_
            self.OrganizationLanguage_nsprefix_ = child_.prefix
            # validate type LanguageCodeType
            self.validate_LanguageCodeType(self.OrganizationLanguage)
        elif nodeName_ == 'RFOrganizationFeatures':
            obj_ = RFOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RFOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RFOrganizationFeatures'
        elif nodeName_ == 'RKOrganizationFeatures':
            obj_ = RKOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RKOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RKOrganizationFeatures'
        elif nodeName_ == 'RBOrganizationFeatures':
            obj_ = RBOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RBOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RBOrganizationFeatures'
        elif nodeName_ == 'RAOrganizationFeatures':
            obj_ = RAOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RAOrganizationFeatures = obj_
            obj_.original_tagname_ = 'RAOrganizationFeatures'
        elif nodeName_ == 'KGOrganizationFeatures':
            obj_ = KGOrganizationFeaturesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KGOrganizationFeatures = obj_
            obj_.original_tagname_ = 'KGOrganizationFeatures'
# end class OrganizationBaseType


class OrganizationType(OrganizationBaseType):
    """OrganizationType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    OKPOID -- К
    о
    д
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    п
    о
    О
    К
    П
    О
    OKATOCode -- К
    о
    д
    О
    К
    А
    Т
    О
    Address -- А
    д
    р
    е
    с
      
    * Contact -- К
      о
      н
      т
      а
      к
      т
      н
      а
      я
      и
      н
      ф
      о
      р
      м
      а
      ц
      и
      я
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = OrganizationBaseType
    def __init__(self, OrganizationName=None, ShortName=None, OrganizationLanguage=None, RFOrganizationFeatures=None, RKOrganizationFeatures=None, RBOrganizationFeatures=None, RAOrganizationFeatures=None, KGOrganizationFeatures=None, OKPOID=None, OKATOCode=None, Address=None, Contact=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("OrganizationType"), self).__init__(OrganizationName, ShortName, OrganizationLanguage, RFOrganizationFeatures, RKOrganizationFeatures, RBOrganizationFeatures, RAOrganizationFeatures, KGOrganizationFeatures, extensiontype_,  **kwargs_)
        self.OKPOID = OKPOID
        self.validate_OKPOIDType(self.OKPOID)
        self.OKPOID_nsprefix_ = "clt_ru"
        self.OKATOCode = OKATOCode
        self.validate_OKATOCodeType(self.OKATOCode)
        self.OKATOCode_nsprefix_ = "clt_ru"
        self.Address = Address
        self.Address_nsprefix_ = "cat_ru"
        self.Contact = Contact
        self.Contact_nsprefix_ = "cat_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OKPOID(self):
        return self.OKPOID
    def set_OKPOID(self, OKPOID):
        self.OKPOID = OKPOID
    def get_OKATOCode(self):
        return self.OKATOCode
    def set_OKATOCode(self, OKATOCode):
        self.OKATOCode = OKATOCode
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def get_Contact(self):
        return self.Contact
    def set_Contact(self, Contact):
        self.Contact = Contact
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_OKPOIDType(self, value):
        result = True
        # Validate type OKPOIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OKPOIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OKPOIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_OKATOCodeType(self, value):
        result = True
        # Validate type OKATOCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_OKATOCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_OKATOCodeType_patterns_, ))
                result = False
        return result
    validate_OKATOCodeType_patterns_ = [['^(\\d{5,11})$']]
    def has__content(self):
        if (
            self.OKPOID is not None or
            self.OKATOCode is not None or
            self.Address is not None or
            self.Contact is not None or
            super(OrganizationType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='OrganizationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganizationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='OrganizationType'):
        super(OrganizationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='OrganizationType', fromsubclass_=False, pretty_print=True):
        super(OrganizationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OKPOID is not None:
            namespaceprefix_ = self.OKPOID_nsprefix_ + ':' if (UseCapturedNS_ and self.OKPOID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOKPOID>%s</%sOKPOID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OKPOID), input_name='OKPOID')), namespaceprefix_ , eol_))
        if self.OKATOCode is not None:
            namespaceprefix_ = self.OKATOCode_nsprefix_ + ':' if (UseCapturedNS_ and self.OKATOCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOKATOCode>%s</%sOKATOCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OKATOCode), input_name='OKATOCode')), namespaceprefix_ , eol_))
        if self.Address is not None:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            self.Address.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        if self.Contact is not None:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            self.Contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OrganizationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OKPOID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OKPOID')
            value_ = self.gds_validate_string(value_, node, 'OKPOID')
            self.OKPOID = value_
            self.OKPOID_nsprefix_ = child_.prefix
            # validate type OKPOIDType
            self.validate_OKPOIDType(self.OKPOID)
        elif nodeName_ == 'OKATOCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OKATOCode')
            value_ = self.gds_validate_string(value_, node, 'OKATOCode')
            self.OKATOCode = value_
            self.OKATOCode_nsprefix_ = child_.prefix
            # validate type OKATOCodeType
            self.validate_OKATOCodeType(self.OKATOCode)
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Contact':
            obj_ = ContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
        super(OrganizationType, self)._buildChildren(child_, node, nodeName_, True)
# end class OrganizationType


class OrganizationWBankType(OrganizationType):
    """OrganizationWBankType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    ,
    в
    к
    л
    ю
    ч
    а
    я
    б
    а
    н
    к
    о
    в
    с
    к
    и
    е
    с
    ч
    е
    т
    а
    BankInformation -- И
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    о
    б
    а
    н
    к
    о
    в
    с
    к
    и
    х
    с
    ч
    е
    т
    а
    х
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = OrganizationType
    def __init__(self, OrganizationName=None, ShortName=None, OrganizationLanguage=None, RFOrganizationFeatures=None, RKOrganizationFeatures=None, RBOrganizationFeatures=None, RAOrganizationFeatures=None, KGOrganizationFeatures=None, OKPOID=None, OKATOCode=None, Address=None, Contact=None, BankInformation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("OrganizationWBankType"), self).__init__(OrganizationName, ShortName, OrganizationLanguage, RFOrganizationFeatures, RKOrganizationFeatures, RBOrganizationFeatures, RAOrganizationFeatures, KGOrganizationFeatures, OKPOID, OKATOCode, Address, Contact,  **kwargs_)
        if BankInformation is None:
            self.BankInformation = []
        else:
            self.BankInformation = BankInformation
        self.BankInformation_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationWBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationWBankType.subclass:
            return OrganizationWBankType.subclass(*args_, **kwargs_)
        else:
            return OrganizationWBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BankInformation(self):
        return self.BankInformation
    def set_BankInformation(self, BankInformation):
        self.BankInformation = BankInformation
    def add_BankInformation(self, value):
        self.BankInformation.append(value)
    def insert_BankInformation_at(self, index, value):
        self.BankInformation.insert(index, value)
    def replace_BankInformation_at(self, index, value):
        self.BankInformation[index] = value
    def has__content(self):
        if (
            self.BankInformation or
            super(OrganizationWBankType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"', name_='OrganizationWBankType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationWBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganizationWBankType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationWBankType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationWBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='OrganizationWBankType'):
        super(OrganizationWBankType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationWBankType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"', name_='OrganizationWBankType', fromsubclass_=False, pretty_print=True):
        super(OrganizationWBankType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BankInformation_ in self.BankInformation:
            namespaceprefix_ = self.BankInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.BankInformation_nsprefix_) else ''
            BankInformation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BankInformation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(OrganizationWBankType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BankInformation':
            obj_ = BankInformationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BankInformation.append(obj_)
            obj_.original_tagname_ = 'BankInformation'
        super(OrganizationWBankType, self)._buildChildren(child_, node, nodeName_, True)
# end class OrganizationWBankType


class PersonBaseType(GeneratedsSuper):
    """PersonBaseType -- Б
    а
    з
    о
    в
    ы
    й
    к
    л
    а
    с
    с
    д
    л
    я
    у
    к
    а
    з
    а
    н
    и
    я
    с
    в
    е
    д
    е
    н
    и
    й
    о
    д
    о
    л
    ж
    н
    о
    с
    т
    н
    о
    м
    л
    и
    ц
    е
    .
    Ф
    И
    О
    ,
    д
    о
    л
    ж
    н
    о
    с
    т
    ь
    PersonSurname -- Ф
    а
    м
    и
    л
    и
    я
    PersonName -- И
    м
    я
    PersonMiddleName -- О
    т
    ч
    е
    с
    т
    в
    о
    PersonPost -- Д
    о
    л
    ж
    н
    о
    с
    т
    ь
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PersonSurname=None, PersonName=None, PersonMiddleName=None, PersonPost=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.PersonSurname = PersonSurname
        self.validate_NameType(self.PersonSurname)
        self.PersonSurname_nsprefix_ = "clt_ru"
        self.PersonName = PersonName
        self.validate_NameType(self.PersonName)
        self.PersonName_nsprefix_ = "clt_ru"
        self.PersonMiddleName = PersonMiddleName
        self.validate_NameType(self.PersonMiddleName)
        self.PersonMiddleName_nsprefix_ = "clt_ru"
        self.PersonPost = PersonPost
        self.validate_PostType(self.PersonPost)
        self.PersonPost_nsprefix_ = "clt_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonBaseType.subclass:
            return PersonBaseType.subclass(*args_, **kwargs_)
        else:
            return PersonBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PersonSurname(self):
        return self.PersonSurname
    def set_PersonSurname(self, PersonSurname):
        self.PersonSurname = PersonSurname
    def get_PersonName(self):
        return self.PersonName
    def set_PersonName(self, PersonName):
        self.PersonName = PersonName
    def get_PersonMiddleName(self):
        return self.PersonMiddleName
    def set_PersonMiddleName(self, PersonMiddleName):
        self.PersonMiddleName = PersonMiddleName
    def get_PersonPost(self):
        return self.PersonPost
    def set_PersonPost(self, PersonPost):
        self.PersonPost = PersonPost
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_PostType(self, value):
        result = True
        # Validate type PostType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PostType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PostType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.PersonSurname is not None or
            self.PersonName is not None or
            self.PersonMiddleName is not None or
            self.PersonPost is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='PersonBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='PersonBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='PersonBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PersonSurname is not None:
            namespaceprefix_ = self.PersonSurname_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonSurname_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonSurname>%s</%sPersonSurname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonSurname), input_name='PersonSurname')), namespaceprefix_ , eol_))
        if self.PersonName is not None:
            namespaceprefix_ = self.PersonName_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonName>%s</%sPersonName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonName), input_name='PersonName')), namespaceprefix_ , eol_))
        if self.PersonMiddleName is not None:
            namespaceprefix_ = self.PersonMiddleName_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonMiddleName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonMiddleName>%s</%sPersonMiddleName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonMiddleName), input_name='PersonMiddleName')), namespaceprefix_ , eol_))
        if self.PersonPost is not None:
            namespaceprefix_ = self.PersonPost_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonPost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonPost>%s</%sPersonPost>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonPost), input_name='PersonPost')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PersonSurname':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonSurname')
            value_ = self.gds_validate_string(value_, node, 'PersonSurname')
            self.PersonSurname = value_
            self.PersonSurname_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.PersonSurname)
        elif nodeName_ == 'PersonName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonName')
            value_ = self.gds_validate_string(value_, node, 'PersonName')
            self.PersonName = value_
            self.PersonName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.PersonName)
        elif nodeName_ == 'PersonMiddleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonMiddleName')
            value_ = self.gds_validate_string(value_, node, 'PersonMiddleName')
            self.PersonMiddleName = value_
            self.PersonMiddleName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.PersonMiddleName)
        elif nodeName_ == 'PersonPost':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonPost')
            value_ = self.gds_validate_string(value_, node, 'PersonPost')
            self.PersonPost = value_
            self.PersonPost_nsprefix_ = child_.prefix
            # validate type PostType
            self.validate_PostType(self.PersonPost)
# end class PersonBaseType


class PersonSignatureType(PersonBaseType):
    """PersonSignatureType -- П
    о
    д
    п
    и
    с
    ь
    IssueDate -- Д
    а
    т
    а
    п
    о
    д
    п
    и
    с
    а
    н
    и
    я
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PersonBaseType
    def __init__(self, PersonSurname=None, PersonName=None, PersonMiddleName=None, PersonPost=None, IssueDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("PersonSignatureType"), self).__init__(PersonSurname, PersonName, PersonMiddleName, PersonPost,  **kwargs_)
        if isinstance(IssueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(IssueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = IssueDate
        self.IssueDate = initvalue_
        self.IssueDate_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonSignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonSignatureType.subclass:
            return PersonSignatureType.subclass(*args_, **kwargs_)
        else:
            return PersonSignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IssueDate(self):
        return self.IssueDate
    def set_IssueDate(self, IssueDate):
        self.IssueDate = IssueDate
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.IssueDate is not None or
            super(PersonSignatureType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='PersonSignatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonSignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonSignatureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonSignatureType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonSignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='PersonSignatureType'):
        super(PersonSignatureType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonSignatureType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='PersonSignatureType', fromsubclass_=False, pretty_print=True):
        super(PersonSignatureType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IssueDate is not None:
            namespaceprefix_ = self.IssueDate_nsprefix_ + ':' if (UseCapturedNS_ and self.IssueDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssueDate>%s</%sIssueDate>%s' % (namespaceprefix_ , self.gds_format_date(self.IssueDate, input_name='IssueDate'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PersonSignatureType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IssueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.IssueDate = dval_
            self.IssueDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.IssueDate)
        super(PersonSignatureType, self)._buildChildren(child_, node, nodeName_, True)
# end class PersonSignatureType


class RAOrganizationFeaturesType(GeneratedsSuper):
    """RAOrganizationFeaturesType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    А
    р
    м
    е
    н
    и
    я
    UNN -- У
    ч
    е
    т
    н
    ы
    й
    н
    о
    м
    е
    р
    н
    а
    л
    о
    г
    о
    п
    л
    а
    т
    е
    л
    ь
    щ
    и
    к
    а
    (
    У
    Н
    Н
    )
    SocialServiceNumber -- Н
    о
    м
    е
    р
    н
    о
    й
    з
    н
    а
    к
    о
    б
    щ
    е
    с
    т
    в
    е
    н
    н
    ы
    х
    у
    с
    л
    у
    г
    (
    Н
    З
    О
    У
    )
    SocialServiceCertificate -- Н
    о
    м
    е
    р
    с
    п
    р
    а
    в
    к
    и
    о
    б
    о
    т
    с
    у
    т
    с
    т
    в
    и
    и
    н
    о
    м
    е
    р
    н
    о
    г
    о
    з
    н
    а
    к
    а
    о
    б
    щ
    е
    с
    т
    в
    е
    н
    н
    ы
    х
    у
    с
    л
    у
    г
    (
    Н
    З
    О
    У
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UNN=None, SocialServiceNumber=None, SocialServiceCertificate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.UNN = UNN
        self.validate_UNNType(self.UNN)
        self.UNN_nsprefix_ = "clt_ru"
        self.SocialServiceNumber = SocialServiceNumber
        self.validate_SocialServiceNumberType(self.SocialServiceNumber)
        self.SocialServiceNumber_nsprefix_ = "clt_ru"
        self.SocialServiceCertificate = SocialServiceCertificate
        self.validate_SocialServiceCertificateType(self.SocialServiceCertificate)
        self.SocialServiceCertificate_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RAOrganizationFeaturesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RAOrganizationFeaturesType.subclass:
            return RAOrganizationFeaturesType.subclass(*args_, **kwargs_)
        else:
            return RAOrganizationFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UNN(self):
        return self.UNN
    def set_UNN(self, UNN):
        self.UNN = UNN
    def get_SocialServiceNumber(self):
        return self.SocialServiceNumber
    def set_SocialServiceNumber(self, SocialServiceNumber):
        self.SocialServiceNumber = SocialServiceNumber
    def get_SocialServiceCertificate(self):
        return self.SocialServiceCertificate
    def set_SocialServiceCertificate(self, SocialServiceCertificate):
        self.SocialServiceCertificate = SocialServiceCertificate
    def validate_UNNType(self, value):
        result = True
        # Validate type UNNType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_UNNType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_UNNType_patterns_, ))
                result = False
        return result
    validate_UNNType_patterns_ = [['^(\\d{8})$']]
    def validate_SocialServiceNumberType(self, value):
        result = True
        # Validate type SocialServiceNumberType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_SocialServiceNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SocialServiceNumberType_patterns_, ))
                result = False
        return result
    validate_SocialServiceNumberType_patterns_ = [['^(\\d{10})$']]
    def validate_SocialServiceCertificateType(self, value):
        result = True
        # Validate type SocialServiceCertificateType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on SocialServiceCertificateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.UNN is not None or
            self.SocialServiceNumber is not None or
            self.SocialServiceCertificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RAOrganizationFeaturesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RAOrganizationFeaturesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RAOrganizationFeaturesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RAOrganizationFeaturesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RAOrganizationFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='RAOrganizationFeaturesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RAOrganizationFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UNN is not None:
            namespaceprefix_ = self.UNN_nsprefix_ + ':' if (UseCapturedNS_ and self.UNN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNN>%s</%sUNN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNN), input_name='UNN')), namespaceprefix_ , eol_))
        if self.SocialServiceNumber is not None:
            namespaceprefix_ = self.SocialServiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.SocialServiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSocialServiceNumber>%s</%sSocialServiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SocialServiceNumber), input_name='SocialServiceNumber')), namespaceprefix_ , eol_))
        if self.SocialServiceCertificate is not None:
            namespaceprefix_ = self.SocialServiceCertificate_nsprefix_ + ':' if (UseCapturedNS_ and self.SocialServiceCertificate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSocialServiceCertificate>%s</%sSocialServiceCertificate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SocialServiceCertificate), input_name='SocialServiceCertificate')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UNN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'UNN')
            value_ = self.gds_validate_string(value_, node, 'UNN')
            self.UNN = value_
            self.UNN_nsprefix_ = child_.prefix
            # validate type UNNType
            self.validate_UNNType(self.UNN)
        elif nodeName_ == 'SocialServiceNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SocialServiceNumber')
            value_ = self.gds_validate_string(value_, node, 'SocialServiceNumber')
            self.SocialServiceNumber = value_
            self.SocialServiceNumber_nsprefix_ = child_.prefix
            # validate type SocialServiceNumberType
            self.validate_SocialServiceNumberType(self.SocialServiceNumber)
        elif nodeName_ == 'SocialServiceCertificate':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SocialServiceCertificate')
            value_ = self.gds_validate_string(value_, node, 'SocialServiceCertificate')
            self.SocialServiceCertificate = value_
            self.SocialServiceCertificate_nsprefix_ = child_.prefix
            # validate type SocialServiceCertificateType
            self.validate_SocialServiceCertificateType(self.SocialServiceCertificate)
# end class RAOrganizationFeaturesType


class RBOrganizationFeaturesType(GeneratedsSuper):
    """RBOrganizationFeaturesType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    Б
    е
    л
    а
    р
    у
    с
    ь
    UNP -- У
    ч
    е
    т
    н
    ы
    й
    н
    о
    м
    е
    р
    п
    л
    а
    т
    е
    л
    ь
    щ
    и
    к
    а
    (
    У
    Н
    П
    )
    RBIdentificationNumber -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    ф
    и
    з
    и
    ч
    е
    с
    к
    о
    г
    о
    л
    и
    ц
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UNP=None, RBIdentificationNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.UNP = UNP
        self.validate_UNPTtype(self.UNP)
        self.UNP_nsprefix_ = "clt_ru"
        self.RBIdentificationNumber = RBIdentificationNumber
        self.validate_CodeVariable14Type(self.RBIdentificationNumber)
        self.RBIdentificationNumber_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RBOrganizationFeaturesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RBOrganizationFeaturesType.subclass:
            return RBOrganizationFeaturesType.subclass(*args_, **kwargs_)
        else:
            return RBOrganizationFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UNP(self):
        return self.UNP
    def set_UNP(self, UNP):
        self.UNP = UNP
    def get_RBIdentificationNumber(self):
        return self.RBIdentificationNumber
    def set_RBIdentificationNumber(self, RBIdentificationNumber):
        self.RBIdentificationNumber = RBIdentificationNumber
    def validate_UNPTtype(self, value):
        result = True
        # Validate type UNPTtype, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_UNPTtype_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_UNPTtype_patterns_, ))
                result = False
        return result
    validate_UNPTtype_patterns_ = [['^(\\d{9})$']]
    def validate_CodeVariable14Type(self, value):
        result = True
        # Validate type CodeVariable14Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CodeVariable14Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CodeVariable14Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.UNP is not None or
            self.RBIdentificationNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RBOrganizationFeaturesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RBOrganizationFeaturesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RBOrganizationFeaturesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RBOrganizationFeaturesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RBOrganizationFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='RBOrganizationFeaturesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RBOrganizationFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UNP is not None:
            namespaceprefix_ = self.UNP_nsprefix_ + ':' if (UseCapturedNS_ and self.UNP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNP>%s</%sUNP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNP), input_name='UNP')), namespaceprefix_ , eol_))
        if self.RBIdentificationNumber is not None:
            namespaceprefix_ = self.RBIdentificationNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.RBIdentificationNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRBIdentificationNumber>%s</%sRBIdentificationNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RBIdentificationNumber), input_name='RBIdentificationNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UNP':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'UNP')
            value_ = self.gds_validate_string(value_, node, 'UNP')
            self.UNP = value_
            self.UNP_nsprefix_ = child_.prefix
            # validate type UNPTtype
            self.validate_UNPTtype(self.UNP)
        elif nodeName_ == 'RBIdentificationNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'RBIdentificationNumber')
            value_ = self.gds_validate_string(value_, node, 'RBIdentificationNumber')
            self.RBIdentificationNumber = value_
            self.RBIdentificationNumber_nsprefix_ = child_.prefix
            # validate type CodeVariable14Type
            self.validate_CodeVariable14Type(self.RBIdentificationNumber)
# end class RBOrganizationFeaturesType


class RFOrganizationFeaturesType(GeneratedsSuper):
    """RFOrganizationFeaturesType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    о
    с
    с
    и
    й
    с
    к
    о
    й
    Ф
    е
    д
    е
    р
    а
    ц
    и
    и
    OGRN -- О
    Г
    Р
    Н
    /
    О
    Г
    Р
    Н
    И
    П
    .
    О
    с
    н
    о
    в
    н
    о
    й
    г
    о
    с
    у
    д
    а
    р
    с
    т
    в
    е
    н
    н
    ы
    й
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    INN -- И
    Н
    Н
    -
    И
    н
    д
    и
    в
    и
    д
    у
    а
    л
    ь
    н
    ы
    й
    н
    о
    м
    е
    р
    н
    а
    л
    о
    г
    о
    п
    л
    а
    т
    е
    л
    ь
    щ
    и
    к
    а
    KPP -- К
    П
    П
    -
    К
    о
    д
    п
    р
    и
    ч
    и
    н
    ы
    п
    о
    с
    т
    а
    н
    о
    в
    к
    и
    н
    а
    у
    ч
    е
    т
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OGRN=None, INN=None, KPP=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.OGRN = OGRN
        self.validate_OGRNIDType(self.OGRN)
        self.OGRN_nsprefix_ = "clt_ru"
        self.INN = INN
        self.validate_INNIDType(self.INN)
        self.INN_nsprefix_ = "clt_ru"
        self.KPP = KPP
        self.validate_KPPCodeType(self.KPP)
        self.KPP_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RFOrganizationFeaturesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RFOrganizationFeaturesType.subclass:
            return RFOrganizationFeaturesType.subclass(*args_, **kwargs_)
        else:
            return RFOrganizationFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OGRN(self):
        return self.OGRN
    def set_OGRN(self, OGRN):
        self.OGRN = OGRN
    def get_INN(self):
        return self.INN
    def set_INN(self, INN):
        self.INN = INN
    def get_KPP(self):
        return self.KPP
    def set_KPP(self, KPP):
        self.KPP = KPP
    def validate_OGRNIDType(self, value):
        result = True
        # Validate type OGRNIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_OGRNIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_OGRNIDType_patterns_, ))
                result = False
        return result
    validate_OGRNIDType_patterns_ = [['^((\\d{15})|(\\d{13}))$']]
    def validate_INNIDType(self, value):
        result = True
        # Validate type INNIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INNIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on INNIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_KPPCodeType(self, value):
        result = True
        # Validate type KPPCodeType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_KPPCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_KPPCodeType_patterns_, ))
                result = False
        return result
    validate_KPPCodeType_patterns_ = [['^(\\d{9})$']]
    def has__content(self):
        if (
            self.OGRN is not None or
            self.INN is not None or
            self.KPP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RFOrganizationFeaturesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RFOrganizationFeaturesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RFOrganizationFeaturesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RFOrganizationFeaturesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RFOrganizationFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='RFOrganizationFeaturesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RFOrganizationFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OGRN is not None:
            namespaceprefix_ = self.OGRN_nsprefix_ + ':' if (UseCapturedNS_ and self.OGRN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOGRN>%s</%sOGRN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OGRN), input_name='OGRN')), namespaceprefix_ , eol_))
        if self.INN is not None:
            namespaceprefix_ = self.INN_nsprefix_ + ':' if (UseCapturedNS_ and self.INN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINN>%s</%sINN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INN), input_name='INN')), namespaceprefix_ , eol_))
        if self.KPP is not None:
            namespaceprefix_ = self.KPP_nsprefix_ + ':' if (UseCapturedNS_ and self.KPP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKPP>%s</%sKPP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KPP), input_name='KPP')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OGRN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OGRN')
            value_ = self.gds_validate_string(value_, node, 'OGRN')
            self.OGRN = value_
            self.OGRN_nsprefix_ = child_.prefix
            # validate type OGRNIDType
            self.validate_OGRNIDType(self.OGRN)
        elif nodeName_ == 'INN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type INNIDType
            self.validate_INNIDType(self.INN)
        elif nodeName_ == 'KPP':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'KPP')
            value_ = self.gds_validate_string(value_, node, 'KPP')
            self.KPP = value_
            self.KPP_nsprefix_ = child_.prefix
            # validate type KPPCodeType
            self.validate_KPPCodeType(self.KPP)
# end class RFOrganizationFeaturesType


class RKOrganizationFeaturesType(GeneratedsSuper):
    """RKOrganizationFeaturesType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    О
    с
    о
    б
    е
    н
    н
    о
    с
    т
    и
    Р
    е
    с
    п
    у
    б
    л
    и
    к
    и
    К
    а
    з
    а
    х
    с
    т
    а
    н
    BIN -- Б
    и
    з
    н
    е
    с
    -
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    (
    Б
    И
    Н
    )
    IIN -- И
    н
    д
    и
    в
    и
    д
    у
    а
    л
    ь
    н
    ы
    й
    и
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    (
    И
    И
    Н
    )
    ITN -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    ц
    и
    о
    н
    н
    ы
    й
    т
    а
    м
    о
    ж
    е
    н
    н
    ы
    й
    н
    о
    м
    е
    р
    (
    И
    Т
    Н
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BIN=None, IIN=None, ITN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.BIN = BIN
        self.validate_BINType(self.BIN)
        self.BIN_nsprefix_ = "clt_ru"
        self.IIN = IIN
        self.validate_IINType(self.IIN)
        self.IIN_nsprefix_ = "clt_ru"
        self.ITN = ITN
        self.ITN_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RKOrganizationFeaturesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RKOrganizationFeaturesType.subclass:
            return RKOrganizationFeaturesType.subclass(*args_, **kwargs_)
        else:
            return RKOrganizationFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BIN(self):
        return self.BIN
    def set_BIN(self, BIN):
        self.BIN = BIN
    def get_IIN(self):
        return self.IIN
    def set_IIN(self, IIN):
        self.IIN = IIN
    def get_ITN(self):
        return self.ITN
    def set_ITN(self, ITN):
        self.ITN = ITN
    def validate_BINType(self, value):
        result = True
        # Validate type BINType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_BINType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BINType_patterns_, ))
                result = False
        return result
    validate_BINType_patterns_ = [['^(\\d{12})$']]
    def validate_IINType(self, value):
        result = True
        # Validate type IINType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IINType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IINType_patterns_, ))
                result = False
        return result
    validate_IINType_patterns_ = [['^(\\d{12})$']]
    def has__content(self):
        if (
            self.BIN is not None or
            self.IIN is not None or
            self.ITN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RKOrganizationFeaturesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RKOrganizationFeaturesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RKOrganizationFeaturesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RKOrganizationFeaturesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RKOrganizationFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='RKOrganizationFeaturesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='RKOrganizationFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BIN is not None:
            namespaceprefix_ = self.BIN_nsprefix_ + ':' if (UseCapturedNS_ and self.BIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIN>%s</%sBIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BIN), input_name='BIN')), namespaceprefix_ , eol_))
        if self.IIN is not None:
            namespaceprefix_ = self.IIN_nsprefix_ + ':' if (UseCapturedNS_ and self.IIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIIN>%s</%sIIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IIN), input_name='IIN')), namespaceprefix_ , eol_))
        if self.ITN is not None:
            namespaceprefix_ = self.ITN_nsprefix_ + ':' if (UseCapturedNS_ and self.ITN_nsprefix_) else ''
            self.ITN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ITN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BIN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BIN')
            value_ = self.gds_validate_string(value_, node, 'BIN')
            self.BIN = value_
            self.BIN_nsprefix_ = child_.prefix
            # validate type BINType
            self.validate_BINType(self.BIN)
        elif nodeName_ == 'IIN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'IIN')
            value_ = self.gds_validate_string(value_, node, 'IIN')
            self.IIN = value_
            self.IIN_nsprefix_ = child_.prefix
            # validate type IINType
            self.validate_IINType(self.IIN)
        elif nodeName_ == 'ITN':
            obj_ = ITNKZType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ITN = obj_
            obj_.original_tagname_ = 'ITN'
# end class RKOrganizationFeaturesType


class SupplementaryQuantityType(GeneratedsSuper):
    """SupplementaryQuantityType -- К
    о
    л
    и
    ч
    е
    с
    т
    в
    о
    в
    д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    о
    й
    е
    д
    и
    н
    и
    ц
    е
    и
    з
    м
    е
    р
    е
    н
    и
    я
    GoodsQuantity -- К
    о
    л
    и
    ч
    е
    с
    т
    в
    о
    т
    о
    в
    а
    р
    а
    в
    е
    д
    и
    н
    и
    ц
    е
    и
    з
    м
    е
    р
    е
    н
    и
    я
    MeasureUnitQualifierName -- У
    с
    л
    о
    в
    н
    о
    е
    о
    б
    о
    з
    н
    а
    ч
    е
    н
    и
    е
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    MeasureUnitQualifierCode -- К
    о
    д
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    е
    д
    и
    н
    и
    ц
    а
    м
    и
    и
    з
    м
    е
    р
    е
    н
    и
    я
    ,
    п
    р
    и
    м
    е
    н
    я
    е
    м
    ы
    м
    и
    в
    Т
    Н
    В
    Э
    Д
    Е
    А
    Э
    С
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GoodsQuantity=None, MeasureUnitQualifierName=None, MeasureUnitQualifierCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.GoodsQuantity = GoodsQuantity
        self.validate_QuantityBasisType(self.GoodsQuantity)
        self.GoodsQuantity_nsprefix_ = "clt_ru"
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
        self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        self.MeasureUnitQualifierName_nsprefix_ = "clt_ru"
        self.MeasureUnitQualifierCode = MeasureUnitQualifierCode
        self.validate_MeasureUnitQualifierCodeType(self.MeasureUnitQualifierCode)
        self.MeasureUnitQualifierCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplementaryQuantityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplementaryQuantityType.subclass:
            return SupplementaryQuantityType.subclass(*args_, **kwargs_)
        else:
            return SupplementaryQuantityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GoodsQuantity(self):
        return self.GoodsQuantity
    def set_GoodsQuantity(self, GoodsQuantity):
        self.GoodsQuantity = GoodsQuantity
    def get_MeasureUnitQualifierName(self):
        return self.MeasureUnitQualifierName
    def set_MeasureUnitQualifierName(self, MeasureUnitQualifierName):
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
    def get_MeasureUnitQualifierCode(self):
        return self.MeasureUnitQualifierCode
    def set_MeasureUnitQualifierCode(self, MeasureUnitQualifierCode):
        self.MeasureUnitQualifierCode = MeasureUnitQualifierCode
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_MeasureUnitQualifierNameType(self, value):
        result = True
        # Validate type MeasureUnitQualifierNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MeasureUnitQualifierNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MeasureUnitQualifierNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MeasureUnitQualifierCodeType(self, value):
        result = True
        # Validate type MeasureUnitQualifierCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on MeasureUnitQualifierCodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.GoodsQuantity is not None or
            self.MeasureUnitQualifierName is not None or
            self.MeasureUnitQualifierCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='SupplementaryQuantityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplementaryQuantityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplementaryQuantityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplementaryQuantityType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplementaryQuantityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='SupplementaryQuantityType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='SupplementaryQuantityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GoodsQuantity is not None:
            namespaceprefix_ = self.GoodsQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsQuantity>%s</%sGoodsQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GoodsQuantity, input_name='GoodsQuantity'), namespaceprefix_ , eol_))
        if self.MeasureUnitQualifierName is not None:
            namespaceprefix_ = self.MeasureUnitQualifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureUnitQualifierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureUnitQualifierName>%s</%sMeasureUnitQualifierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasureUnitQualifierName), input_name='MeasureUnitQualifierName')), namespaceprefix_ , eol_))
        if self.MeasureUnitQualifierCode is not None:
            namespaceprefix_ = self.MeasureUnitQualifierCode_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureUnitQualifierCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureUnitQualifierCode>%s</%sMeasureUnitQualifierCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasureUnitQualifierCode), input_name='MeasureUnitQualifierCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GoodsQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GoodsQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GoodsQuantity')
            self.GoodsQuantity = fval_
            self.GoodsQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GoodsQuantity)
        elif nodeName_ == 'MeasureUnitQualifierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MeasureUnitQualifierName')
            value_ = self.gds_validate_string(value_, node, 'MeasureUnitQualifierName')
            self.MeasureUnitQualifierName = value_
            self.MeasureUnitQualifierName_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierNameType
            self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        elif nodeName_ == 'MeasureUnitQualifierCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'MeasureUnitQualifierCode')
            value_ = self.gds_validate_string(value_, node, 'MeasureUnitQualifierCode')
            self.MeasureUnitQualifierCode = value_
            self.MeasureUnitQualifierCode_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierCodeType
            self.validate_MeasureUnitQualifierCodeType(self.MeasureUnitQualifierCode)
# end class SupplementaryQuantityType


class TransportGoodsBaseType(GeneratedsSuper):
    """TransportGoodsBaseType -- О
    п
    и
    с
    а
    н
    и
    е
    т
    о
    в
    а
    р
    о
    в
    .
    Б
    а
    з
    о
    в
    ы
    й
    GoodsMarking -- Н
    о
    м
    е
    р
    и
    м
    а
    р
    к
    а
    г
    р
    у
    з
    а
    GoodsDescription -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    г
    р
    у
    з
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GoodsMarking=None, GoodsDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.GoodsMarking = GoodsMarking
        self.validate_GoodMarkingType(self.GoodsMarking)
        self.GoodsMarking_nsprefix_ = "clt_ru"
        if GoodsDescription is None:
            self.GoodsDescription = []
        else:
            self.GoodsDescription = GoodsDescription
        self.GoodsDescription_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportGoodsBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportGoodsBaseType.subclass:
            return TransportGoodsBaseType.subclass(*args_, **kwargs_)
        else:
            return TransportGoodsBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GoodsMarking(self):
        return self.GoodsMarking
    def set_GoodsMarking(self, GoodsMarking):
        self.GoodsMarking = GoodsMarking
    def get_GoodsDescription(self):
        return self.GoodsDescription
    def set_GoodsDescription(self, GoodsDescription):
        self.GoodsDescription = GoodsDescription
    def add_GoodsDescription(self, value):
        self.GoodsDescription.append(value)
    def insert_GoodsDescription_at(self, index, value):
        self.GoodsDescription.insert(index, value)
    def replace_GoodsDescription_at(self, index, value):
        self.GoodsDescription[index] = value
    def validate_GoodMarkingType(self, value):
        result = True
        # Validate type GoodMarkingType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GoodMarkingType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on GoodMarkingType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.GoodsMarking is not None or
            self.GoodsDescription
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportGoodsBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransportGoodsBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransportGoodsBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransportGoodsBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransportGoodsBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='TransportGoodsBaseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportGoodsBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GoodsMarking is not None:
            namespaceprefix_ = self.GoodsMarking_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsMarking_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsMarking>%s</%sGoodsMarking>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsMarking), input_name='GoodsMarking')), namespaceprefix_ , eol_))
        for GoodsDescription_ in self.GoodsDescription:
            namespaceprefix_ = self.GoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsDescription>%s</%sGoodsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(GoodsDescription_), input_name='GoodsDescription')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GoodsMarking':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsMarking')
            value_ = self.gds_validate_string(value_, node, 'GoodsMarking')
            self.GoodsMarking = value_
            self.GoodsMarking_nsprefix_ = child_.prefix
            # validate type GoodMarkingType
            self.validate_GoodMarkingType(self.GoodsMarking)
        elif nodeName_ == 'GoodsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsDescription')
            value_ = self.gds_validate_string(value_, node, 'GoodsDescription')
            self.GoodsDescription.append(value_)
            self.GoodsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.GoodsDescription[-1])
# end class TransportGoodsBaseType


class TransportMeansBaseType(GeneratedsSuper):
    """TransportMeansBaseType -- Б
    а
    з
    о
    в
    ы
    й
    т
    и
    п
    д
    л
    я
    о
    п
    и
    с
    а
    н
    и
    я
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    в
    т
    а
    м
    о
    ж
    е
    н
    н
    ы
    х
    д
    о
    к
    у
    м
    е
    н
    т
    а
    х
    VIN -- Н
    о
    м
    е
    р
    ш
    а
    с
    с
    и
    (VIN)
    TransportKindCode -- К
    о
    д
    т
    и
    п
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    TransportTypeName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    т
    и
    п
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    TransportMarkCode -- К
    о
    д
    м
    а
    р
    к
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    TransportIdentifier -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    т
    о
    р
    .
    Н
    о
    м
    е
    р
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    ,
    н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    с
    у
    д
    н
    а
    ,
    н
    о
    м
    е
    р
    а
    в
    и
    а
    р
    е
    й
    с
    а
    ,
    н
    о
    м
    е
    р
    п
    о
    е
    з
    д
    а
    ,
    н
    о
    м
    е
    р
    ж
    е
    л
    е
    з
    н
    о
    д
    о
    р
    о
    ж
    н
    о
    г
    о
    в
    а
    г
    о
    н
    а
    (
    п
    л
    а
    т
    ф
    о
    р
    м
    ,
    ц
    и
    с
    т
    е
    р
    н
    и
    т
    .
    п
    .)
    TransportMeansNationalityCode -- Б
    у
    к
    в
    е
    н
    н
    ы
    й
    к
    о
    д
    с
    т
    р
    а
    н
    ы
    п
    р
    и
    н
    а
    д
    л
    е
    ж
    н
    о
    с
    т
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    п
    о
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    т
    о
    р
    у
    с
    т
    р
    а
    н
    м
    и
    р
    а
    ActiveTransportIdentifier -- И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    т
    о
    р
    а
    к
    т
    и
    в
    н
    о
    г
    о
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    д
    л
    я
    п
    р
    и
    ц
    е
    п
    о
    в
    ,
    п
    о
    л
    у
    п
    р
    и
    ц
    е
    п
    о
    в
    и
    д
    р
    . (
    Р
    е
    з
    е
    р
    в
    )
    TransportRegNumber -- Н
    о
    м
    е
    р
    с
    в
    и
    д
    е
    т
    е
    л
    ь
    с
    т
    в
    а
    о
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    д
    л
    я
    Р
    Б
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VIN=None, TransportKindCode=None, TransportTypeName=None, TransportMarkCode=None, TransportIdentifier=None, TransportMeansNationalityCode=None, ActiveTransportIdentifier=None, TransportRegNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.VIN = VIN
        self.validate_VINIDType(self.VIN)
        self.VIN_nsprefix_ = "clt_ru"
        self.TransportKindCode = TransportKindCode
        self.validate_Code3Type(self.TransportKindCode)
        self.TransportKindCode_nsprefix_ = "clt_ru"
        self.TransportTypeName = TransportTypeName
        self.validate_Text150Type(self.TransportTypeName)
        self.TransportTypeName_nsprefix_ = "clt_ru"
        self.TransportMarkCode = TransportMarkCode
        self.validate_Code3Type(self.TransportMarkCode)
        self.TransportMarkCode_nsprefix_ = "clt_ru"
        self.TransportIdentifier = TransportIdentifier
        self.validate_TransportMeansIDType(self.TransportIdentifier)
        self.TransportIdentifier_nsprefix_ = "clt_ru"
        self.TransportMeansNationalityCode = TransportMeansNationalityCode
        self.validate_CountryA2CodeType(self.TransportMeansNationalityCode)
        self.TransportMeansNationalityCode_nsprefix_ = "clt_ru"
        self.ActiveTransportIdentifier = ActiveTransportIdentifier
        self.validate_TransportMeansIDType(self.ActiveTransportIdentifier)
        self.ActiveTransportIdentifier_nsprefix_ = "clt_ru"
        self.TransportRegNumber = TransportRegNumber
        self.validate_CodeVariable20Type(self.TransportRegNumber)
        self.TransportRegNumber_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportMeansBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportMeansBaseType.subclass:
            return TransportMeansBaseType.subclass(*args_, **kwargs_)
        else:
            return TransportMeansBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VIN(self):
        return self.VIN
    def set_VIN(self, VIN):
        self.VIN = VIN
    def get_TransportKindCode(self):
        return self.TransportKindCode
    def set_TransportKindCode(self, TransportKindCode):
        self.TransportKindCode = TransportKindCode
    def get_TransportTypeName(self):
        return self.TransportTypeName
    def set_TransportTypeName(self, TransportTypeName):
        self.TransportTypeName = TransportTypeName
    def get_TransportMarkCode(self):
        return self.TransportMarkCode
    def set_TransportMarkCode(self, TransportMarkCode):
        self.TransportMarkCode = TransportMarkCode
    def get_TransportIdentifier(self):
        return self.TransportIdentifier
    def set_TransportIdentifier(self, TransportIdentifier):
        self.TransportIdentifier = TransportIdentifier
    def get_TransportMeansNationalityCode(self):
        return self.TransportMeansNationalityCode
    def set_TransportMeansNationalityCode(self, TransportMeansNationalityCode):
        self.TransportMeansNationalityCode = TransportMeansNationalityCode
    def get_ActiveTransportIdentifier(self):
        return self.ActiveTransportIdentifier
    def set_ActiveTransportIdentifier(self, ActiveTransportIdentifier):
        self.ActiveTransportIdentifier = ActiveTransportIdentifier
    def get_TransportRegNumber(self):
        return self.TransportRegNumber
    def set_TransportRegNumber(self, TransportRegNumber):
        self.TransportRegNumber = TransportRegNumber
    def validate_VINIDType(self, value):
        result = True
        # Validate type VINIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on VINIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on VINIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_Code3Type(self, value):
        result = True
        # Validate type Code3Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on Code3Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_Text150Type(self, value):
        result = True
        # Validate type Text150Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text150Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text150Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TransportMeansIDType(self, value):
        result = True
        # Validate type TransportMeansIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TransportMeansIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TransportMeansIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CountryA2CodeType(self, value):
        result = True
        # Validate type CountryA2CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryA2CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryA2CodeType_patterns_, ))
                result = False
        return result
    validate_CountryA2CodeType_patterns_ = [['^([A-Z]{2}|[0]{2}|[9]{2})$']]
    def validate_CodeVariable20Type(self, value):
        result = True
        # Validate type CodeVariable20Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CodeVariable20Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CodeVariable20Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.VIN is not None or
            self.TransportKindCode is not None or
            self.TransportTypeName is not None or
            self.TransportMarkCode is not None or
            self.TransportIdentifier is not None or
            self.TransportMeansNationalityCode is not None or
            self.ActiveTransportIdentifier is not None or
            self.TransportRegNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportMeansBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransportMeansBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransportMeansBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransportMeansBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransportMeansBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='TransportMeansBaseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportMeansBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VIN is not None:
            namespaceprefix_ = self.VIN_nsprefix_ + ':' if (UseCapturedNS_ and self.VIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVIN>%s</%sVIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VIN), input_name='VIN')), namespaceprefix_ , eol_))
        if self.TransportKindCode is not None:
            namespaceprefix_ = self.TransportKindCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportKindCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportKindCode>%s</%sTransportKindCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportKindCode), input_name='TransportKindCode')), namespaceprefix_ , eol_))
        if self.TransportTypeName is not None:
            namespaceprefix_ = self.TransportTypeName_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportTypeName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportTypeName>%s</%sTransportTypeName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportTypeName), input_name='TransportTypeName')), namespaceprefix_ , eol_))
        if self.TransportMarkCode is not None:
            namespaceprefix_ = self.TransportMarkCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportMarkCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportMarkCode>%s</%sTransportMarkCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportMarkCode), input_name='TransportMarkCode')), namespaceprefix_ , eol_))
        if self.TransportIdentifier is not None:
            namespaceprefix_ = self.TransportIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportIdentifier>%s</%sTransportIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportIdentifier), input_name='TransportIdentifier')), namespaceprefix_ , eol_))
        if self.TransportMeansNationalityCode is not None:
            namespaceprefix_ = self.TransportMeansNationalityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportMeansNationalityCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportMeansNationalityCode>%s</%sTransportMeansNationalityCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportMeansNationalityCode), input_name='TransportMeansNationalityCode')), namespaceprefix_ , eol_))
        if self.ActiveTransportIdentifier is not None:
            namespaceprefix_ = self.ActiveTransportIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveTransportIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sActiveTransportIdentifier>%s</%sActiveTransportIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ActiveTransportIdentifier), input_name='ActiveTransportIdentifier')), namespaceprefix_ , eol_))
        if self.TransportRegNumber is not None:
            namespaceprefix_ = self.TransportRegNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportRegNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportRegNumber>%s</%sTransportRegNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TransportRegNumber), input_name='TransportRegNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VIN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'VIN')
            value_ = self.gds_validate_string(value_, node, 'VIN')
            self.VIN = value_
            self.VIN_nsprefix_ = child_.prefix
            # validate type VINIDType
            self.validate_VINIDType(self.VIN)
        elif nodeName_ == 'TransportKindCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportKindCode')
            value_ = self.gds_validate_string(value_, node, 'TransportKindCode')
            self.TransportKindCode = value_
            self.TransportKindCode_nsprefix_ = child_.prefix
            # validate type Code3Type
            self.validate_Code3Type(self.TransportKindCode)
        elif nodeName_ == 'TransportTypeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TransportTypeName')
            value_ = self.gds_validate_string(value_, node, 'TransportTypeName')
            self.TransportTypeName = value_
            self.TransportTypeName_nsprefix_ = child_.prefix
            # validate type Text150Type
            self.validate_Text150Type(self.TransportTypeName)
        elif nodeName_ == 'TransportMarkCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportMarkCode')
            value_ = self.gds_validate_string(value_, node, 'TransportMarkCode')
            self.TransportMarkCode = value_
            self.TransportMarkCode_nsprefix_ = child_.prefix
            # validate type Code3Type
            self.validate_Code3Type(self.TransportMarkCode)
        elif nodeName_ == 'TransportIdentifier':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportIdentifier')
            value_ = self.gds_validate_string(value_, node, 'TransportIdentifier')
            self.TransportIdentifier = value_
            self.TransportIdentifier_nsprefix_ = child_.prefix
            # validate type TransportMeansIDType
            self.validate_TransportMeansIDType(self.TransportIdentifier)
        elif nodeName_ == 'TransportMeansNationalityCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportMeansNationalityCode')
            value_ = self.gds_validate_string(value_, node, 'TransportMeansNationalityCode')
            self.TransportMeansNationalityCode = value_
            self.TransportMeansNationalityCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.TransportMeansNationalityCode)
        elif nodeName_ == 'ActiveTransportIdentifier':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ActiveTransportIdentifier')
            value_ = self.gds_validate_string(value_, node, 'ActiveTransportIdentifier')
            self.ActiveTransportIdentifier = value_
            self.ActiveTransportIdentifier_nsprefix_ = child_.prefix
            # validate type TransportMeansIDType
            self.validate_TransportMeansIDType(self.ActiveTransportIdentifier)
        elif nodeName_ == 'TransportRegNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransportRegNumber')
            value_ = self.gds_validate_string(value_, node, 'TransportRegNumber')
            self.TransportRegNumber = value_
            self.TransportRegNumber_nsprefix_ = child_.prefix
            # validate type CodeVariable20Type
            self.validate_CodeVariable20Type(self.TransportRegNumber)
# end class TransportMeansBaseType


class TransportMeansPassportType(GeneratedsSuper):
    """TransportMeansPassportType -- С
    е
    р
    и
    я
    и
    н
    о
    м
    е
    р
    П
    а
    с
    п
    о
    р
    т
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    Series -- С
    е
    р
    и
    я
    П
    а
    с
    п
    о
    р
    т
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    PTSNumber -- Н
    о
    м
    е
    р
    П
    а
    с
    п
    о
    р
    т
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    RegionCode -- К
    о
    д
    р
    е
    г
    и
    о
    н
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Series=None, PTSNumber=None, RegionCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        self.Series = Series
        self.validate_SeriesCodeType(self.Series)
        self.Series_nsprefix_ = "clt_ru"
        self.PTSNumber = PTSNumber
        self.validate_TransportPassportIDType(self.PTSNumber)
        self.PTSNumber_nsprefix_ = "clt_ru"
        self.RegionCode = RegionCode
        self.validate_RegionCodeType(self.RegionCode)
        self.RegionCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportMeansPassportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportMeansPassportType.subclass:
            return TransportMeansPassportType.subclass(*args_, **kwargs_)
        else:
            return TransportMeansPassportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Series(self):
        return self.Series
    def set_Series(self, Series):
        self.Series = Series
    def get_PTSNumber(self):
        return self.PTSNumber
    def set_PTSNumber(self, PTSNumber):
        self.PTSNumber = PTSNumber
    def get_RegionCode(self):
        return self.RegionCode
    def set_RegionCode(self, RegionCode):
        self.RegionCode = RegionCode
    def validate_SeriesCodeType(self, value):
        result = True
        # Validate type SeriesCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_SeriesCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SeriesCodeType_patterns_, ))
                result = False
        return result
    validate_SeriesCodeType_patterns_ = [['^(([А-Я]{2}))$']]
    def validate_TransportPassportIDType(self, value):
        result = True
        # Validate type TransportPassportIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TransportPassportIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TransportPassportIDType_patterns_, ))
                result = False
        return result
    validate_TransportPassportIDType_patterns_ = [['^([0-9]{6}|[0-9]{7})$']]
    def validate_RegionCodeType(self, value):
        result = True
        # Validate type RegionCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_RegionCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RegionCodeType_patterns_, ))
                result = False
        return result
    validate_RegionCodeType_patterns_ = [['^((\\d{3})|(\\d{2}))$']]
    def has__content(self):
        if (
            self.Series is not None or
            self.PTSNumber is not None or
            self.RegionCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportMeansPassportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransportMeansPassportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransportMeansPassportType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransportMeansPassportType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransportMeansPassportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='TransportMeansPassportType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportMeansPassportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Series is not None:
            namespaceprefix_ = self.Series_nsprefix_ + ':' if (UseCapturedNS_ and self.Series_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeries>%s</%sSeries>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Series), input_name='Series')), namespaceprefix_ , eol_))
        if self.PTSNumber is not None:
            namespaceprefix_ = self.PTSNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.PTSNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPTSNumber>%s</%sPTSNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PTSNumber), input_name='PTSNumber')), namespaceprefix_ , eol_))
        if self.RegionCode is not None:
            namespaceprefix_ = self.RegionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.RegionCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegionCode>%s</%sRegionCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RegionCode), input_name='RegionCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Series':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'Series')
            value_ = self.gds_validate_string(value_, node, 'Series')
            self.Series = value_
            self.Series_nsprefix_ = child_.prefix
            # validate type SeriesCodeType
            self.validate_SeriesCodeType(self.Series)
        elif nodeName_ == 'PTSNumber':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PTSNumber')
            value_ = self.gds_validate_string(value_, node, 'PTSNumber')
            self.PTSNumber = value_
            self.PTSNumber_nsprefix_ = child_.prefix
            # validate type TransportPassportIDType
            self.validate_TransportPassportIDType(self.PTSNumber)
        elif nodeName_ == 'RegionCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'RegionCode')
            value_ = self.gds_validate_string(value_, node, 'RegionCode')
            self.RegionCode = value_
            self.RegionCode_nsprefix_ = child_.prefix
            # validate type RegionCodeType
            self.validate_RegionCodeType(self.RegionCode)
# end class TransportMeansPassportType


class AdditionalGoodsDescriptionType(GeneratedsSuper):
    """AdditionalGoodsDescriptionType -- Д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    ы
    е
    х
    а
    р
    а
    к
    т
    е
    р
    и
    с
    т
    и
    к
    и
    т
    о
    в
    а
    р
    о
    в
    Manufacturer -- С
    в
    е
    д
    е
    н
    и
    я
    о
    п
    р
    о
    и
    з
    в
    о
    д
    и
    т
    е
    л
    е
    TradeMark -- Т
    о
    в
    .
    з
    н
    а
    к
    ,
    м
    е
    с
    т
    о
    п
    р
    о
    и
    с
    х
    о
    ж
    д
    е
    н
    и
    я
    ,
    о
    б
    ъ
    е
    к
    т
    а
    в
    т
    о
    р
    с
    к
    о
    г
    о
    п
    р
    а
    в
    а
    ,
    с
    м
    е
    ж
    н
    ы
    х
    п
    р
    а
    в
    ,
    п
    а
    т
    е
    н
    т
    и
    т
    .
    д
    .
    GoodsMark -- М
    а
    р
    к
    а
    т
    о
    в
    а
    р
    а
    GoodsModel -- М
    о
    д
    е
    л
    ь
    т
    о
    в
    а
    р
    а
    GoodsStandart -- С
    т
    а
    н
    д
    а
    р
    т
    (
    Г
    О
    С
    Т
    ,
    О
    С
    Т
    ,
    С
    П
    П
    ,
    С
    Т
    О
    ,
    Т
    У
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Manufacturer=None, TradeMark=None, GoodsMark=None, GoodsModel=None, GoodsStandart=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.Manufacturer = Manufacturer
        self.validate_NameType(self.Manufacturer)
        self.Manufacturer_nsprefix_ = "clt_ru"
        self.TradeMark = TradeMark
        self.validate_NameType(self.TradeMark)
        self.TradeMark_nsprefix_ = "clt_ru"
        self.GoodsMark = GoodsMark
        self.validate_Text50Type(self.GoodsMark)
        self.GoodsMark_nsprefix_ = "clt_ru"
        self.GoodsModel = GoodsModel
        self.validate_Text50Type(self.GoodsModel)
        self.GoodsModel_nsprefix_ = "clt_ru"
        self.GoodsStandart = GoodsStandart
        self.validate_Text50Type(self.GoodsStandart)
        self.GoodsStandart_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalGoodsDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalGoodsDescriptionType.subclass:
            return AdditionalGoodsDescriptionType.subclass(*args_, **kwargs_)
        else:
            return AdditionalGoodsDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Manufacturer(self):
        return self.Manufacturer
    def set_Manufacturer(self, Manufacturer):
        self.Manufacturer = Manufacturer
    def get_TradeMark(self):
        return self.TradeMark
    def set_TradeMark(self, TradeMark):
        self.TradeMark = TradeMark
    def get_GoodsMark(self):
        return self.GoodsMark
    def set_GoodsMark(self, GoodsMark):
        self.GoodsMark = GoodsMark
    def get_GoodsModel(self):
        return self.GoodsModel
    def set_GoodsModel(self, GoodsModel):
        self.GoodsModel = GoodsModel
    def get_GoodsStandart(self):
        return self.GoodsStandart
    def set_GoodsStandart(self, GoodsStandart):
        self.GoodsStandart = GoodsStandart
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Manufacturer is not None or
            self.TradeMark is not None or
            self.GoodsMark is not None or
            self.GoodsModel is not None or
            self.GoodsStandart is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AdditionalGoodsDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalGoodsDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AdditionalGoodsDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdditionalGoodsDescriptionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdditionalGoodsDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='AdditionalGoodsDescriptionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AdditionalGoodsDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Manufacturer is not None:
            namespaceprefix_ = self.Manufacturer_nsprefix_ + ':' if (UseCapturedNS_ and self.Manufacturer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespaceprefix_ , eol_))
        if self.TradeMark is not None:
            namespaceprefix_ = self.TradeMark_nsprefix_ + ':' if (UseCapturedNS_ and self.TradeMark_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTradeMark>%s</%sTradeMark>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TradeMark), input_name='TradeMark')), namespaceprefix_ , eol_))
        if self.GoodsMark is not None:
            namespaceprefix_ = self.GoodsMark_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsMark_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsMark>%s</%sGoodsMark>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsMark), input_name='GoodsMark')), namespaceprefix_ , eol_))
        if self.GoodsModel is not None:
            namespaceprefix_ = self.GoodsModel_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsModel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsModel>%s</%sGoodsModel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsModel), input_name='GoodsModel')), namespaceprefix_ , eol_))
        if self.GoodsStandart is not None:
            namespaceprefix_ = self.GoodsStandart_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsStandart_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsStandart>%s</%sGoodsStandart>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsStandart), input_name='GoodsStandart')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Manufacturer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Manufacturer')
            value_ = self.gds_validate_string(value_, node, 'Manufacturer')
            self.Manufacturer = value_
            self.Manufacturer_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.Manufacturer)
        elif nodeName_ == 'TradeMark':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TradeMark')
            value_ = self.gds_validate_string(value_, node, 'TradeMark')
            self.TradeMark = value_
            self.TradeMark_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.TradeMark)
        elif nodeName_ == 'GoodsMark':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsMark')
            value_ = self.gds_validate_string(value_, node, 'GoodsMark')
            self.GoodsMark = value_
            self.GoodsMark_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.GoodsMark)
        elif nodeName_ == 'GoodsModel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsModel')
            value_ = self.gds_validate_string(value_, node, 'GoodsModel')
            self.GoodsModel = value_
            self.GoodsModel_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.GoodsModel)
        elif nodeName_ == 'GoodsStandart':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsStandart')
            value_ = self.gds_validate_string(value_, node, 'GoodsStandart')
            self.GoodsStandart = value_
            self.GoodsStandart_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.GoodsStandart)
# end class AdditionalGoodsDescriptionType


class BankMarkType(GeneratedsSuper):
    """BankMarkType -- О
    т
    м
    е
    т
    к
    и
    б
    а
    н
    к
    а
      
    * BankName -- Н
      а
      и
      м
      е
      н
      о
      в
      а
      н
      и
      е
      б
      а
      н
      к
      а
    * BIC -- Б
      И
      К
    * RecipSign -- П
      о
      д
      п
      и
      с
      ь
      о
      т
      в
      е
      т
      с
      т
      в
      е
      н
      н
      о
      г
      о
      и
      с
      п
      о
      л
      н
      и
      т
      е
      л
      я
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BankName=None, BIC=None, RecipSign=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.BankName = BankName
        self.validate_NameType(self.BankName)
        self.BankName_nsprefix_ = "clt_ru"
        self.BIC = BIC
        self.validate_BICIDType(self.BIC)
        self.BIC_nsprefix_ = "clt_ru"
        self.RecipSign = RecipSign
        self.RecipSign_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BankMarkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BankMarkType.subclass:
            return BankMarkType.subclass(*args_, **kwargs_)
        else:
            return BankMarkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BankName(self):
        return self.BankName
    def set_BankName(self, BankName):
        self.BankName = BankName
    def get_BIC(self):
        return self.BIC
    def set_BIC(self, BIC):
        self.BIC = BIC
    def get_RecipSign(self):
        return self.RecipSign
    def set_RecipSign(self, RecipSign):
        self.RecipSign = RecipSign
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_BICIDType(self, value):
        result = True
        # Validate type BICIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BICIDType_patterns_, ))
                result = False
        return result
    validate_BICIDType_patterns_ = [['^(\\d{9})$']]
    def has__content(self):
        if (
            self.BankName is not None or
            self.BIC is not None or
            self.RecipSign is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='BankMarkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BankMarkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BankMarkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BankMarkType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BankMarkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='BankMarkType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='BankMarkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BankName is not None:
            namespaceprefix_ = self.BankName_nsprefix_ + ':' if (UseCapturedNS_ and self.BankName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankName>%s</%sBankName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BankName), input_name='BankName')), namespaceprefix_ , eol_))
        if self.BIC is not None:
            namespaceprefix_ = self.BIC_nsprefix_ + ':' if (UseCapturedNS_ and self.BIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIC>%s</%sBIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BIC), input_name='BIC')), namespaceprefix_ , eol_))
        if self.RecipSign is not None:
            namespaceprefix_ = self.RecipSign_nsprefix_ + ':' if (UseCapturedNS_ and self.RecipSign_nsprefix_) else ''
            self.RecipSign.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RecipSign', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BankName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankName')
            value_ = self.gds_validate_string(value_, node, 'BankName')
            self.BankName = value_
            self.BankName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.BankName)
        elif nodeName_ == 'BIC':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BIC')
            value_ = self.gds_validate_string(value_, node, 'BIC')
            self.BIC = value_
            self.BIC_nsprefix_ = child_.prefix
            # validate type BICIDType
            self.validate_BICIDType(self.BIC)
        elif nodeName_ == 'RecipSign':
            obj_ = PersonSignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RecipSign = obj_
            obj_.original_tagname_ = 'RecipSign'
# end class BankMarkType


class BankType(GeneratedsSuper):
    """BankType -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    б
    а
    н
    к
    а
    BankName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    б
    а
    н
    к
    а
    BIC -- Б
    И
    К
    CorrespAccount -- Н
    о
    м
    е
    р
    к
    о
    р
    р
    е
    с
    п
    о
    н
    д
    е
    н
    т
    с
    к
    о
    г
    о
    с
    ч
    е
    т
    а
    (
    с
    у
    б
    с
    ч
    е
    т
    а
    )
    BankPlace -- М
    е
    с
    т
    о
    н
    а
    х
    о
    ж
    д
    е
    н
    и
    е
    б
    а
    н
    к
    а
    PersonalAccount -- Л
    и
    ц
    е
    в
    о
    й
    с
    ч
    е
    т
    к
    л
    и
    е
    н
    т
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BankName=None, BIC=None, CorrespAccount=None, BankPlace=None, PersonalAccount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.BankName = BankName
        self.validate_NameType(self.BankName)
        self.BankName_nsprefix_ = "clt_ru"
        self.BIC = BIC
        self.validate_BICIDType(self.BIC)
        self.BIC_nsprefix_ = "clt_ru"
        self.CorrespAccount = CorrespAccount
        self.validate_AccountType(self.CorrespAccount)
        self.CorrespAccount_nsprefix_ = "clt_ru"
        self.BankPlace = BankPlace
        self.validate_PlaceNameType(self.BankPlace)
        self.BankPlace_nsprefix_ = "clt_ru"
        self.PersonalAccount = PersonalAccount
        self.validate_AccountType(self.PersonalAccount)
        self.PersonalAccount_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BankType.subclass:
            return BankType.subclass(*args_, **kwargs_)
        else:
            return BankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BankName(self):
        return self.BankName
    def set_BankName(self, BankName):
        self.BankName = BankName
    def get_BIC(self):
        return self.BIC
    def set_BIC(self, BIC):
        self.BIC = BIC
    def get_CorrespAccount(self):
        return self.CorrespAccount
    def set_CorrespAccount(self, CorrespAccount):
        self.CorrespAccount = CorrespAccount
    def get_BankPlace(self):
        return self.BankPlace
    def set_BankPlace(self, BankPlace):
        self.BankPlace = BankPlace
    def get_PersonalAccount(self):
        return self.PersonalAccount
    def set_PersonalAccount(self, PersonalAccount):
        self.PersonalAccount = PersonalAccount
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_BICIDType(self, value):
        result = True
        # Validate type BICIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BICIDType_patterns_, ))
                result = False
        return result
    validate_BICIDType_patterns_ = [['^(\\d{9})$']]
    def validate_AccountType(self, value):
        result = True
        # Validate type AccountType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AccountType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AccountType_patterns_, ))
                result = False
        return result
    validate_AccountType_patterns_ = [['^(\\d{20})$']]
    def validate_PlaceNameType(self, value):
        result = True
        # Validate type PlaceNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PlaceNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PlaceNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.BankName is not None or
            self.BIC is not None or
            self.CorrespAccount is not None or
            self.BankPlace is not None or
            self.PersonalAccount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='BankType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BankType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BankType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='BankType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='BankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BankName is not None:
            namespaceprefix_ = self.BankName_nsprefix_ + ':' if (UseCapturedNS_ and self.BankName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankName>%s</%sBankName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BankName), input_name='BankName')), namespaceprefix_ , eol_))
        if self.BIC is not None:
            namespaceprefix_ = self.BIC_nsprefix_ + ':' if (UseCapturedNS_ and self.BIC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIC>%s</%sBIC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BIC), input_name='BIC')), namespaceprefix_ , eol_))
        if self.CorrespAccount is not None:
            namespaceprefix_ = self.CorrespAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.CorrespAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrespAccount>%s</%sCorrespAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CorrespAccount), input_name='CorrespAccount')), namespaceprefix_ , eol_))
        if self.BankPlace is not None:
            namespaceprefix_ = self.BankPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.BankPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankPlace>%s</%sBankPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BankPlace), input_name='BankPlace')), namespaceprefix_ , eol_))
        if self.PersonalAccount is not None:
            namespaceprefix_ = self.PersonalAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonalAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonalAccount>%s</%sPersonalAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonalAccount), input_name='PersonalAccount')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BankName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankName')
            value_ = self.gds_validate_string(value_, node, 'BankName')
            self.BankName = value_
            self.BankName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.BankName)
        elif nodeName_ == 'BIC':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BIC')
            value_ = self.gds_validate_string(value_, node, 'BIC')
            self.BIC = value_
            self.BIC_nsprefix_ = child_.prefix
            # validate type BICIDType
            self.validate_BICIDType(self.BIC)
        elif nodeName_ == 'CorrespAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CorrespAccount')
            value_ = self.gds_validate_string(value_, node, 'CorrespAccount')
            self.CorrespAccount = value_
            self.CorrespAccount_nsprefix_ = child_.prefix
            # validate type AccountType
            self.validate_AccountType(self.CorrespAccount)
        elif nodeName_ == 'BankPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankPlace')
            value_ = self.gds_validate_string(value_, node, 'BankPlace')
            self.BankPlace = value_
            self.BankPlace_nsprefix_ = child_.prefix
            # validate type PlaceNameType
            self.validate_PlaceNameType(self.BankPlace)
        elif nodeName_ == 'PersonalAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PersonalAccount')
            value_ = self.gds_validate_string(value_, node, 'PersonalAccount')
            self.PersonalAccount = value_
            self.PersonalAccount_nsprefix_ = child_.prefix
            # validate type AccountType
            self.validate_AccountType(self.PersonalAccount)
# end class BankType


class ContractDeliveryTermsType(GeneratedsSuper):
    """ContractDeliveryTermsType -- О
    п
    и
    с
    а
    н
    и
    е
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    в
    к
    о
    н
    т
    р
    а
    к
    т
    е
    DeliveryPlace -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    п
    у
    н
    к
    т
    а
    п
    о
    с
    т
    а
    в
    к
    и
    DeliveryTermsNumericCode -- Ч
    и
    с
    л
    о
    в
    о
    й
    к
    о
    д
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    DeliveryTermsStringCode -- К
    о
    д
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    п
    о
    И
    н
    к
    о
    т
    е
    р
    м
    с
    TermsDescription -- О
    п
    и
    с
    а
    н
    и
    е
    ,
    к
    о
    м
    м
    е
    н
    т
    а
    р
    и
    и
    п
    о
    у
    с
    л
    о
    в
    и
    я
    м
    п
    о
    с
    т
    а
    в
    к
    и
    InvoiceSaleTerms -- С
    р
    о
    к
    о
    п
    л
    а
    т
    ы
    п
    о
    и
    н
    в
    о
    й
    с
    у
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DeliveryPlace=None, DeliveryTermsNumericCode=None, DeliveryTermsStringCode=None, TermsDescription=None, InvoiceSaleTerms=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        if DeliveryPlace is None:
            self.DeliveryPlace = []
        else:
            self.DeliveryPlace = DeliveryPlace
        self.DeliveryPlace_nsprefix_ = "clt_ru"
        self.DeliveryTermsNumericCode = DeliveryTermsNumericCode
        self.validate_DeliveryTermsNumericCodeType(self.DeliveryTermsNumericCode)
        self.DeliveryTermsNumericCode_nsprefix_ = "clt_ru"
        self.DeliveryTermsStringCode = DeliveryTermsStringCode
        self.validate_IncotermsDeliveryStringCodeType(self.DeliveryTermsStringCode)
        self.DeliveryTermsStringCode_nsprefix_ = "clt_ru"
        if TermsDescription is None:
            self.TermsDescription = []
        else:
            self.TermsDescription = TermsDescription
        self.TermsDescription_nsprefix_ = "clt_ru"
        if InvoiceSaleTerms is None:
            self.InvoiceSaleTerms = []
        else:
            self.InvoiceSaleTerms = InvoiceSaleTerms
        self.InvoiceSaleTerms_nsprefix_ = "catComFin_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractDeliveryTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractDeliveryTermsType.subclass:
            return ContractDeliveryTermsType.subclass(*args_, **kwargs_)
        else:
            return ContractDeliveryTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DeliveryPlace(self):
        return self.DeliveryPlace
    def set_DeliveryPlace(self, DeliveryPlace):
        self.DeliveryPlace = DeliveryPlace
    def add_DeliveryPlace(self, value):
        self.DeliveryPlace.append(value)
    def insert_DeliveryPlace_at(self, index, value):
        self.DeliveryPlace.insert(index, value)
    def replace_DeliveryPlace_at(self, index, value):
        self.DeliveryPlace[index] = value
    def get_DeliveryTermsNumericCode(self):
        return self.DeliveryTermsNumericCode
    def set_DeliveryTermsNumericCode(self, DeliveryTermsNumericCode):
        self.DeliveryTermsNumericCode = DeliveryTermsNumericCode
    def get_DeliveryTermsStringCode(self):
        return self.DeliveryTermsStringCode
    def set_DeliveryTermsStringCode(self, DeliveryTermsStringCode):
        self.DeliveryTermsStringCode = DeliveryTermsStringCode
    def get_TermsDescription(self):
        return self.TermsDescription
    def set_TermsDescription(self, TermsDescription):
        self.TermsDescription = TermsDescription
    def add_TermsDescription(self, value):
        self.TermsDescription.append(value)
    def insert_TermsDescription_at(self, index, value):
        self.TermsDescription.insert(index, value)
    def replace_TermsDescription_at(self, index, value):
        self.TermsDescription[index] = value
    def get_InvoiceSaleTerms(self):
        return self.InvoiceSaleTerms
    def set_InvoiceSaleTerms(self, InvoiceSaleTerms):
        self.InvoiceSaleTerms = InvoiceSaleTerms
    def add_InvoiceSaleTerms(self, value):
        self.InvoiceSaleTerms.append(value)
    def insert_InvoiceSaleTerms_at(self, index, value):
        self.InvoiceSaleTerms.insert(index, value)
    def replace_InvoiceSaleTerms_at(self, index, value):
        self.InvoiceSaleTerms[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_PlaceNameType(self, value):
        result = True
        # Validate type PlaceNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PlaceNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PlaceNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DeliveryTermsNumericCodeType(self, value):
        result = True
        # Validate type DeliveryTermsNumericCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DeliveryTermsNumericCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DeliveryTermsNumericCodeType_patterns_, ))
                result = False
        return result
    validate_DeliveryTermsNumericCodeType_patterns_ = [['^(\\d{2})$']]
    def validate_IncotermsDeliveryStringCodeType(self, value):
        result = True
        # Validate type IncotermsDeliveryStringCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IncotermsDeliveryStringCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IncotermsDeliveryStringCodeType_patterns_, ))
                result = False
        return result
    validate_IncotermsDeliveryStringCodeType_patterns_ = [['^(\\D{3})$']]
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.DeliveryPlace or
            self.DeliveryTermsNumericCode is not None or
            self.DeliveryTermsStringCode is not None or
            self.TermsDescription or
            self.InvoiceSaleTerms
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContractDeliveryTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContractDeliveryTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContractDeliveryTermsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractDeliveryTermsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContractDeliveryTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ContractDeliveryTermsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContractDeliveryTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DeliveryPlace_ in self.DeliveryPlace:
            namespaceprefix_ = self.DeliveryPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryPlace>%s</%sDeliveryPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DeliveryPlace_), input_name='DeliveryPlace')), namespaceprefix_ , eol_))
        if self.DeliveryTermsNumericCode is not None:
            namespaceprefix_ = self.DeliveryTermsNumericCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryTermsNumericCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryTermsNumericCode>%s</%sDeliveryTermsNumericCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTermsNumericCode), input_name='DeliveryTermsNumericCode')), namespaceprefix_ , eol_))
        if self.DeliveryTermsStringCode is not None:
            namespaceprefix_ = self.DeliveryTermsStringCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryTermsStringCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveryTermsStringCode>%s</%sDeliveryTermsStringCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTermsStringCode), input_name='DeliveryTermsStringCode')), namespaceprefix_ , eol_))
        for TermsDescription_ in self.TermsDescription:
            namespaceprefix_ = self.TermsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.TermsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTermsDescription>%s</%sTermsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(TermsDescription_), input_name='TermsDescription')), namespaceprefix_ , eol_))
        for InvoiceSaleTerms_ in self.InvoiceSaleTerms:
            namespaceprefix_ = self.InvoiceSaleTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.InvoiceSaleTerms_nsprefix_) else ''
            InvoiceSaleTerms_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InvoiceSaleTerms', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DeliveryPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DeliveryPlace')
            value_ = self.gds_validate_string(value_, node, 'DeliveryPlace')
            self.DeliveryPlace.append(value_)
            self.DeliveryPlace_nsprefix_ = child_.prefix
            # validate type PlaceNameType
            self.validate_PlaceNameType(self.DeliveryPlace[-1])
        elif nodeName_ == 'DeliveryTermsNumericCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DeliveryTermsNumericCode')
            value_ = self.gds_validate_string(value_, node, 'DeliveryTermsNumericCode')
            self.DeliveryTermsNumericCode = value_
            self.DeliveryTermsNumericCode_nsprefix_ = child_.prefix
            # validate type DeliveryTermsNumericCodeType
            self.validate_DeliveryTermsNumericCodeType(self.DeliveryTermsNumericCode)
        elif nodeName_ == 'DeliveryTermsStringCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DeliveryTermsStringCode')
            value_ = self.gds_validate_string(value_, node, 'DeliveryTermsStringCode')
            self.DeliveryTermsStringCode = value_
            self.DeliveryTermsStringCode_nsprefix_ = child_.prefix
            # validate type IncotermsDeliveryStringCodeType
            self.validate_IncotermsDeliveryStringCodeType(self.DeliveryTermsStringCode)
        elif nodeName_ == 'TermsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TermsDescription')
            value_ = self.gds_validate_string(value_, node, 'TermsDescription')
            self.TermsDescription.append(value_)
            self.TermsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.TermsDescription[-1])
        elif nodeName_ == 'InvoiceSaleTerms':
            obj_ = InvoiceSaleTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InvoiceSaleTerms.append(obj_)
            obj_.original_tagname_ = 'InvoiceSaleTerms'
# end class ContractDeliveryTermsType


class ContractRegistrationType(DocumentBaseType):
    """ContractRegistrationType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    п
    о
    д
    п
    и
    с
    а
    н
    и
    и
    (
    з
    а
    к
    л
    ю
    ч
    е
    н
    и
    и
    )
    к
    о
    н
    т
    р
    а
    к
    т
    а
    (
    д
    а
    т
    а
    ,
    н
    о
    м
    е
    р
    ,
    м
    е
    с
    т
    о
    )
    ContractPlace -- М
    е
    с
    т
    о
    з
    а
    к
    л
    ю
    ч
    е
    н
    и
    я
    к
    о
    н
    т
    р
    а
    к
    т
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DocumentBaseType
    def __init__(self, PrDocumentName=None, PrDocumentNumber=None, PrDocumentDate=None, ContractPlace=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        super(globals().get("ContractRegistrationType"), self).__init__(PrDocumentName, PrDocumentNumber, PrDocumentDate,  **kwargs_)
        self.ContractPlace = ContractPlace
        self.validate_PlaceNameType(self.ContractPlace)
        self.ContractPlace_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractRegistrationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractRegistrationType.subclass:
            return ContractRegistrationType.subclass(*args_, **kwargs_)
        else:
            return ContractRegistrationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ContractPlace(self):
        return self.ContractPlace
    def set_ContractPlace(self, ContractPlace):
        self.ContractPlace = ContractPlace
    def validate_PlaceNameType(self, value):
        result = True
        # Validate type PlaceNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PlaceNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PlaceNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ContractPlace is not None or
            super(ContractRegistrationType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContractRegistrationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContractRegistrationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContractRegistrationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractRegistrationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContractRegistrationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ContractRegistrationType'):
        super(ContractRegistrationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractRegistrationType')
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContractRegistrationType', fromsubclass_=False, pretty_print=True):
        super(ContractRegistrationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContractPlace is not None:
            namespaceprefix_ = self.ContractPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.ContractPlace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContractPlace>%s</%sContractPlace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ContractPlace), input_name='ContractPlace')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ContractRegistrationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContractPlace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ContractPlace')
            value_ = self.gds_validate_string(value_, node, 'ContractPlace')
            self.ContractPlace = value_
            self.ContractPlace_nsprefix_ = child_.prefix
            # validate type PlaceNameType
            self.validate_PlaceNameType(self.ContractPlace)
        super(ContractRegistrationType, self)._buildChildren(child_, node, nodeName_, True)
# end class ContractRegistrationType


class ContractSpecificationType(GeneratedsSuper):
    """ContractSpecificationType -- С
    п
    е
    ц
    и
    ф
    и
    к
    а
    ц
    и
    я
    к
    к
    о
    н
    т
    р
    а
    к
    т
    у
    ID -- Н
    о
    м
    е
    р
    д
    о
    к
    у
    м
    е
    н
    т
    а
    IssueDate -- Д
    а
    т
    а
    с
    о
    с
    т
    а
    в
    л
    е
    н
    и
    я
    д
    о
    к
    у
    м
    е
    н
    т
    а
    SpecificationGoodsExtended -- О
    п
    и
    с
    а
    н
    и
    е
    и
    д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    ы
    е
    х
    а
    р
    а
    к
    т
    е
    р
    и
    с
    т
    и
    к
    и
    т
    о
    в
    а
    р
    о
    в
    и
    з
    с
    п
    е
    ц
    и
    ф
    и
    к
    а
    ц
    и
    и
    к
    к
    о
    н
    т
    р
    а
    к
    т
    у
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, IssueDate=None, SpecificationGoodsExtended=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.ID = ID
        self.validate_DocumentNumberType(self.ID)
        self.ID_nsprefix_ = "clt_ru"
        if isinstance(IssueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(IssueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = IssueDate
        self.IssueDate = initvalue_
        self.IssueDate_nsprefix_ = "clt_ru"
        if SpecificationGoodsExtended is None:
            self.SpecificationGoodsExtended = []
        else:
            self.SpecificationGoodsExtended = SpecificationGoodsExtended
        self.SpecificationGoodsExtended_nsprefix_ = "catComFin_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractSpecificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractSpecificationType.subclass:
            return ContractSpecificationType.subclass(*args_, **kwargs_)
        else:
            return ContractSpecificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_IssueDate(self):
        return self.IssueDate
    def set_IssueDate(self, IssueDate):
        self.IssueDate = IssueDate
    def get_SpecificationGoodsExtended(self):
        return self.SpecificationGoodsExtended
    def set_SpecificationGoodsExtended(self, SpecificationGoodsExtended):
        self.SpecificationGoodsExtended = SpecificationGoodsExtended
    def add_SpecificationGoodsExtended(self, value):
        self.SpecificationGoodsExtended.append(value)
    def insert_SpecificationGoodsExtended_at(self, index, value):
        self.SpecificationGoodsExtended.insert(index, value)
    def replace_SpecificationGoodsExtended_at(self, index, value):
        self.SpecificationGoodsExtended[index] = value
    def validate_DocumentNumberType(self, value):
        result = True
        # Validate type DocumentNumberType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DocumentNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DocumentNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.ID is not None or
            self.IssueDate is not None or
            self.SpecificationGoodsExtended
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContractSpecificationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContractSpecificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContractSpecificationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractSpecificationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContractSpecificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ContractSpecificationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='ContractSpecificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.IssueDate is not None:
            namespaceprefix_ = self.IssueDate_nsprefix_ + ':' if (UseCapturedNS_ and self.IssueDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIssueDate>%s</%sIssueDate>%s' % (namespaceprefix_ , self.gds_format_date(self.IssueDate, input_name='IssueDate'), namespaceprefix_ , eol_))
        for SpecificationGoodsExtended_ in self.SpecificationGoodsExtended:
            namespaceprefix_ = self.SpecificationGoodsExtended_nsprefix_ + ':' if (UseCapturedNS_ and self.SpecificationGoodsExtended_nsprefix_) else ''
            SpecificationGoodsExtended_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpecificationGoodsExtended', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type DocumentNumberType
            self.validate_DocumentNumberType(self.ID)
        elif nodeName_ == 'IssueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.IssueDate = dval_
            self.IssueDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.IssueDate)
        elif nodeName_ == 'SpecificationGoodsExtended':
            obj_ = SpecificationGoodsExtendedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpecificationGoodsExtended.append(obj_)
            obj_.original_tagname_ = 'SpecificationGoodsExtended'
# end class ContractSpecificationType


class CustomerType(GeneratedsSuper):
    """CustomerType -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    OrganizationName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    к
    л
    и
    е
    н
    т
    а
    INN -- И
    Н
    Н
    к
    л
    и
    е
    н
    т
    а
    KPP -- К
    о
    д
    п
    о
    с
    т
    а
    н
    о
    в
    к
    и
    н
    а
    у
    ч
    е
    т
    (
    К
    П
    П
    )
    к
    л
    и
    е
    н
    т
    а
    Bank -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    б
    а
    н
    к
    а
    к
    л
    и
    е
    н
    т
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OrganizationName=None, INN=None, KPP=None, Bank=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.OrganizationName = OrganizationName
        self.validate_NameType(self.OrganizationName)
        self.OrganizationName_nsprefix_ = "clt_ru"
        self.INN = INN
        self.validate_INNIDType(self.INN)
        self.INN_nsprefix_ = "clt_ru"
        self.KPP = KPP
        self.validate_KPPCodeType(self.KPP)
        self.KPP_nsprefix_ = "clt_ru"
        self.Bank = Bank
        self.Bank_nsprefix_ = "catComFin_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerType.subclass:
            return CustomerType.subclass(*args_, **kwargs_)
        else:
            return CustomerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OrganizationName(self):
        return self.OrganizationName
    def set_OrganizationName(self, OrganizationName):
        self.OrganizationName = OrganizationName
    def get_INN(self):
        return self.INN
    def set_INN(self, INN):
        self.INN = INN
    def get_KPP(self):
        return self.KPP
    def set_KPP(self, KPP):
        self.KPP = KPP
    def get_Bank(self):
        return self.Bank
    def set_Bank(self, Bank):
        self.Bank = Bank
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_INNIDType(self, value):
        result = True
        # Validate type INNIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INNIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on INNIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_KPPCodeType(self, value):
        result = True
        # Validate type KPPCodeType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_KPPCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_KPPCodeType_patterns_, ))
                result = False
        return result
    validate_KPPCodeType_patterns_ = [['^(\\d{9})$']]
    def has__content(self):
        if (
            self.OrganizationName is not None or
            self.INN is not None or
            self.KPP is not None or
            self.Bank is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CustomerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='CustomerType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CustomerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganizationName is not None:
            namespaceprefix_ = self.OrganizationName_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganizationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationName>%s</%sOrganizationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganizationName), input_name='OrganizationName')), namespaceprefix_ , eol_))
        if self.INN is not None:
            namespaceprefix_ = self.INN_nsprefix_ + ':' if (UseCapturedNS_ and self.INN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINN>%s</%sINN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INN), input_name='INN')), namespaceprefix_ , eol_))
        if self.KPP is not None:
            namespaceprefix_ = self.KPP_nsprefix_ + ':' if (UseCapturedNS_ and self.KPP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKPP>%s</%sKPP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KPP), input_name='KPP')), namespaceprefix_ , eol_))
        if self.Bank is not None:
            namespaceprefix_ = self.Bank_nsprefix_ + ':' if (UseCapturedNS_ and self.Bank_nsprefix_) else ''
            self.Bank.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Bank', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OrganizationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationName')
            value_ = self.gds_validate_string(value_, node, 'OrganizationName')
            self.OrganizationName = value_
            self.OrganizationName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.OrganizationName)
        elif nodeName_ == 'INN':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'INN')
            value_ = self.gds_validate_string(value_, node, 'INN')
            self.INN = value_
            self.INN_nsprefix_ = child_.prefix
            # validate type INNIDType
            self.validate_INNIDType(self.INN)
        elif nodeName_ == 'KPP':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'KPP')
            value_ = self.gds_validate_string(value_, node, 'KPP')
            self.KPP = value_
            self.KPP_nsprefix_ = child_.prefix
            # validate type KPPCodeType
            self.validate_KPPCodeType(self.KPP)
        elif nodeName_ == 'Bank':
            obj_ = BankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Bank = obj_
            obj_.original_tagname_ = 'Bank'
# end class CustomerType


class DepartmentalInfoType(GeneratedsSuper):
    """DepartmentalInfoType -- В
    е
    д
    о
    м
    с
    т
    в
    е
    н
    н
    а
    я
    и
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    DrawerStatus -- С
    т
    а
    т
    у
    с
    с
    о
    с
    т
    а
    в
    и
    т
    е
    л
    я
    р
    а
    с
    ч
    е
    т
    н
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    CBC -- К
    о
    д
    б
    ю
    д
    ж
    е
    т
    н
    о
    й
    к
    л
    а
    с
    с
    и
    ф
    и
    к
    а
    ц
    и
    и
    (
    К
    Б
    К
    ),
    п
    о
    к
    о
    т
    о
    р
    о
    м
    у
    у
    ч
    и
    т
    ы
    в
    а
    е
    т
    с
    я
    н
    а
    л
    о
    г
    (
    с
    б
    о
    р
    )
    OKATO -- К
    о
    д
    м
    у
    н
    и
    ц
    и
    п
    а
    л
    ь
    н
    о
    г
    о
    о
    б
    р
    а
    з
    о
    в
    а
    н
    и
    я
    О
    К
    А
    Т
    О
    PaymentReason -- О
    с
    н
    о
    в
    а
    н
    и
    е
    н
    а
    л
    о
    г
    о
    в
    о
    г
    о
    п
    л
    а
    т
    е
    ж
    а
    TaxPeriod -- Н
    а
    л
    о
    г
    о
    в
    ы
    й
    п
    е
    р
    и
    о
    д
    DocNo -- Н
    о
    м
    е
    р
    н
    а
    л
    о
    г
    о
    в
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    /
    И
    д
    е
    н
    т
    и
    ф
    и
    к
    а
    т
    о
    р
    с
    в
    е
    д
    е
    н
    и
    й
    о
    ф
    и
    з
    и
    ч
    е
    с
    к
    о
    м
    л
    и
    ц
    е
    DocDate -- Д
    а
    т
    а
    н
    а
    л
    о
    г
    о
    в
    о
    г
    о
    д
    о
    к
    у
    м
    е
    н
    т
    а
    TaxPaymentKind -- Т
    и
    п
    н
    а
    л
    о
    г
    о
    в
    о
    г
    о
    п
    л
    а
    т
    е
    ж
    а
    CustomsCode -- К
    о
    д
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    о
    р
    г
    а
    н
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DrawerStatus=None, CBC=None, OKATO=None, PaymentReason=None, TaxPeriod=None, DocNo=None, DocDate=None, TaxPaymentKind=None, CustomsCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.DrawerStatus = DrawerStatus
        self.validate_CodeVariable2Type(self.DrawerStatus)
        self.DrawerStatus_nsprefix_ = "clt_ru"
        self.CBC = CBC
        self.validate_CBCType(self.CBC)
        self.CBC_nsprefix_ = "cltComFin_ru"
        self.OKATO = OKATO
        self.validate_OKATOCodeType(self.OKATO)
        self.OKATO_nsprefix_ = "clt_ru"
        self.PaymentReason = PaymentReason
        self.validate_CodeVariable2Type(self.PaymentReason)
        self.PaymentReason_nsprefix_ = "clt_ru"
        self.TaxPeriod = TaxPeriod
        self.validate_Text10Type(self.TaxPeriod)
        self.TaxPeriod_nsprefix_ = "clt_ru"
        self.DocNo = DocNo
        self.validate_TaxDocIDTextType(self.DocNo)
        self.DocNo_nsprefix_ = "cltComFin_ru"
        self.DocDate = DocDate
        self.validate_TaxDocDateCodeTextType(self.DocDate)
        self.DocDate_nsprefix_ = "cltComFin_ru"
        self.TaxPaymentKind = TaxPaymentKind
        self.validate_CodeVariable2Type(self.TaxPaymentKind)
        self.TaxPaymentKind_nsprefix_ = "clt_ru"
        self.CustomsCode = CustomsCode
        self.validate_CustomsCodeType(self.CustomsCode)
        self.CustomsCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DepartmentalInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DepartmentalInfoType.subclass:
            return DepartmentalInfoType.subclass(*args_, **kwargs_)
        else:
            return DepartmentalInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DrawerStatus(self):
        return self.DrawerStatus
    def set_DrawerStatus(self, DrawerStatus):
        self.DrawerStatus = DrawerStatus
    def get_CBC(self):
        return self.CBC
    def set_CBC(self, CBC):
        self.CBC = CBC
    def get_OKATO(self):
        return self.OKATO
    def set_OKATO(self, OKATO):
        self.OKATO = OKATO
    def get_PaymentReason(self):
        return self.PaymentReason
    def set_PaymentReason(self, PaymentReason):
        self.PaymentReason = PaymentReason
    def get_TaxPeriod(self):
        return self.TaxPeriod
    def set_TaxPeriod(self, TaxPeriod):
        self.TaxPeriod = TaxPeriod
    def get_DocNo(self):
        return self.DocNo
    def set_DocNo(self, DocNo):
        self.DocNo = DocNo
    def get_DocDate(self):
        return self.DocDate
    def set_DocDate(self, DocDate):
        self.DocDate = DocDate
    def get_TaxPaymentKind(self):
        return self.TaxPaymentKind
    def set_TaxPaymentKind(self, TaxPaymentKind):
        self.TaxPaymentKind = TaxPaymentKind
    def get_CustomsCode(self):
        return self.CustomsCode
    def set_CustomsCode(self, CustomsCode):
        self.CustomsCode = CustomsCode
    def validate_CodeVariable2Type(self, value):
        result = True
        # Validate type CodeVariable2Type, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CodeVariable2Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CodeVariable2Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CBCType(self, value):
        result = True
        # Validate type CBCType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CBCType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CBCType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_OKATOCodeType(self, value):
        result = True
        # Validate type OKATOCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_OKATOCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_OKATOCodeType_patterns_, ))
                result = False
        return result
    validate_OKATOCodeType_patterns_ = [['^(\\d{5,11})$']]
    def validate_Text10Type(self, value):
        result = True
        # Validate type Text10Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text10Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text10Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TaxDocIDTextType(self, value):
        result = True
        # Validate type TaxDocIDTextType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxDocIDTextType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxDocIDTextType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TaxDocDateCodeTextType(self, value):
        result = True
        # Validate type TaxDocDateCodeTextType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxDocDateCodeTextType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxDocDateCodeTextType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CustomsCodeType(self, value):
        result = True
        # Validate type CustomsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CustomsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CustomsCodeType_patterns_, ))
                result = False
        return result
    validate_CustomsCodeType_patterns_ = [['^([0-9]{2}|[0-9]{5}|[0-9]{8})$']]
    def has__content(self):
        if (
            self.DrawerStatus is not None or
            self.CBC is not None or
            self.OKATO is not None or
            self.PaymentReason is not None or
            self.TaxPeriod is not None or
            self.DocNo is not None or
            self.DocDate is not None or
            self.TaxPaymentKind is not None or
            self.CustomsCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='DepartmentalInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DepartmentalInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DepartmentalInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DepartmentalInfoType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DepartmentalInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='DepartmentalInfoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='DepartmentalInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DrawerStatus is not None:
            namespaceprefix_ = self.DrawerStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.DrawerStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDrawerStatus>%s</%sDrawerStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DrawerStatus), input_name='DrawerStatus')), namespaceprefix_ , eol_))
        if self.CBC is not None:
            namespaceprefix_ = self.CBC_nsprefix_ + ':' if (UseCapturedNS_ and self.CBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCBC>%s</%sCBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CBC), input_name='CBC')), namespaceprefix_ , eol_))
        if self.OKATO is not None:
            namespaceprefix_ = self.OKATO_nsprefix_ + ':' if (UseCapturedNS_ and self.OKATO_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOKATO>%s</%sOKATO>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OKATO), input_name='OKATO')), namespaceprefix_ , eol_))
        if self.PaymentReason is not None:
            namespaceprefix_ = self.PaymentReason_nsprefix_ + ':' if (UseCapturedNS_ and self.PaymentReason_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentReason>%s</%sPaymentReason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PaymentReason), input_name='PaymentReason')), namespaceprefix_ , eol_))
        if self.TaxPeriod is not None:
            namespaceprefix_ = self.TaxPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxPeriod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxPeriod>%s</%sTaxPeriod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TaxPeriod), input_name='TaxPeriod')), namespaceprefix_ , eol_))
        if self.DocNo is not None:
            namespaceprefix_ = self.DocNo_nsprefix_ + ':' if (UseCapturedNS_ and self.DocNo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDocNo>%s</%sDocNo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DocNo), input_name='DocNo')), namespaceprefix_ , eol_))
        if self.DocDate is not None:
            namespaceprefix_ = self.DocDate_nsprefix_ + ':' if (UseCapturedNS_ and self.DocDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDocDate>%s</%sDocDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DocDate), input_name='DocDate')), namespaceprefix_ , eol_))
        if self.TaxPaymentKind is not None:
            namespaceprefix_ = self.TaxPaymentKind_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxPaymentKind_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxPaymentKind>%s</%sTaxPaymentKind>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TaxPaymentKind), input_name='TaxPaymentKind')), namespaceprefix_ , eol_))
        if self.CustomsCode is not None:
            namespaceprefix_ = self.CustomsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomsCode>%s</%sCustomsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CustomsCode), input_name='CustomsCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DrawerStatus':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DrawerStatus')
            value_ = self.gds_validate_string(value_, node, 'DrawerStatus')
            self.DrawerStatus = value_
            self.DrawerStatus_nsprefix_ = child_.prefix
            # validate type CodeVariable2Type
            self.validate_CodeVariable2Type(self.DrawerStatus)
        elif nodeName_ == 'CBC':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CBC')
            value_ = self.gds_validate_string(value_, node, 'CBC')
            self.CBC = value_
            self.CBC_nsprefix_ = child_.prefix
            # validate type CBCType
            self.validate_CBCType(self.CBC)
        elif nodeName_ == 'OKATO':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OKATO')
            value_ = self.gds_validate_string(value_, node, 'OKATO')
            self.OKATO = value_
            self.OKATO_nsprefix_ = child_.prefix
            # validate type OKATOCodeType
            self.validate_OKATOCodeType(self.OKATO)
        elif nodeName_ == 'PaymentReason':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PaymentReason')
            value_ = self.gds_validate_string(value_, node, 'PaymentReason')
            self.PaymentReason = value_
            self.PaymentReason_nsprefix_ = child_.prefix
            # validate type CodeVariable2Type
            self.validate_CodeVariable2Type(self.PaymentReason)
        elif nodeName_ == 'TaxPeriod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TaxPeriod')
            value_ = self.gds_validate_string(value_, node, 'TaxPeriod')
            self.TaxPeriod = value_
            self.TaxPeriod_nsprefix_ = child_.prefix
            # validate type Text10Type
            self.validate_Text10Type(self.TaxPeriod)
        elif nodeName_ == 'DocNo':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DocNo')
            value_ = self.gds_validate_string(value_, node, 'DocNo')
            self.DocNo = value_
            self.DocNo_nsprefix_ = child_.prefix
            # validate type TaxDocIDTextType
            self.validate_TaxDocIDTextType(self.DocNo)
        elif nodeName_ == 'DocDate':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DocDate')
            value_ = self.gds_validate_string(value_, node, 'DocDate')
            self.DocDate = value_
            self.DocDate_nsprefix_ = child_.prefix
            # validate type TaxDocDateCodeTextType
            self.validate_TaxDocDateCodeTextType(self.DocDate)
        elif nodeName_ == 'TaxPaymentKind':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TaxPaymentKind')
            value_ = self.gds_validate_string(value_, node, 'TaxPaymentKind')
            self.TaxPaymentKind = value_
            self.TaxPaymentKind_nsprefix_ = child_.prefix
            # validate type CodeVariable2Type
            self.validate_CodeVariable2Type(self.TaxPaymentKind)
        elif nodeName_ == 'CustomsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CustomsCode')
            value_ = self.gds_validate_string(value_, node, 'CustomsCode')
            self.CustomsCode = value_
            self.CustomsCode_nsprefix_ = child_.prefix
            # validate type CustomsCodeType
            self.validate_CustomsCodeType(self.CustomsCode)
# end class DepartmentalInfoType


class ForeignPersonType(GeneratedsSuper):
    """ForeignPersonType -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    и
    н
    о
    с
    т
    р
    а
    н
    н
    о
    й
    с
    т
    о
    р
    о
    н
    ы
    к
    о
    н
    т
    р
    а
    к
    т
    а
    Phone -- Т
    е
    л
    е
    ф
    о
    н
    и
    н
    о
    с
    т
    р
    а
    н
    н
    о
    й
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    OrganizationName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    PostalAddress -- П
    о
    ч
    т
    о
    в
    ы
    й
    а
    д
    р
    е
    с
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Phone=None, OrganizationName=None, PostalAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.Phone = Phone
        self.validate_PhoneNumberType(self.Phone)
        self.Phone_nsprefix_ = "clt_ru"
        self.OrganizationName = OrganizationName
        self.validate_NameType(self.OrganizationName)
        self.OrganizationName_nsprefix_ = "clt_ru"
        self.PostalAddress = PostalAddress
        self.PostalAddress_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForeignPersonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForeignPersonType.subclass:
            return ForeignPersonType.subclass(*args_, **kwargs_)
        else:
            return ForeignPersonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Phone(self):
        return self.Phone
    def set_Phone(self, Phone):
        self.Phone = Phone
    def get_OrganizationName(self):
        return self.OrganizationName
    def set_OrganizationName(self, OrganizationName):
        self.OrganizationName = OrganizationName
    def get_PostalAddress(self):
        return self.PostalAddress
    def set_PostalAddress(self, PostalAddress):
        self.PostalAddress = PostalAddress
    def validate_PhoneNumberType(self, value):
        result = True
        # Validate type PhoneNumberType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PhoneNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PhoneNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Phone is not None or
            self.OrganizationName is not None or
            self.PostalAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='ForeignPersonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ForeignPersonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ForeignPersonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ForeignPersonType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ForeignPersonType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ForeignPersonType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='ForeignPersonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Phone is not None:
            namespaceprefix_ = self.Phone_nsprefix_ + ':' if (UseCapturedNS_ and self.Phone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhone>%s</%sPhone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Phone), input_name='Phone')), namespaceprefix_ , eol_))
        if self.OrganizationName is not None:
            namespaceprefix_ = self.OrganizationName_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganizationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationName>%s</%sOrganizationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganizationName), input_name='OrganizationName')), namespaceprefix_ , eol_))
        if self.PostalAddress is not None:
            namespaceprefix_ = self.PostalAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.PostalAddress_nsprefix_) else ''
            self.PostalAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PostalAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Phone')
            value_ = self.gds_validate_string(value_, node, 'Phone')
            self.Phone = value_
            self.Phone_nsprefix_ = child_.prefix
            # validate type PhoneNumberType
            self.validate_PhoneNumberType(self.Phone)
        elif nodeName_ == 'OrganizationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationName')
            value_ = self.gds_validate_string(value_, node, 'OrganizationName')
            self.OrganizationName = value_
            self.OrganizationName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.OrganizationName)
        elif nodeName_ == 'PostalAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PostalAddress = obj_
            obj_.original_tagname_ = 'PostalAddress'
# end class ForeignPersonType


class GoodsPlaceType(GeneratedsSuper):
    """GoodsPlaceType -- О
    п
    и
    с
    а
    н
    и
    е
    г
    р
    у
    з
    о
    в
    ы
    х
    м
    е
    с
    т
    PlaceKind -- К
    о
    д
    в
    и
    д
    а
    г
    р
    у
    з
    о
    в
    о
    г
    о
    м
    е
    с
    т
    а
    и
    з
    с
    п
    р
    а
    в
    о
    ч
    н
    и
    к
    а
    Н
    С
    И
    PlacesQuantity -- О
    б
    щ
    е
    е
    к
    о
    л
    и
    ч
    е
    с
    т
    в
    о
    г
    р
    у
    з
    о
    в
    ы
    х
    м
    е
    с
    т
    т
    о
    в
    а
    р
    а
    PlaceWeightQuantity -- В
    е
    с
    м
    е
    с
    т
    а
    (
    к
    г
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PlaceKind=None, PlacesQuantity=None, PlaceWeightQuantity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.PlaceKind = PlaceKind
        self.validate_PackageCodeType(self.PlaceKind)
        self.PlaceKind_nsprefix_ = "clt_ru"
        self.PlacesQuantity = PlacesQuantity
        self.validate_PackagesQuantityType(self.PlacesQuantity)
        self.PlacesQuantity_nsprefix_ = "clt_ru"
        self.PlaceWeightQuantity = PlaceWeightQuantity
        self.validate_QuantityBasisType(self.PlaceWeightQuantity)
        self.PlaceWeightQuantity_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GoodsPlaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GoodsPlaceType.subclass:
            return GoodsPlaceType.subclass(*args_, **kwargs_)
        else:
            return GoodsPlaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PlaceKind(self):
        return self.PlaceKind
    def set_PlaceKind(self, PlaceKind):
        self.PlaceKind = PlaceKind
    def get_PlacesQuantity(self):
        return self.PlacesQuantity
    def set_PlacesQuantity(self, PlacesQuantity):
        self.PlacesQuantity = PlacesQuantity
    def get_PlaceWeightQuantity(self):
        return self.PlaceWeightQuantity
    def set_PlaceWeightQuantity(self, PlaceWeightQuantity):
        self.PlaceWeightQuantity = PlaceWeightQuantity
    def validate_PackageCodeType(self, value):
        result = True
        # Validate type PackageCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on PackageCodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_PackagesQuantityType(self, value):
        result = True
        # Validate type PackagesQuantityType, a restriction on CategoryCust:IntegerCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PackagesQuantityType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on PackagesQuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.PlaceKind is not None or
            self.PlacesQuantity is not None or
            self.PlaceWeightQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GoodsPlaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GoodsPlaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GoodsPlaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GoodsPlaceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GoodsPlaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='GoodsPlaceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GoodsPlaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PlaceKind is not None:
            namespaceprefix_ = self.PlaceKind_nsprefix_ + ':' if (UseCapturedNS_ and self.PlaceKind_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlaceKind>%s</%sPlaceKind>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PlaceKind), input_name='PlaceKind')), namespaceprefix_ , eol_))
        if self.PlacesQuantity is not None:
            namespaceprefix_ = self.PlacesQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.PlacesQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlacesQuantity>%s</%sPlacesQuantity>%s' % (namespaceprefix_ , self.gds_format_integer(self.PlacesQuantity, input_name='PlacesQuantity'), namespaceprefix_ , eol_))
        if self.PlaceWeightQuantity is not None:
            namespaceprefix_ = self.PlaceWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.PlaceWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlaceWeightQuantity>%s</%sPlaceWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.PlaceWeightQuantity, input_name='PlaceWeightQuantity'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PlaceKind':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PlaceKind')
            value_ = self.gds_validate_string(value_, node, 'PlaceKind')
            self.PlaceKind = value_
            self.PlaceKind_nsprefix_ = child_.prefix
            # validate type PackageCodeType
            self.validate_PackageCodeType(self.PlaceKind)
        elif nodeName_ == 'PlacesQuantity' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PlacesQuantity')
            ival_ = self.gds_validate_integer(ival_, node, 'PlacesQuantity')
            self.PlacesQuantity = ival_
            self.PlacesQuantity_nsprefix_ = child_.prefix
            # validate type PackagesQuantityType
            self.validate_PackagesQuantityType(self.PlacesQuantity)
        elif nodeName_ == 'PlaceWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'PlaceWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'PlaceWeightQuantity')
            self.PlaceWeightQuantity = fval_
            self.PlaceWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.PlaceWeightQuantity)
# end class GoodsPlaceType


class GoodsWeightType(GeneratedsSuper):
    """GoodsWeightType -- В
    е
    с
    н
    е
    т
    т
    о
    ,
    б
    р
    у
    т
    т
    о
    т
    о
    в
    а
    р
    а
    в
    к
    г
    .
    NetWeightQuantity -- В
    е
    с
    т
    о
    в
    а
    р
    а
    н
    е
    т
    т
    о
    (
    к
    г
    )
    GrossWeightQuantity -- В
    е
    с
    т
    о
    в
    а
    р
    а
    б
    р
    у
    т
    т
    о
    (
    к
    г
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NetWeightQuantity=None, GrossWeightQuantity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.NetWeightQuantity = NetWeightQuantity
        self.validate_QuantityBasisType(self.NetWeightQuantity)
        self.NetWeightQuantity_nsprefix_ = "clt_ru"
        self.GrossWeightQuantity = GrossWeightQuantity
        self.validate_QuantityBasisType(self.GrossWeightQuantity)
        self.GrossWeightQuantity_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GoodsWeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GoodsWeightType.subclass:
            return GoodsWeightType.subclass(*args_, **kwargs_)
        else:
            return GoodsWeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NetWeightQuantity(self):
        return self.NetWeightQuantity
    def set_NetWeightQuantity(self, NetWeightQuantity):
        self.NetWeightQuantity = NetWeightQuantity
    def get_GrossWeightQuantity(self):
        return self.GrossWeightQuantity
    def set_GrossWeightQuantity(self, GrossWeightQuantity):
        self.GrossWeightQuantity = GrossWeightQuantity
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.NetWeightQuantity is not None or
            self.GrossWeightQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GoodsWeightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GoodsWeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GoodsWeightType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GoodsWeightType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GoodsWeightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='GoodsWeightType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='GoodsWeightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetWeightQuantity is not None:
            namespaceprefix_ = self.NetWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.NetWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetWeightQuantity>%s</%sNetWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NetWeightQuantity, input_name='NetWeightQuantity'), namespaceprefix_ , eol_))
        if self.GrossWeightQuantity is not None:
            namespaceprefix_ = self.GrossWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GrossWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGrossWeightQuantity>%s</%sGrossWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GrossWeightQuantity, input_name='GrossWeightQuantity'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NetWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NetWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'NetWeightQuantity')
            self.NetWeightQuantity = fval_
            self.NetWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.NetWeightQuantity)
        elif nodeName_ == 'GrossWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GrossWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GrossWeightQuantity')
            self.GrossWeightQuantity = fval_
            self.GrossWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GrossWeightQuantity)
# end class GoodsWeightType


class ImportContractTermsType(GeneratedsSuper):
    """ImportContractTermsType -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    и
    у
    с
    л
    о
    в
    и
    я
    к
    о
    н
    т
    р
    а
    к
    т
    а
    п
    о
    И
    м
    п
    о
    р
    т
    у
    Amount -- О
    б
    щ
    а
    я
    с
    у
    м
    м
    а
    с
    д
    е
    л
    к
    и
    Discount -- О
    б
    щ
    а
    я
    с
    у
    м
    м
    а
    с
    к
    и
    д
    к
    и
    п
    о
    к
    о
    н
    т
    р
    а
    к
    т
    у
    CurrencyCode -- К
    о
    д
    в
    а
    л
    ю
    т
    ы
    к
    о
    н
    т
    р
    а
    к
    т
    а
    (
    ц
    е
    н
    ы
    )
    PaymentModeCode -- К
    о
    д
    р
    а
    с
    ч
    е
    т
    н
    о
    г
    о
    с
    р
    о
    к
    а
    о
    п
    л
    а
    т
    ы
    т
    о
    в
    а
    р
    а
    (
    у
    с
    л
    у
    г
    и
    )
    п
    о
    К
    о
    н
    т
    р
    а
    к
    т
    у
      
    * DueDateCode -- К
      о
      д
      п
      р
      и
      м
      е
      н
      я
      е
      м
      о
      й
      ф
      о
      р
      м
      ы
      р
      а
      с
      ч
      е
      т
      о
      в
      п
      о
      К
      о
      н
      т
      р
      а
      к
      т
      у
    * LastDate -- П
      о
      с
      л
      е
      д
      н
      я
      я
      д
      а
      т
      а
      р
      а
      с
      ч
      е
      т
      о
      в
      п
      о
      к
      о
      н
      т
      р
      а
      к
      т
      у
    * PaymentCurrencyCode -- К
      о
      д
      в
      а
      л
      ю
      т
      ы
      п
      л
      а
      т
      е
      ж
      а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Amount=None, Discount=None, CurrencyCode=None, PaymentModeCode=None, DueDateCode=None, LastDate=None, PaymentCurrencyCode=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.Amount = Amount
        self.validate_Quantity18point3Type(self.Amount)
        self.Amount_nsprefix_ = "clt_ru"
        self.Discount = Discount
        self.validate_Quantity18point3Type(self.Discount)
        self.Discount_nsprefix_ = "clt_ru"
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyA3CodeType(self.CurrencyCode)
        self.CurrencyCode_nsprefix_ = "clt_ru"
        self.PaymentModeCode = PaymentModeCode
        self.validate_PaymentModeCodeType(self.PaymentModeCode)
        self.PaymentModeCode_nsprefix_ = "cltComFin_ru"
        if DueDateCode is None:
            self.DueDateCode = []
        else:
            self.DueDateCode = DueDateCode
        self.DueDateCode_nsprefix_ = "clt_ru"
        if isinstance(LastDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LastDate, '%Y-%m-%d').date()
        else:
            initvalue_ = LastDate
        self.LastDate = initvalue_
        self.LastDate_nsprefix_ = "clt_ru"
        if PaymentCurrencyCode is None:
            self.PaymentCurrencyCode = []
        else:
            self.PaymentCurrencyCode = PaymentCurrencyCode
        self.PaymentCurrencyCode_nsprefix_ = "clt_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImportContractTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImportContractTermsType.subclass:
            return ImportContractTermsType.subclass(*args_, **kwargs_)
        else:
            return ImportContractTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Amount(self):
        return self.Amount
    def set_Amount(self, Amount):
        self.Amount = Amount
    def get_Discount(self):
        return self.Discount
    def set_Discount(self, Discount):
        self.Discount = Discount
    def get_CurrencyCode(self):
        return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode):
        self.CurrencyCode = CurrencyCode
    def get_PaymentModeCode(self):
        return self.PaymentModeCode
    def set_PaymentModeCode(self, PaymentModeCode):
        self.PaymentModeCode = PaymentModeCode
    def get_DueDateCode(self):
        return self.DueDateCode
    def set_DueDateCode(self, DueDateCode):
        self.DueDateCode = DueDateCode
    def add_DueDateCode(self, value):
        self.DueDateCode.append(value)
    def insert_DueDateCode_at(self, index, value):
        self.DueDateCode.insert(index, value)
    def replace_DueDateCode_at(self, index, value):
        self.DueDateCode[index] = value
    def get_LastDate(self):
        return self.LastDate
    def set_LastDate(self, LastDate):
        self.LastDate = LastDate
    def get_PaymentCurrencyCode(self):
        return self.PaymentCurrencyCode
    def set_PaymentCurrencyCode(self, PaymentCurrencyCode):
        self.PaymentCurrencyCode = PaymentCurrencyCode
    def add_PaymentCurrencyCode(self, value):
        self.PaymentCurrencyCode.append(value)
    def insert_PaymentCurrencyCode_at(self, index, value):
        self.PaymentCurrencyCode.insert(index, value)
    def replace_PaymentCurrencyCode_at(self, index, value):
        self.PaymentCurrencyCode[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_Quantity18point3Type(self, value):
        result = True
        # Validate type Quantity18point3Type, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Quantity18point3Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Quantity18point3Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_CurrencyA3CodeType(self, value):
        result = True
        # Validate type CurrencyA3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CurrencyA3CodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_PaymentModeCodeType(self, value):
        result = True
        # Validate type PaymentModeCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_PaymentModeCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PaymentModeCodeType_patterns_, ))
                result = False
        return result
    validate_PaymentModeCodeType_patterns_ = [['^(\\d{2})$']]
    def validate_Numeric1Type(self, value):
        result = True
        # Validate type Numeric1Type, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Numeric1Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Numeric1Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.Amount is not None or
            self.Discount is not None or
            self.CurrencyCode is not None or
            self.PaymentModeCode is not None or
            self.DueDateCode or
            self.LastDate is not None or
            self.PaymentCurrencyCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='ImportContractTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImportContractTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImportContractTermsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImportContractTermsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImportContractTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ImportContractTermsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='ImportContractTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amount is not None:
            namespaceprefix_ = self.Amount_nsprefix_ + ':' if (UseCapturedNS_ and self.Amount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAmount>%s</%sAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Amount, input_name='Amount'), namespaceprefix_ , eol_))
        if self.Discount is not None:
            namespaceprefix_ = self.Discount_nsprefix_ + ':' if (UseCapturedNS_ and self.Discount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscount>%s</%sDiscount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Discount, input_name='Discount'), namespaceprefix_ , eol_))
        if self.CurrencyCode is not None:
            namespaceprefix_ = self.CurrencyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrencyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), namespaceprefix_ , eol_))
        if self.PaymentModeCode is not None:
            namespaceprefix_ = self.PaymentModeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.PaymentModeCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentModeCode>%s</%sPaymentModeCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PaymentModeCode), input_name='PaymentModeCode')), namespaceprefix_ , eol_))
        for DueDateCode_ in self.DueDateCode:
            namespaceprefix_ = self.DueDateCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DueDateCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDueDateCode>%s</%sDueDateCode>%s' % (namespaceprefix_ , self.gds_format_decimal(DueDateCode_, input_name='DueDateCode'), namespaceprefix_ , eol_))
        if self.LastDate is not None:
            namespaceprefix_ = self.LastDate_nsprefix_ + ':' if (UseCapturedNS_ and self.LastDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLastDate>%s</%sLastDate>%s' % (namespaceprefix_ , self.gds_format_date(self.LastDate, input_name='LastDate'), namespaceprefix_ , eol_))
        for PaymentCurrencyCode_ in self.PaymentCurrencyCode:
            namespaceprefix_ = self.PaymentCurrencyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.PaymentCurrencyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentCurrencyCode>%s</%sPaymentCurrencyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(PaymentCurrencyCode_), input_name='PaymentCurrencyCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Amount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Amount')
            fval_ = self.gds_validate_decimal(fval_, node, 'Amount')
            self.Amount = fval_
            self.Amount_nsprefix_ = child_.prefix
            # validate type Quantity18point3Type
            self.validate_Quantity18point3Type(self.Amount)
        elif nodeName_ == 'Discount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Discount')
            fval_ = self.gds_validate_decimal(fval_, node, 'Discount')
            self.Discount = fval_
            self.Discount_nsprefix_ = child_.prefix
            # validate type Quantity18point3Type
            self.validate_Quantity18point3Type(self.Discount)
        elif nodeName_ == 'CurrencyCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CurrencyCode')
            value_ = self.gds_validate_string(value_, node, 'CurrencyCode')
            self.CurrencyCode = value_
            self.CurrencyCode_nsprefix_ = child_.prefix
            # validate type CurrencyA3CodeType
            self.validate_CurrencyA3CodeType(self.CurrencyCode)
        elif nodeName_ == 'PaymentModeCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PaymentModeCode')
            value_ = self.gds_validate_string(value_, node, 'PaymentModeCode')
            self.PaymentModeCode = value_
            self.PaymentModeCode_nsprefix_ = child_.prefix
            # validate type PaymentModeCodeType
            self.validate_PaymentModeCodeType(self.PaymentModeCode)
        elif nodeName_ == 'DueDateCode' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DueDateCode')
            fval_ = self.gds_validate_decimal(fval_, node, 'DueDateCode')
            self.DueDateCode.append(fval_)
            self.DueDateCode_nsprefix_ = child_.prefix
            # validate type Numeric1Type
            self.validate_Numeric1Type(self.DueDateCode[-1])
        elif nodeName_ == 'LastDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.LastDate = dval_
            self.LastDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.LastDate)
        elif nodeName_ == 'PaymentCurrencyCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PaymentCurrencyCode')
            value_ = self.gds_validate_string(value_, node, 'PaymentCurrencyCode')
            self.PaymentCurrencyCode.append(value_)
            self.PaymentCurrencyCode_nsprefix_ = child_.prefix
            # validate type CurrencyA3CodeType
            self.validate_CurrencyA3CodeType(self.PaymentCurrencyCode[-1])
# end class ImportContractTermsType


class InvoiceGoodsType(GeneratedsSuper):
    """InvoiceGoodsType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    т
    о
    в
    а
    р
    а
    х
    и
    н
    в
    о
    й
    с
    а
    GoodMarking -- А
    р
    т
    и
    к
    у
    л
    (
    к
    о
    д
    т
    о
    в
    а
    р
    а
    ,
    н
    о
    м
    е
    р
    п
    о
    к
    а
    т
    а
    л
    о
    г
    у
    п
    р
    о
    и
    з
    в
    о
    д
    и
    т
    е
    л
    я
    )
    GoodsCode -- К
    о
    д
    т
    о
    в
    а
    р
    а
    п
    о
    Т
    Н
    В
    Э
    Д
    Е
    А
    Э
    С
    SupplementaryQualifierName -- Н
    а
    з
    в
    а
    н
    и
    е
    д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    о
    й
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    п
    р
    и
    в
    о
    з
    м
    о
    ж
    н
    о
    с
    т
    и
    е
    е
    у
    к
    а
    з
    а
    н
    и
    я
    GoodsDescription -- О
    п
    и
    с
    а
    н
    и
    е
    т
    о
    в
    а
    р
    а
    т
    е
    к
    с
    т
    о
    в
    о
    е
    (
    с
    о
    д
    е
    р
    ж
    и
    т
    н
    а
    з
    в
    а
    н
    и
    е
    м
    а
    р
    о
    к
    ,
    м
    о
    д
    е
    л
    е
    й
    т
    о
    в
    а
    р
    о
    в
    и
    /
    и
    л
    и
    и
    х
    и
    н
    д
    и
    в
    и
    д
    у
    а
    л
    ь
    н
    ы
    е
    н
    о
    м
    е
    р
    а
    -
    п
    р
    и
    к
    а
    з
    Г
    Т
    К
    Р
    Ф
    о
    т
    13.05.03
    №
    500)
    GoodsQuantity -- К
    о
    л
    и
    ч
    е
    с
    т
    в
    о
    т
    о
    в
    а
    р
    а
    ,
    у
    с
    л
    у
    г
    б
    е
    з
    у
    к
    а
    з
    а
    н
    и
    я
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
      
    * MeasureUnitQualifierName -- Н
      а
      з
      в
      а
      н
      и
      е
      е
      д
      и
      н
      и
      ц
      ы
      и
      з
      м
      е
      р
      е
      н
      и
      я
      п
      р
      и
      в
      о
      з
      м
      о
      ж
      н
      о
      с
      т
      и
      е
      е
      у
      к
      а
      з
      а
      н
      и
      я
    * GrossWeightQuantity -- В
      е
      с
      т
      о
      в
      а
      р
      а
      ,
      б
      р
      у
      т
      т
      о
      (
      к
      г
      )
    * NetWeightQuantity -- В
      е
      с
      т
      о
      в
      а
      р
      а
      ,
      н
      е
      т
      т
      о
      (
      к
      г
      )
    * Price -- Ц
      е
      н
      а
      т
      о
      в
      а
      р
      а
      /
      у
      с
      л
      у
      г
      и
    * TotalCost -- С
      т
      о
      и
      м
      о
      с
      т
      ь
      в
      с
      е
      г
      о
      к
      о
      л
      и
      ч
      е
      с
      т
      в
      а
      п
      о
      с
      т
      а
      в
      л
      я
      е
      м
      о
      г
      о
      (
      о
      т
      г
      р
      у
      ж
      е
      н
      н
      о
      г
      о
      )
      п
      о
      с
      ч
      е
      т
      у
      -
      ф
      а
      к
      т
      у
      р
      е
      т
      о
      в
      а
      р
      а
      (
      в
      ы
      п
      о
      л
      н
      е
      н
      н
      ы
      х
      р
      а
      б
      о
      т
      ,
      о
      к
      а
      з
      а
      н
      н
      ы
      х
      у
      с
      л
      у
      г
      )
      б
      е
      з
      н
      а
      л
      о
      г
      а
    * Discount -- C
      у
      м
      м
      а
      с
      к
      и
      д
      к
      и
    * DiscountPercentage -- С
      у
      м
      м
      а
      с
      к
      и
      д
      к
      и
      , %
    * OriginCountryCode -- К
      о
      д
      с
      т
      р
      а
      н
      ы
      п
      р
      о
      и
      с
      х
      о
      ж
      д
      е
      н
      и
      я
      ,
      у
      к
      а
      з
      ы
      в
      а
      ю
      т
      с
      я
      в
      о
      т
      н
      о
      ш
      е
      н
      и
      и
      т
      о
      в
      а
      р
      о
      в
      ,
      с
      т
      р
      а
      н
      о
      й
      п
      р
      о
      и
      с
      х
      о
      ж
      д
      е
      н
      и
      я
      к
      о
      т
      о
      р
      ы
      х
      н
      е
      я
      в
      л
      я
      е
      т
      с
      я
      Р
      о
      с
      с
      и
      й
      с
      к
      а
      я
      Ф
      е
      д
      е
      р
      а
      ц
      и
      я
      .
    * ServiceCharges -- В
      ы
      ч
      е
      т
      ы
      (
      р
      а
      с
      х
      о
      д
      ы
      н
      а
      с
      т
      р
      о
      и
      т
      е
      л
      ь
      с
      т
      в
      о
      ,
      в
      о
      з
      в
      е
      д
      е
      н
      и
      е
      ,
      с
      б
      о
      р
      к
      у
      ,
      м
      о
      н
      т
      а
      ж
      ,
      о
      б
      с
      л
      у
      ж
      и
      в
      а
      н
      и
      е
      и
      л
      и
      о
      к
      а
      з
      а
      н
      и
      е
      т
      е
      х
      н
      и
      ч
      е
      с
      к
      о
      г
      о
      с
      о
      д
      е
      й
      с
      т
      в
      и
      я
      ,
      п
      р
      о
      и
      з
      в
      о
      д
      и
      м
      ы
      е
      п
      о
      с
      л
      е
      п
      р
      и
      б
      ы
      т
      и
      я
      н
      а
      Т
      а
      м
      о
      ж
      е
      н
      н
      у
      ю
      т
      е
      р
      р
      и
      т
      о
      р
      и
      ю
      Т
      С
      )
    * TransportCharges -- В
      ы
      ч
      е
      т
      ы
      (
      р
      а
      с
      х
      о
      д
      ы
      п
      о
      п
      е
      р
      е
      в
      о
      з
      к
      е
      (
      т
      р
      а
      н
      с
      п
      о
      р
      т
      и
      р
      о
      в
      к
      е
      )
      т
      о
      в
      а
      р
      о
      в
      п
      о
      с
      л
      е
      и
      х
      п
      р
      и
      б
      ы
      т
      и
      я
      н
      а
      т
      а
      м
      о
      ж
      е
      н
      н
      у
      ю
      т
      е
      р
      р
      и
      т
      о
      р
      и
      ю
      Т
      С
      )
    * OtherCharges -- И
      н
      ф
      о
      р
      м
      а
      ц
      и
      я
      о
      п
      р
      о
      ч
      и
      х
      р
      а
      с
      х
      о
      д
      а
      х
    * AdditionalGoodsDescription -- Д
      о
      п
      о
      л
      н
      и
      т
      е
      л
      ь
      н
      ы
      е
      х
      а
      р
      а
      к
      т
      е
      р
      и
      с
      т
      и
      к
      и
      т
      о
      в
      а
      р
      о
      в
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GoodMarking=None, GoodsCode=None, SupplementaryQualifierName=None, GoodsDescription=None, GoodsQuantity=None, MeasureUnitQualifierName=None, GrossWeightQuantity=None, NetWeightQuantity=None, Price=None, TotalCost=None, Discount=None, DiscountPercentage=None, OriginCountryCode=None, ServiceCharges=None, TransportCharges=None, OtherCharges=None, AdditionalGoodsDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.GoodMarking = GoodMarking
        self.validate_GoodMarkingType(self.GoodMarking)
        self.GoodMarking_nsprefix_ = "clt_ru"
        self.GoodsCode = GoodsCode
        self.validate_GoodsNomenclatureCodeType(self.GoodsCode)
        self.GoodsCode_nsprefix_ = "clt_ru"
        self.SupplementaryQualifierName = SupplementaryQualifierName
        self.validate_MeasureUnitQualifierNameType(self.SupplementaryQualifierName)
        self.SupplementaryQualifierName_nsprefix_ = "clt_ru"
        if GoodsDescription is None:
            self.GoodsDescription = []
        else:
            self.GoodsDescription = GoodsDescription
        self.GoodsDescription_nsprefix_ = "clt_ru"
        self.GoodsQuantity = GoodsQuantity
        self.validate_QuantityBasisType(self.GoodsQuantity)
        self.GoodsQuantity_nsprefix_ = "clt_ru"
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
        self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        self.MeasureUnitQualifierName_nsprefix_ = "clt_ru"
        self.GrossWeightQuantity = GrossWeightQuantity
        self.validate_QuantityBasisType(self.GrossWeightQuantity)
        self.GrossWeightQuantity_nsprefix_ = "clt_ru"
        self.NetWeightQuantity = NetWeightQuantity
        self.validate_QuantityBasisType(self.NetWeightQuantity)
        self.NetWeightQuantity_nsprefix_ = "clt_ru"
        self.Price = Price
        self.validate_MoreAccuratePriceType(self.Price)
        self.Price_nsprefix_ = "cltComFin_ru"
        self.TotalCost = TotalCost
        self.validate_AmountType(self.TotalCost)
        self.TotalCost_nsprefix_ = "clt_ru"
        self.Discount = Discount
        self.validate_AmountType(self.Discount)
        self.Discount_nsprefix_ = "clt_ru"
        self.DiscountPercentage = DiscountPercentage
        self.validate_ProcentNumericType(self.DiscountPercentage)
        self.DiscountPercentage_nsprefix_ = "clt_ru"
        self.OriginCountryCode = OriginCountryCode
        self.validate_CountryN3CodeType(self.OriginCountryCode)
        self.OriginCountryCode_nsprefix_ = "clt_ru"
        self.ServiceCharges = ServiceCharges
        self.validate_AmountType(self.ServiceCharges)
        self.ServiceCharges_nsprefix_ = "clt_ru"
        self.TransportCharges = TransportCharges
        self.validate_AmountType(self.TransportCharges)
        self.TransportCharges_nsprefix_ = "clt_ru"
        if OtherCharges is None:
            self.OtherCharges = []
        else:
            self.OtherCharges = OtherCharges
        self.OtherCharges_nsprefix_ = "catComFin_ru"
        self.AdditionalGoodsDescription = AdditionalGoodsDescription
        self.AdditionalGoodsDescription_nsprefix_ = "catComFin_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceGoodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceGoodsType.subclass:
            return InvoiceGoodsType.subclass(*args_, **kwargs_)
        else:
            return InvoiceGoodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GoodMarking(self):
        return self.GoodMarking
    def set_GoodMarking(self, GoodMarking):
        self.GoodMarking = GoodMarking
    def get_GoodsCode(self):
        return self.GoodsCode
    def set_GoodsCode(self, GoodsCode):
        self.GoodsCode = GoodsCode
    def get_SupplementaryQualifierName(self):
        return self.SupplementaryQualifierName
    def set_SupplementaryQualifierName(self, SupplementaryQualifierName):
        self.SupplementaryQualifierName = SupplementaryQualifierName
    def get_GoodsDescription(self):
        return self.GoodsDescription
    def set_GoodsDescription(self, GoodsDescription):
        self.GoodsDescription = GoodsDescription
    def add_GoodsDescription(self, value):
        self.GoodsDescription.append(value)
    def insert_GoodsDescription_at(self, index, value):
        self.GoodsDescription.insert(index, value)
    def replace_GoodsDescription_at(self, index, value):
        self.GoodsDescription[index] = value
    def get_GoodsQuantity(self):
        return self.GoodsQuantity
    def set_GoodsQuantity(self, GoodsQuantity):
        self.GoodsQuantity = GoodsQuantity
    def get_MeasureUnitQualifierName(self):
        return self.MeasureUnitQualifierName
    def set_MeasureUnitQualifierName(self, MeasureUnitQualifierName):
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
    def get_GrossWeightQuantity(self):
        return self.GrossWeightQuantity
    def set_GrossWeightQuantity(self, GrossWeightQuantity):
        self.GrossWeightQuantity = GrossWeightQuantity
    def get_NetWeightQuantity(self):
        return self.NetWeightQuantity
    def set_NetWeightQuantity(self, NetWeightQuantity):
        self.NetWeightQuantity = NetWeightQuantity
    def get_Price(self):
        return self.Price
    def set_Price(self, Price):
        self.Price = Price
    def get_TotalCost(self):
        return self.TotalCost
    def set_TotalCost(self, TotalCost):
        self.TotalCost = TotalCost
    def get_Discount(self):
        return self.Discount
    def set_Discount(self, Discount):
        self.Discount = Discount
    def get_DiscountPercentage(self):
        return self.DiscountPercentage
    def set_DiscountPercentage(self, DiscountPercentage):
        self.DiscountPercentage = DiscountPercentage
    def get_OriginCountryCode(self):
        return self.OriginCountryCode
    def set_OriginCountryCode(self, OriginCountryCode):
        self.OriginCountryCode = OriginCountryCode
    def get_ServiceCharges(self):
        return self.ServiceCharges
    def set_ServiceCharges(self, ServiceCharges):
        self.ServiceCharges = ServiceCharges
    def get_TransportCharges(self):
        return self.TransportCharges
    def set_TransportCharges(self, TransportCharges):
        self.TransportCharges = TransportCharges
    def get_OtherCharges(self):
        return self.OtherCharges
    def set_OtherCharges(self, OtherCharges):
        self.OtherCharges = OtherCharges
    def add_OtherCharges(self, value):
        self.OtherCharges.append(value)
    def insert_OtherCharges_at(self, index, value):
        self.OtherCharges.insert(index, value)
    def replace_OtherCharges_at(self, index, value):
        self.OtherCharges[index] = value
    def get_AdditionalGoodsDescription(self):
        return self.AdditionalGoodsDescription
    def set_AdditionalGoodsDescription(self, AdditionalGoodsDescription):
        self.AdditionalGoodsDescription = AdditionalGoodsDescription
    def validate_GoodMarkingType(self, value):
        result = True
        # Validate type GoodMarkingType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GoodMarkingType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on GoodMarkingType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_GoodsNomenclatureCodeType(self, value):
        result = True
        # Validate type GoodsNomenclatureCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_GoodsNomenclatureCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_GoodsNomenclatureCodeType_patterns_, ))
                result = False
        return result
    validate_GoodsNomenclatureCodeType_patterns_ = [['^(\\d{4,10})$']]
    def validate_MeasureUnitQualifierNameType(self, value):
        result = True
        # Validate type MeasureUnitQualifierNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MeasureUnitQualifierNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MeasureUnitQualifierNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_MoreAccuratePriceType(self, value):
        result = True
        # Validate type MoreAccuratePriceType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on MoreAccuratePriceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MoreAccuratePriceType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_AmountType(self, value):
        result = True
        # Validate type AmountType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on AmountType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ProcentNumericType(self, value):
        result = True
        # Validate type ProcentNumericType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_CountryN3CodeType(self, value):
        result = True
        # Validate type CountryN3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryN3CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryN3CodeType_patterns_, ))
                result = False
        return result
    validate_CountryN3CodeType_patterns_ = [['^(\\d{3})$']]
    def has__content(self):
        if (
            self.GoodMarking is not None or
            self.GoodsCode is not None or
            self.SupplementaryQualifierName is not None or
            self.GoodsDescription or
            self.GoodsQuantity is not None or
            self.MeasureUnitQualifierName is not None or
            self.GrossWeightQuantity is not None or
            self.NetWeightQuantity is not None or
            self.Price is not None or
            self.TotalCost is not None or
            self.Discount is not None or
            self.DiscountPercentage is not None or
            self.OriginCountryCode is not None or
            self.ServiceCharges is not None or
            self.TransportCharges is not None or
            self.OtherCharges or
            self.AdditionalGoodsDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='InvoiceGoodsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceGoodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceGoodsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceGoodsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceGoodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='InvoiceGoodsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='InvoiceGoodsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GoodMarking is not None:
            namespaceprefix_ = self.GoodMarking_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodMarking_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodMarking>%s</%sGoodMarking>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodMarking), input_name='GoodMarking')), namespaceprefix_ , eol_))
        if self.GoodsCode is not None:
            namespaceprefix_ = self.GoodsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsCode>%s</%sGoodsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsCode), input_name='GoodsCode')), namespaceprefix_ , eol_))
        if self.SupplementaryQualifierName is not None:
            namespaceprefix_ = self.SupplementaryQualifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.SupplementaryQualifierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupplementaryQualifierName>%s</%sSupplementaryQualifierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SupplementaryQualifierName), input_name='SupplementaryQualifierName')), namespaceprefix_ , eol_))
        for GoodsDescription_ in self.GoodsDescription:
            namespaceprefix_ = self.GoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsDescription>%s</%sGoodsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(GoodsDescription_), input_name='GoodsDescription')), namespaceprefix_ , eol_))
        if self.GoodsQuantity is not None:
            namespaceprefix_ = self.GoodsQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsQuantity>%s</%sGoodsQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GoodsQuantity, input_name='GoodsQuantity'), namespaceprefix_ , eol_))
        if self.MeasureUnitQualifierName is not None:
            namespaceprefix_ = self.MeasureUnitQualifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureUnitQualifierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureUnitQualifierName>%s</%sMeasureUnitQualifierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasureUnitQualifierName), input_name='MeasureUnitQualifierName')), namespaceprefix_ , eol_))
        if self.GrossWeightQuantity is not None:
            namespaceprefix_ = self.GrossWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GrossWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGrossWeightQuantity>%s</%sGrossWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GrossWeightQuantity, input_name='GrossWeightQuantity'), namespaceprefix_ , eol_))
        if self.NetWeightQuantity is not None:
            namespaceprefix_ = self.NetWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.NetWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetWeightQuantity>%s</%sNetWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NetWeightQuantity, input_name='NetWeightQuantity'), namespaceprefix_ , eol_))
        if self.Price is not None:
            namespaceprefix_ = self.Price_nsprefix_ + ':' if (UseCapturedNS_ and self.Price_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrice>%s</%sPrice>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Price, input_name='Price'), namespaceprefix_ , eol_))
        if self.TotalCost is not None:
            namespaceprefix_ = self.TotalCost_nsprefix_ + ':' if (UseCapturedNS_ and self.TotalCost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTotalCost>%s</%sTotalCost>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TotalCost, input_name='TotalCost'), namespaceprefix_ , eol_))
        if self.Discount is not None:
            namespaceprefix_ = self.Discount_nsprefix_ + ':' if (UseCapturedNS_ and self.Discount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscount>%s</%sDiscount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Discount, input_name='Discount'), namespaceprefix_ , eol_))
        if self.DiscountPercentage is not None:
            namespaceprefix_ = self.DiscountPercentage_nsprefix_ + ':' if (UseCapturedNS_ and self.DiscountPercentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscountPercentage>%s</%sDiscountPercentage>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DiscountPercentage, input_name='DiscountPercentage'), namespaceprefix_ , eol_))
        if self.OriginCountryCode is not None:
            namespaceprefix_ = self.OriginCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.OriginCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginCountryCode>%s</%sOriginCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OriginCountryCode), input_name='OriginCountryCode')), namespaceprefix_ , eol_))
        if self.ServiceCharges is not None:
            namespaceprefix_ = self.ServiceCharges_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceCharges_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sServiceCharges>%s</%sServiceCharges>%s' % (namespaceprefix_ , self.gds_format_decimal(self.ServiceCharges, input_name='ServiceCharges'), namespaceprefix_ , eol_))
        if self.TransportCharges is not None:
            namespaceprefix_ = self.TransportCharges_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportCharges_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportCharges>%s</%sTransportCharges>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TransportCharges, input_name='TransportCharges'), namespaceprefix_ , eol_))
        for OtherCharges_ in self.OtherCharges:
            namespaceprefix_ = self.OtherCharges_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherCharges_nsprefix_) else ''
            OtherCharges_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherCharges', pretty_print=pretty_print)
        if self.AdditionalGoodsDescription is not None:
            namespaceprefix_ = self.AdditionalGoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.AdditionalGoodsDescription_nsprefix_) else ''
            self.AdditionalGoodsDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AdditionalGoodsDescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GoodMarking':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodMarking')
            value_ = self.gds_validate_string(value_, node, 'GoodMarking')
            self.GoodMarking = value_
            self.GoodMarking_nsprefix_ = child_.prefix
            # validate type GoodMarkingType
            self.validate_GoodMarkingType(self.GoodMarking)
        elif nodeName_ == 'GoodsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'GoodsCode')
            value_ = self.gds_validate_string(value_, node, 'GoodsCode')
            self.GoodsCode = value_
            self.GoodsCode_nsprefix_ = child_.prefix
            # validate type GoodsNomenclatureCodeType
            self.validate_GoodsNomenclatureCodeType(self.GoodsCode)
        elif nodeName_ == 'SupplementaryQualifierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SupplementaryQualifierName')
            value_ = self.gds_validate_string(value_, node, 'SupplementaryQualifierName')
            self.SupplementaryQualifierName = value_
            self.SupplementaryQualifierName_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierNameType
            self.validate_MeasureUnitQualifierNameType(self.SupplementaryQualifierName)
        elif nodeName_ == 'GoodsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsDescription')
            value_ = self.gds_validate_string(value_, node, 'GoodsDescription')
            self.GoodsDescription.append(value_)
            self.GoodsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.GoodsDescription[-1])
        elif nodeName_ == 'GoodsQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GoodsQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GoodsQuantity')
            self.GoodsQuantity = fval_
            self.GoodsQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GoodsQuantity)
        elif nodeName_ == 'MeasureUnitQualifierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MeasureUnitQualifierName')
            value_ = self.gds_validate_string(value_, node, 'MeasureUnitQualifierName')
            self.MeasureUnitQualifierName = value_
            self.MeasureUnitQualifierName_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierNameType
            self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        elif nodeName_ == 'GrossWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GrossWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GrossWeightQuantity')
            self.GrossWeightQuantity = fval_
            self.GrossWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GrossWeightQuantity)
        elif nodeName_ == 'NetWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NetWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'NetWeightQuantity')
            self.NetWeightQuantity = fval_
            self.NetWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.NetWeightQuantity)
        elif nodeName_ == 'Price' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Price')
            fval_ = self.gds_validate_decimal(fval_, node, 'Price')
            self.Price = fval_
            self.Price_nsprefix_ = child_.prefix
            # validate type MoreAccuratePriceType
            self.validate_MoreAccuratePriceType(self.Price)
        elif nodeName_ == 'TotalCost' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TotalCost')
            fval_ = self.gds_validate_decimal(fval_, node, 'TotalCost')
            self.TotalCost = fval_
            self.TotalCost_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.TotalCost)
        elif nodeName_ == 'Discount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Discount')
            fval_ = self.gds_validate_decimal(fval_, node, 'Discount')
            self.Discount = fval_
            self.Discount_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.Discount)
        elif nodeName_ == 'DiscountPercentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DiscountPercentage')
            fval_ = self.gds_validate_decimal(fval_, node, 'DiscountPercentage')
            self.DiscountPercentage = fval_
            self.DiscountPercentage_nsprefix_ = child_.prefix
            # validate type ProcentNumericType
            self.validate_ProcentNumericType(self.DiscountPercentage)
        elif nodeName_ == 'OriginCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OriginCountryCode')
            value_ = self.gds_validate_string(value_, node, 'OriginCountryCode')
            self.OriginCountryCode = value_
            self.OriginCountryCode_nsprefix_ = child_.prefix
            # validate type CountryN3CodeType
            self.validate_CountryN3CodeType(self.OriginCountryCode)
        elif nodeName_ == 'ServiceCharges' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'ServiceCharges')
            fval_ = self.gds_validate_decimal(fval_, node, 'ServiceCharges')
            self.ServiceCharges = fval_
            self.ServiceCharges_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.ServiceCharges)
        elif nodeName_ == 'TransportCharges' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TransportCharges')
            fval_ = self.gds_validate_decimal(fval_, node, 'TransportCharges')
            self.TransportCharges = fval_
            self.TransportCharges_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.TransportCharges)
        elif nodeName_ == 'OtherCharges':
            obj_ = OtherChargesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OtherCharges.append(obj_)
            obj_.original_tagname_ = 'OtherCharges'
        elif nodeName_ == 'AdditionalGoodsDescription':
            obj_ = AdditionalGoodsDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdditionalGoodsDescription = obj_
            obj_.original_tagname_ = 'AdditionalGoodsDescription'
# end class InvoiceGoodsType


class InvoiceParticipantType(GeneratedsSuper):
    """InvoiceParticipantType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    у
    ч
    а
    с
    т
    н
    и
    к
    а
    х
    с
    д
    е
    л
    к
    и
    п
    о
    к
    у
    п
    л
    и
    -
    п
    р
    о
    д
    а
    ж
    и
    (
    п
    р
    о
    д
    а
    в
    е
    ц
    и
    л
    и
    п
    о
    к
    у
    п
    а
    т
    е
    л
    ь
    )
    CompanyID -- И
    н
    д
    и
    в
    и
    д
    у
    а
    л
    ь
    н
    ы
    й
    н
    о
    м
    е
    р
    н
    а
    л
    о
    г
    о
    п
    л
    а
    т
    е
    л
    ь
    щ
    и
    к
    а
    в
    с
    о
    о
    т
    в
    е
    т
    с
    т
    в
    и
    и
    с
    н
    а
    ц
    и
    о
    н
    а
    л
    ь
    н
    о
    й
    с
    и
    с
    т
    е
    м
    о
    й
    к
    о
    д
    и
    р
    о
    в
    а
    н
    и
    я
    (
    в
    Р
    Ф
    д
    л
    я
    ю
    р
    .
    л
    и
    ц
    -
    И
    Н
    Н
    )
    KPPCode -- К
    о
    д
    п
    р
    и
    ч
    и
    н
    ы
    п
    о
    с
    т
    а
    н
    о
    в
    к
    и
    н
    а
    н
    а
    л
    о
    г
    о
    в
    ы
    й
    у
    ч
    е
    т
    Name -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    Phone -- Т
    е
    л
    е
    ф
    о
    н
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CompanyID=None, KPPCode=None, Name=None, Phone=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.CompanyID = CompanyID
        self.validate_INNIDType(self.CompanyID)
        self.CompanyID_nsprefix_ = "clt_ru"
        self.KPPCode = KPPCode
        self.validate_KPPCodeType(self.KPPCode)
        self.KPPCode_nsprefix_ = "clt_ru"
        self.Name = Name
        self.validate_NameType(self.Name)
        self.Name_nsprefix_ = "clt_ru"
        self.Phone = Phone
        self.validate_PhoneNumberType(self.Phone)
        self.Phone_nsprefix_ = "clt_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceParticipantType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceParticipantType.subclass:
            return InvoiceParticipantType.subclass(*args_, **kwargs_)
        else:
            return InvoiceParticipantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CompanyID(self):
        return self.CompanyID
    def set_CompanyID(self, CompanyID):
        self.CompanyID = CompanyID
    def get_KPPCode(self):
        return self.KPPCode
    def set_KPPCode(self, KPPCode):
        self.KPPCode = KPPCode
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Phone(self):
        return self.Phone
    def set_Phone(self, Phone):
        self.Phone = Phone
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_INNIDType(self, value):
        result = True
        # Validate type INNIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INNIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on INNIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_KPPCodeType(self, value):
        result = True
        # Validate type KPPCodeType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_KPPCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_KPPCodeType_patterns_, ))
                result = False
        return result
    validate_KPPCodeType_patterns_ = [['^(\\d{9})$']]
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_PhoneNumberType(self, value):
        result = True
        # Validate type PhoneNumberType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PhoneNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PhoneNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.CompanyID is not None or
            self.KPPCode is not None or
            self.Name is not None or
            self.Phone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='InvoiceParticipantType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceParticipantType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceParticipantType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceParticipantType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceParticipantType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='InvoiceParticipantType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='InvoiceParticipantType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompanyID is not None:
            namespaceprefix_ = self.CompanyID_nsprefix_ + ':' if (UseCapturedNS_ and self.CompanyID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompanyID>%s</%sCompanyID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CompanyID), input_name='CompanyID')), namespaceprefix_ , eol_))
        if self.KPPCode is not None:
            namespaceprefix_ = self.KPPCode_nsprefix_ + ':' if (UseCapturedNS_ and self.KPPCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKPPCode>%s</%sKPPCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.KPPCode), input_name='KPPCode')), namespaceprefix_ , eol_))
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.Phone is not None:
            namespaceprefix_ = self.Phone_nsprefix_ + ':' if (UseCapturedNS_ and self.Phone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhone>%s</%sPhone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Phone), input_name='Phone')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CompanyID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CompanyID')
            value_ = self.gds_validate_string(value_, node, 'CompanyID')
            self.CompanyID = value_
            self.CompanyID_nsprefix_ = child_.prefix
            # validate type INNIDType
            self.validate_INNIDType(self.CompanyID)
        elif nodeName_ == 'KPPCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'KPPCode')
            value_ = self.gds_validate_string(value_, node, 'KPPCode')
            self.KPPCode = value_
            self.KPPCode_nsprefix_ = child_.prefix
            # validate type KPPCodeType
            self.validate_KPPCodeType(self.KPPCode)
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.Name)
        elif nodeName_ == 'Phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Phone')
            value_ = self.gds_validate_string(value_, node, 'Phone')
            self.Phone = value_
            self.Phone_nsprefix_ = child_.prefix
            # validate type PhoneNumberType
            self.validate_PhoneNumberType(self.Phone)
# end class InvoiceParticipantType


class InvoiceSaleTermsType(GeneratedsSuper):
    """InvoiceSaleTermsType -- С
    р
    о
    к
    о
    п
    л
    а
    т
    ы
    п
    о
    и
    н
    в
    о
    й
    с
    у
    SaleTermsCode -- К
    о
    д
    с
    р
    о
    к
    а
    о
    п
    л
    а
    т
    ы
    п
    о
    и
    н
    в
    о
    й
    с
    у
    SaleTermsDescription -- О
    п
    и
    с
    а
    н
    и
    е
    с
    р
    о
    к
    а
    о
    п
    л
    а
    т
    ы
    п
    о
    и
    н
    в
    о
    й
    с
    у
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SaleTermsCode=None, SaleTermsDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.SaleTermsCode = SaleTermsCode
        self.validate_SaleTermsCodeType(self.SaleTermsCode)
        self.SaleTermsCode_nsprefix_ = "cltComFin_ru"
        self.SaleTermsDescription = SaleTermsDescription
        self.validate_FreeText250Type(self.SaleTermsDescription)
        self.SaleTermsDescription_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceSaleTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceSaleTermsType.subclass:
            return InvoiceSaleTermsType.subclass(*args_, **kwargs_)
        else:
            return InvoiceSaleTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SaleTermsCode(self):
        return self.SaleTermsCode
    def set_SaleTermsCode(self, SaleTermsCode):
        self.SaleTermsCode = SaleTermsCode
    def get_SaleTermsDescription(self):
        return self.SaleTermsDescription
    def set_SaleTermsDescription(self, SaleTermsDescription):
        self.SaleTermsDescription = SaleTermsDescription
    def validate_SaleTermsCodeType(self, value):
        result = True
        # Validate type SaleTermsCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_SaleTermsCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SaleTermsCodeType_patterns_, ))
                result = False
        return result
    validate_SaleTermsCodeType_patterns_ = [['^(\\d{2})$']]
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.SaleTermsCode is not None or
            self.SaleTermsDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0"  xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='InvoiceSaleTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceSaleTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceSaleTermsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceSaleTermsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceSaleTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='InvoiceSaleTermsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0"  xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='InvoiceSaleTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SaleTermsCode is not None:
            namespaceprefix_ = self.SaleTermsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.SaleTermsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSaleTermsCode>%s</%sSaleTermsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SaleTermsCode), input_name='SaleTermsCode')), namespaceprefix_ , eol_))
        if self.SaleTermsDescription is not None:
            namespaceprefix_ = self.SaleTermsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.SaleTermsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSaleTermsDescription>%s</%sSaleTermsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SaleTermsDescription), input_name='SaleTermsDescription')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SaleTermsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SaleTermsCode')
            value_ = self.gds_validate_string(value_, node, 'SaleTermsCode')
            self.SaleTermsCode = value_
            self.SaleTermsCode_nsprefix_ = child_.prefix
            # validate type SaleTermsCodeType
            self.validate_SaleTermsCodeType(self.SaleTermsCode)
        elif nodeName_ == 'SaleTermsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SaleTermsDescription')
            value_ = self.gds_validate_string(value_, node, 'SaleTermsDescription')
            self.SaleTermsDescription = value_
            self.SaleTermsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.SaleTermsDescription)
# end class InvoiceSaleTermsType


class MarkType(GeneratedsSuper):
    """MarkType -- О
    т
    м
    е
    т
    к
    и
    о
    п
    р
    о
    х
    о
    ж
    д
    е
    н
    и
    и
    т
    о
    в
    а
    р
    а
    м
    и
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    г
    о
    и
    и
    н
    ы
    х
    в
    и
    д
    о
    в
    г
    о
    с
    у
    д
    а
    р
    с
    т
    в
    е
    н
    н
    о
    г
    о
    к
    о
    н
    т
    р
    о
    л
    я
    .
    MarkSing -- П
    р
    и
    з
    н
    а
    к
    н
    а
    л
    и
    ч
    и
    я
    о
    т
    м
    е
    т
    к
    и
    MarkKind -- Т
    и
    п
    о
    т
    м
    е
    т
    к
    и
    ResultControl -- Р
    е
    з
    у
    л
    ь
    т
    а
    т
    п
    р
    о
    х
    о
    ж
    д
    е
    н
    и
    я
    к
    о
    н
    т
    р
    о
    л
    я
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MarkSing=None, MarkKind=None, ResultControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.MarkSing = MarkSing
        self.validate_IndicatorType(self.MarkSing)
        self.MarkSing_nsprefix_ = "clt_ru"
        self.MarkKind = MarkKind
        self.validate_FreeText250Type(self.MarkKind)
        self.MarkKind_nsprefix_ = "clt_ru"
        self.ResultControl = ResultControl
        self.validate_FreeText250Type(self.ResultControl)
        self.ResultControl_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarkType.subclass:
            return MarkType.subclass(*args_, **kwargs_)
        else:
            return MarkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MarkSing(self):
        return self.MarkSing
    def set_MarkSing(self, MarkSing):
        self.MarkSing = MarkSing
    def get_MarkKind(self):
        return self.MarkKind
    def set_MarkKind(self, MarkKind):
        self.MarkKind = MarkKind
    def get_ResultControl(self):
        return self.ResultControl
    def set_ResultControl(self, ResultControl):
        self.ResultControl = ResultControl
    def validate_IndicatorType(self, value):
        result = True
        # Validate type IndicatorType, a restriction on CategoryCust:IndicatorCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.MarkSing is not None or
            self.MarkKind is not None or
            self.ResultControl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='MarkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MarkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MarkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MarkType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MarkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='MarkType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='MarkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MarkSing is not None:
            namespaceprefix_ = self.MarkSing_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkSing_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMarkSing>%s</%sMarkSing>%s' % (namespaceprefix_ , self.gds_format_boolean(self.MarkSing, input_name='MarkSing'), namespaceprefix_ , eol_))
        if self.MarkKind is not None:
            namespaceprefix_ = self.MarkKind_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkKind_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMarkKind>%s</%sMarkKind>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MarkKind), input_name='MarkKind')), namespaceprefix_ , eol_))
        if self.ResultControl is not None:
            namespaceprefix_ = self.ResultControl_nsprefix_ + ':' if (UseCapturedNS_ and self.ResultControl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResultControl>%s</%sResultControl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ResultControl), input_name='ResultControl')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MarkSing':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'MarkSing')
            ival_ = self.gds_validate_boolean(ival_, node, 'MarkSing')
            self.MarkSing = ival_
            self.MarkSing_nsprefix_ = child_.prefix
            # validate type IndicatorType
            self.validate_IndicatorType(self.MarkSing)
        elif nodeName_ == 'MarkKind':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MarkKind')
            value_ = self.gds_validate_string(value_, node, 'MarkKind')
            self.MarkKind = value_
            self.MarkKind_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.MarkKind)
        elif nodeName_ == 'ResultControl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResultControl')
            value_ = self.gds_validate_string(value_, node, 'ResultControl')
            self.ResultControl = value_
            self.ResultControl_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.ResultControl)
# end class MarkType


class OtherChargesType(GeneratedsSuper):
    """OtherChargesType -- И
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    о
    п
    р
    о
    ч
    и
    х
    р
    а
    с
    х
    о
    д
    а
    х
    ChargeType -- Т
    и
    п
    р
    а
    с
    х
    о
    д
    а
    (
    н
    а
    п
    р
    и
    м
    е
    р
    ,
    у
    п
    а
    к
    о
    в
    к
    а
    ,
    п
    е
    р
    е
    г
    р
    у
    з
    к
    а
    в
    п
    о
    р
    т
    у
    и
    п
    р
    о
    ч
    е
    е
    ).
    ChargeAmount -- С
    у
    м
    м
    а
    р
    а
    с
    х
    о
    д
    а
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ChargeType=None, ChargeAmount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.ChargeType = ChargeType
        self.validate_FreeText250Type(self.ChargeType)
        self.ChargeType_nsprefix_ = "clt_ru"
        self.ChargeAmount = ChargeAmount
        self.validate_AmountType(self.ChargeAmount)
        self.ChargeAmount_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherChargesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherChargesType.subclass:
            return OtherChargesType.subclass(*args_, **kwargs_)
        else:
            return OtherChargesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ChargeType(self):
        return self.ChargeType
    def set_ChargeType(self, ChargeType):
        self.ChargeType = ChargeType
    def get_ChargeAmount(self):
        return self.ChargeAmount
    def set_ChargeAmount(self, ChargeAmount):
        self.ChargeAmount = ChargeAmount
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_AmountType(self, value):
        result = True
        # Validate type AmountType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on AmountType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.ChargeType is not None or
            self.ChargeAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='OtherChargesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtherChargesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OtherChargesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtherChargesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OtherChargesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='OtherChargesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='OtherChargesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChargeType is not None:
            namespaceprefix_ = self.ChargeType_nsprefix_ + ':' if (UseCapturedNS_ and self.ChargeType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChargeType>%s</%sChargeType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ChargeType), input_name='ChargeType')), namespaceprefix_ , eol_))
        if self.ChargeAmount is not None:
            namespaceprefix_ = self.ChargeAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.ChargeAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChargeAmount>%s</%sChargeAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.ChargeAmount, input_name='ChargeAmount'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ChargeType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ChargeType')
            value_ = self.gds_validate_string(value_, node, 'ChargeType')
            self.ChargeType = value_
            self.ChargeType_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.ChargeType)
        elif nodeName_ == 'ChargeAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'ChargeAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'ChargeAmount')
            self.ChargeAmount = fval_
            self.ChargeAmount_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.ChargeAmount)
# end class OtherChargesType


class PartPaymentType(GeneratedsSuper):
    """PartPaymentType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    ч
    а
    с
    т
    и
    ч
    н
    о
    м
    п
    л
    а
    т
    е
    ж
    е
    PartPaymentNum -- Н
    о
    м
    е
    р
    ч
    а
    с
    т
    и
    ч
    н
    о
    г
    о
    п
    л
    а
    т
    е
    ж
    а
    PartPaymentPP -- Н
    о
    м
    е
    р
    п
    л
    а
    т
    е
    ж
    н
    о
    г
    о
    о
    р
    д
    е
    р
    а
    PartPaymentPPDate -- Д
    а
    т
    а
    п
    л
    а
    т
    е
    ж
    н
    о
    г
    о
    о
    р
    д
    е
    р
    а
    PartPaymentSumm -- С
    у
    м
    м
    а
    ч
    а
    с
    т
    и
    ч
    н
    о
    г
    о
    п
    л
    а
    т
    е
    ж
    а
    Remainder -- С
    у
    м
    м
    а
    о
    с
    т
    а
    т
    к
    а
    п
    л
    а
    т
    е
    ж
    а
    PartPaymentSign -- П
    о
    д
    п
    и
    с
    ь
    д
    о
    л
    ж
    н
    о
    с
    т
    н
    о
    г
    о
    л
    и
    ц
    а
    ,
    п
    о
    с
    т
    а
    в
    и
    в
    ш
    е
    г
    о
    з
    а
    п
    и
    с
    ь
    о
    ч
    а
    с
    т
    и
    ч
    н
    о
    м
    п
    л
    а
    т
    е
    ж
    е
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PartPaymentNum=None, PartPaymentPP=None, PartPaymentPPDate=None, PartPaymentSumm=None, Remainder=None, PartPaymentSign=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.PartPaymentNum = PartPaymentNum
        self.validate_Count2Type(self.PartPaymentNum)
        self.PartPaymentNum_nsprefix_ = "clt_ru"
        self.PartPaymentPP = PartPaymentPP
        self.validate_DocumentNumberType(self.PartPaymentPP)
        self.PartPaymentPP_nsprefix_ = "clt_ru"
        if isinstance(PartPaymentPPDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PartPaymentPPDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PartPaymentPPDate
        self.PartPaymentPPDate = initvalue_
        self.PartPaymentPPDate_nsprefix_ = "clt_ru"
        self.PartPaymentSumm = PartPaymentSumm
        self.validate_AmountType(self.PartPaymentSumm)
        self.PartPaymentSumm_nsprefix_ = "clt_ru"
        self.Remainder = Remainder
        self.validate_AmountType(self.Remainder)
        self.Remainder_nsprefix_ = "clt_ru"
        self.PartPaymentSign = PartPaymentSign
        self.PartPaymentSign_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartPaymentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartPaymentType.subclass:
            return PartPaymentType.subclass(*args_, **kwargs_)
        else:
            return PartPaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PartPaymentNum(self):
        return self.PartPaymentNum
    def set_PartPaymentNum(self, PartPaymentNum):
        self.PartPaymentNum = PartPaymentNum
    def get_PartPaymentPP(self):
        return self.PartPaymentPP
    def set_PartPaymentPP(self, PartPaymentPP):
        self.PartPaymentPP = PartPaymentPP
    def get_PartPaymentPPDate(self):
        return self.PartPaymentPPDate
    def set_PartPaymentPPDate(self, PartPaymentPPDate):
        self.PartPaymentPPDate = PartPaymentPPDate
    def get_PartPaymentSumm(self):
        return self.PartPaymentSumm
    def set_PartPaymentSumm(self, PartPaymentSumm):
        self.PartPaymentSumm = PartPaymentSumm
    def get_Remainder(self):
        return self.Remainder
    def set_Remainder(self, Remainder):
        self.Remainder = Remainder
    def get_PartPaymentSign(self):
        return self.PartPaymentSign
    def set_PartPaymentSign(self, PartPaymentSign):
        self.PartPaymentSign = PartPaymentSign
    def validate_Count2Type(self, value):
        result = True
        # Validate type Count2Type, a restriction on CategoryCust:IntegerCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Count2Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Count2Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_DocumentNumberType(self, value):
        result = True
        # Validate type DocumentNumberType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DocumentNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DocumentNumberType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_AmountType(self, value):
        result = True
        # Validate type AmountType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on AmountType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.PartPaymentNum is not None or
            self.PartPaymentPP is not None or
            self.PartPaymentPPDate is not None or
            self.PartPaymentSumm is not None or
            self.Remainder is not None or
            self.PartPaymentSign is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='PartPaymentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartPaymentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PartPaymentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PartPaymentType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PartPaymentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='PartPaymentType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='PartPaymentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartPaymentNum is not None:
            namespaceprefix_ = self.PartPaymentNum_nsprefix_ + ':' if (UseCapturedNS_ and self.PartPaymentNum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartPaymentNum>%s</%sPartPaymentNum>%s' % (namespaceprefix_ , self.gds_format_integer(self.PartPaymentNum, input_name='PartPaymentNum'), namespaceprefix_ , eol_))
        if self.PartPaymentPP is not None:
            namespaceprefix_ = self.PartPaymentPP_nsprefix_ + ':' if (UseCapturedNS_ and self.PartPaymentPP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartPaymentPP>%s</%sPartPaymentPP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PartPaymentPP), input_name='PartPaymentPP')), namespaceprefix_ , eol_))
        if self.PartPaymentPPDate is not None:
            namespaceprefix_ = self.PartPaymentPPDate_nsprefix_ + ':' if (UseCapturedNS_ and self.PartPaymentPPDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartPaymentPPDate>%s</%sPartPaymentPPDate>%s' % (namespaceprefix_ , self.gds_format_date(self.PartPaymentPPDate, input_name='PartPaymentPPDate'), namespaceprefix_ , eol_))
        if self.PartPaymentSumm is not None:
            namespaceprefix_ = self.PartPaymentSumm_nsprefix_ + ':' if (UseCapturedNS_ and self.PartPaymentSumm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPartPaymentSumm>%s</%sPartPaymentSumm>%s' % (namespaceprefix_ , self.gds_format_decimal(self.PartPaymentSumm, input_name='PartPaymentSumm'), namespaceprefix_ , eol_))
        if self.Remainder is not None:
            namespaceprefix_ = self.Remainder_nsprefix_ + ':' if (UseCapturedNS_ and self.Remainder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRemainder>%s</%sRemainder>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Remainder, input_name='Remainder'), namespaceprefix_ , eol_))
        if self.PartPaymentSign is not None:
            namespaceprefix_ = self.PartPaymentSign_nsprefix_ + ':' if (UseCapturedNS_ and self.PartPaymentSign_nsprefix_) else ''
            self.PartPaymentSign.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PartPaymentSign', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PartPaymentNum' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PartPaymentNum')
            ival_ = self.gds_validate_integer(ival_, node, 'PartPaymentNum')
            self.PartPaymentNum = ival_
            self.PartPaymentNum_nsprefix_ = child_.prefix
            # validate type Count2Type
            self.validate_Count2Type(self.PartPaymentNum)
        elif nodeName_ == 'PartPaymentPP':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'PartPaymentPP')
            value_ = self.gds_validate_string(value_, node, 'PartPaymentPP')
            self.PartPaymentPP = value_
            self.PartPaymentPP_nsprefix_ = child_.prefix
            # validate type DocumentNumberType
            self.validate_DocumentNumberType(self.PartPaymentPP)
        elif nodeName_ == 'PartPaymentPPDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PartPaymentPPDate = dval_
            self.PartPaymentPPDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.PartPaymentPPDate)
        elif nodeName_ == 'PartPaymentSumm' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'PartPaymentSumm')
            fval_ = self.gds_validate_decimal(fval_, node, 'PartPaymentSumm')
            self.PartPaymentSumm = fval_
            self.PartPaymentSumm_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.PartPaymentSumm)
        elif nodeName_ == 'Remainder' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Remainder')
            fval_ = self.gds_validate_decimal(fval_, node, 'Remainder')
            self.Remainder = fval_
            self.Remainder_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.Remainder)
        elif nodeName_ == 'PartPaymentSign':
            class_obj_ = self.get_class_obj_(child_, PersonBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PartPaymentSign = obj_
            obj_.original_tagname_ = 'PartPaymentSign'
# end class PartPaymentType


class PayCustomerType(CustomerType):
    """PayCustomerType -- Р
    е
    к
    в
    и
    з
    и
    т
    ы
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    AddInformation -- Д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    а
    я
    и
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CustomerType
    def __init__(self, OrganizationName=None, INN=None, KPP=None, Bank=None, AddInformation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        super(globals().get("PayCustomerType"), self).__init__(OrganizationName, INN, KPP, Bank,  **kwargs_)
        self.AddInformation = AddInformation
        self.validate_FreeText250Type(self.AddInformation)
        self.AddInformation_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PayCustomerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PayCustomerType.subclass:
            return PayCustomerType.subclass(*args_, **kwargs_)
        else:
            return PayCustomerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AddInformation(self):
        return self.AddInformation
    def set_AddInformation(self, AddInformation):
        self.AddInformation = AddInformation
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.AddInformation is not None or
            super(PayCustomerType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='PayCustomerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PayCustomerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PayCustomerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PayCustomerType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PayCustomerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='PayCustomerType'):
        super(PayCustomerType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PayCustomerType')
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='PayCustomerType', fromsubclass_=False, pretty_print=True):
        super(PayCustomerType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddInformation is not None:
            namespaceprefix_ = self.AddInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.AddInformation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddInformation>%s</%sAddInformation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AddInformation), input_name='AddInformation')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PayCustomerType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AddInformation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AddInformation')
            value_ = self.gds_validate_string(value_, node, 'AddInformation')
            self.AddInformation = value_
            self.AddInformation_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.AddInformation)
        super(PayCustomerType, self)._buildChildren(child_, node, nodeName_, True)
# end class PayCustomerType


class PaymentRequisitionsType(GeneratedsSuper):
    """PaymentRequisitionsType -- П
    л
    а
    т
    е
    ж
    н
    ы
    е
    р
    е
    к
    в
    и
    з
    и
    т
    ы
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    OKPOID -- К
    о
    д
    б
    а
    н
    к
    а
    п
    о
    О
    К
    П
    О
    BankName -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    б
    а
    н
    к
    а
    BICID -- Б
    И
    К
    б
    а
    н
    к
    а
    SWIFTID -- SWIFT
    к
    о
    д
    б
    а
    н
    к
    а
    AccountNumeric -- Н
    о
    м
    е
    р
    к
    о
    р
    р
    е
    с
    п
    о
    н
    д
    е
    н
    т
    с
    к
    о
    г
    о
    с
    ч
    е
    т
    а
    б
    а
    н
    к
    а
    CurrentCurrencyAccount -- В
    а
    л
    ю
    т
    н
    ы
    й
    с
    ч
    е
    т
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    (
    т
    е
    к
    у
    щ
    и
    й
    )
    TransitCurrencyAccount -- В
    а
    л
    ю
    т
    н
    ы
    й
    с
    ч
    е
    т
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    (
    т
    р
    а
    н
    з
    и
    т
    н
    ы
    й
    )
    SpecialTransitCurrencyAccount -- В
    а
    л
    ю
    т
    н
    ы
    й
    с
    ч
    е
    т
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    (
    с
    п
    е
    ц
    и
    а
    л
    ь
    н
    ы
    й
    т
    р
    а
    н
    з
    и
    т
    н
    ы
    й
    )
    RoubleCurrencyAccount -- Р
    у
    б
    л
    е
    в
    ы
    й
    р
    а
    с
    ч
    е
    т
    н
    ы
    й
    с
    ч
    е
    т
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    BankPostalAddress -- О
    п
    и
    с
    а
    н
    и
    е
    а
    д
    р
    е
    с
    а
    б
    а
    н
    к
    а
    (
    а
    д
    р
    е
    с
    д
    о
    с
    т
    а
    в
    к
    и
    п
    о
    ч
    т
    о
    в
    о
    й
    к
    о
    р
    р
    е
    с
    п
    о
    н
    д
    е
    н
    ц
    и
    и
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, OKPOID=None, BankName=None, BICID=None, SWIFTID=None, AccountNumeric=None, CurrentCurrencyAccount=None, TransitCurrencyAccount=None, SpecialTransitCurrencyAccount=None, RoubleCurrencyAccount=None, BankPostalAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.OKPOID = OKPOID
        self.validate_OKPOIDType(self.OKPOID)
        self.OKPOID_nsprefix_ = "clt_ru"
        self.BankName = BankName
        self.validate_NameType(self.BankName)
        self.BankName_nsprefix_ = "clt_ru"
        self.BICID = BICID
        self.validate_BICIDType(self.BICID)
        self.BICID_nsprefix_ = "clt_ru"
        self.SWIFTID = SWIFTID
        self.validate_SWIFTIDType(self.SWIFTID)
        self.SWIFTID_nsprefix_ = "clt_ru"
        self.AccountNumeric = AccountNumeric
        self.validate_ForeignAccountType(self.AccountNumeric)
        self.AccountNumeric_nsprefix_ = "clt_ru"
        if CurrentCurrencyAccount is None:
            self.CurrentCurrencyAccount = []
        else:
            self.CurrentCurrencyAccount = CurrentCurrencyAccount
        self.CurrentCurrencyAccount_nsprefix_ = "clt_ru"
        if TransitCurrencyAccount is None:
            self.TransitCurrencyAccount = []
        else:
            self.TransitCurrencyAccount = TransitCurrencyAccount
        self.TransitCurrencyAccount_nsprefix_ = "clt_ru"
        if SpecialTransitCurrencyAccount is None:
            self.SpecialTransitCurrencyAccount = []
        else:
            self.SpecialTransitCurrencyAccount = SpecialTransitCurrencyAccount
        self.SpecialTransitCurrencyAccount_nsprefix_ = "clt_ru"
        self.RoubleCurrencyAccount = RoubleCurrencyAccount
        self.validate_AccountType(self.RoubleCurrencyAccount)
        self.RoubleCurrencyAccount_nsprefix_ = "clt_ru"
        self.BankPostalAddress = BankPostalAddress
        self.BankPostalAddress_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentRequisitionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentRequisitionsType.subclass:
            return PaymentRequisitionsType.subclass(*args_, **kwargs_)
        else:
            return PaymentRequisitionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OKPOID(self):
        return self.OKPOID
    def set_OKPOID(self, OKPOID):
        self.OKPOID = OKPOID
    def get_BankName(self):
        return self.BankName
    def set_BankName(self, BankName):
        self.BankName = BankName
    def get_BICID(self):
        return self.BICID
    def set_BICID(self, BICID):
        self.BICID = BICID
    def get_SWIFTID(self):
        return self.SWIFTID
    def set_SWIFTID(self, SWIFTID):
        self.SWIFTID = SWIFTID
    def get_AccountNumeric(self):
        return self.AccountNumeric
    def set_AccountNumeric(self, AccountNumeric):
        self.AccountNumeric = AccountNumeric
    def get_CurrentCurrencyAccount(self):
        return self.CurrentCurrencyAccount
    def set_CurrentCurrencyAccount(self, CurrentCurrencyAccount):
        self.CurrentCurrencyAccount = CurrentCurrencyAccount
    def add_CurrentCurrencyAccount(self, value):
        self.CurrentCurrencyAccount.append(value)
    def insert_CurrentCurrencyAccount_at(self, index, value):
        self.CurrentCurrencyAccount.insert(index, value)
    def replace_CurrentCurrencyAccount_at(self, index, value):
        self.CurrentCurrencyAccount[index] = value
    def get_TransitCurrencyAccount(self):
        return self.TransitCurrencyAccount
    def set_TransitCurrencyAccount(self, TransitCurrencyAccount):
        self.TransitCurrencyAccount = TransitCurrencyAccount
    def add_TransitCurrencyAccount(self, value):
        self.TransitCurrencyAccount.append(value)
    def insert_TransitCurrencyAccount_at(self, index, value):
        self.TransitCurrencyAccount.insert(index, value)
    def replace_TransitCurrencyAccount_at(self, index, value):
        self.TransitCurrencyAccount[index] = value
    def get_SpecialTransitCurrencyAccount(self):
        return self.SpecialTransitCurrencyAccount
    def set_SpecialTransitCurrencyAccount(self, SpecialTransitCurrencyAccount):
        self.SpecialTransitCurrencyAccount = SpecialTransitCurrencyAccount
    def add_SpecialTransitCurrencyAccount(self, value):
        self.SpecialTransitCurrencyAccount.append(value)
    def insert_SpecialTransitCurrencyAccount_at(self, index, value):
        self.SpecialTransitCurrencyAccount.insert(index, value)
    def replace_SpecialTransitCurrencyAccount_at(self, index, value):
        self.SpecialTransitCurrencyAccount[index] = value
    def get_RoubleCurrencyAccount(self):
        return self.RoubleCurrencyAccount
    def set_RoubleCurrencyAccount(self, RoubleCurrencyAccount):
        self.RoubleCurrencyAccount = RoubleCurrencyAccount
    def get_BankPostalAddress(self):
        return self.BankPostalAddress
    def set_BankPostalAddress(self, BankPostalAddress):
        self.BankPostalAddress = BankPostalAddress
    def validate_OKPOIDType(self, value):
        result = True
        # Validate type OKPOIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OKPOIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OKPOIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_BICIDType(self, value):
        result = True
        # Validate type BICIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_BICIDType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BICIDType_patterns_, ))
                result = False
        return result
    validate_BICIDType_patterns_ = [['^(\\d{9})$']]
    def validate_SWIFTIDType(self, value):
        result = True
        # Validate type SWIFTIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SWIFTIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SWIFTIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ForeignAccountType(self, value):
        result = True
        # Validate type ForeignAccountType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ForeignAccountType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ForeignAccountType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_AccountType(self, value):
        result = True
        # Validate type AccountType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_AccountType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_AccountType_patterns_, ))
                result = False
        return result
    validate_AccountType_patterns_ = [['^(\\d{20})$']]
    def has__content(self):
        if (
            self.OKPOID is not None or
            self.BankName is not None or
            self.BICID is not None or
            self.SWIFTID is not None or
            self.AccountNumeric is not None or
            self.CurrentCurrencyAccount or
            self.TransitCurrencyAccount or
            self.SpecialTransitCurrencyAccount or
            self.RoubleCurrencyAccount is not None or
            self.BankPostalAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='PaymentRequisitionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentRequisitionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PaymentRequisitionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaymentRequisitionsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaymentRequisitionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='PaymentRequisitionsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='PaymentRequisitionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OKPOID is not None:
            namespaceprefix_ = self.OKPOID_nsprefix_ + ':' if (UseCapturedNS_ and self.OKPOID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOKPOID>%s</%sOKPOID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OKPOID), input_name='OKPOID')), namespaceprefix_ , eol_))
        if self.BankName is not None:
            namespaceprefix_ = self.BankName_nsprefix_ + ':' if (UseCapturedNS_ and self.BankName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBankName>%s</%sBankName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BankName), input_name='BankName')), namespaceprefix_ , eol_))
        if self.BICID is not None:
            namespaceprefix_ = self.BICID_nsprefix_ + ':' if (UseCapturedNS_ and self.BICID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBICID>%s</%sBICID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BICID), input_name='BICID')), namespaceprefix_ , eol_))
        if self.SWIFTID is not None:
            namespaceprefix_ = self.SWIFTID_nsprefix_ + ':' if (UseCapturedNS_ and self.SWIFTID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSWIFTID>%s</%sSWIFTID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SWIFTID), input_name='SWIFTID')), namespaceprefix_ , eol_))
        if self.AccountNumeric is not None:
            namespaceprefix_ = self.AccountNumeric_nsprefix_ + ':' if (UseCapturedNS_ and self.AccountNumeric_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccountNumeric>%s</%sAccountNumeric>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumeric), input_name='AccountNumeric')), namespaceprefix_ , eol_))
        for CurrentCurrencyAccount_ in self.CurrentCurrencyAccount:
            namespaceprefix_ = self.CurrentCurrencyAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrentCurrencyAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrentCurrencyAccount>%s</%sCurrentCurrencyAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(CurrentCurrencyAccount_), input_name='CurrentCurrencyAccount')), namespaceprefix_ , eol_))
        for TransitCurrencyAccount_ in self.TransitCurrencyAccount:
            namespaceprefix_ = self.TransitCurrencyAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.TransitCurrencyAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransitCurrencyAccount>%s</%sTransitCurrencyAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(TransitCurrencyAccount_), input_name='TransitCurrencyAccount')), namespaceprefix_ , eol_))
        for SpecialTransitCurrencyAccount_ in self.SpecialTransitCurrencyAccount:
            namespaceprefix_ = self.SpecialTransitCurrencyAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.SpecialTransitCurrencyAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialTransitCurrencyAccount>%s</%sSpecialTransitCurrencyAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SpecialTransitCurrencyAccount_), input_name='SpecialTransitCurrencyAccount')), namespaceprefix_ , eol_))
        if self.RoubleCurrencyAccount is not None:
            namespaceprefix_ = self.RoubleCurrencyAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.RoubleCurrencyAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoubleCurrencyAccount>%s</%sRoubleCurrencyAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RoubleCurrencyAccount), input_name='RoubleCurrencyAccount')), namespaceprefix_ , eol_))
        if self.BankPostalAddress is not None:
            namespaceprefix_ = self.BankPostalAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.BankPostalAddress_nsprefix_) else ''
            self.BankPostalAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BankPostalAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OKPOID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OKPOID')
            value_ = self.gds_validate_string(value_, node, 'OKPOID')
            self.OKPOID = value_
            self.OKPOID_nsprefix_ = child_.prefix
            # validate type OKPOIDType
            self.validate_OKPOIDType(self.OKPOID)
        elif nodeName_ == 'BankName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BankName')
            value_ = self.gds_validate_string(value_, node, 'BankName')
            self.BankName = value_
            self.BankName_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.BankName)
        elif nodeName_ == 'BICID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'BICID')
            value_ = self.gds_validate_string(value_, node, 'BICID')
            self.BICID = value_
            self.BICID_nsprefix_ = child_.prefix
            # validate type BICIDType
            self.validate_BICIDType(self.BICID)
        elif nodeName_ == 'SWIFTID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SWIFTID')
            value_ = self.gds_validate_string(value_, node, 'SWIFTID')
            self.SWIFTID = value_
            self.SWIFTID_nsprefix_ = child_.prefix
            # validate type SWIFTIDType
            self.validate_SWIFTIDType(self.SWIFTID)
        elif nodeName_ == 'AccountNumeric':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'AccountNumeric')
            value_ = self.gds_validate_string(value_, node, 'AccountNumeric')
            self.AccountNumeric = value_
            self.AccountNumeric_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.AccountNumeric)
        elif nodeName_ == 'CurrentCurrencyAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CurrentCurrencyAccount')
            value_ = self.gds_validate_string(value_, node, 'CurrentCurrencyAccount')
            self.CurrentCurrencyAccount.append(value_)
            self.CurrentCurrencyAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.CurrentCurrencyAccount[-1])
        elif nodeName_ == 'TransitCurrencyAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TransitCurrencyAccount')
            value_ = self.gds_validate_string(value_, node, 'TransitCurrencyAccount')
            self.TransitCurrencyAccount.append(value_)
            self.TransitCurrencyAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.TransitCurrencyAccount[-1])
        elif nodeName_ == 'SpecialTransitCurrencyAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'SpecialTransitCurrencyAccount')
            value_ = self.gds_validate_string(value_, node, 'SpecialTransitCurrencyAccount')
            self.SpecialTransitCurrencyAccount.append(value_)
            self.SpecialTransitCurrencyAccount_nsprefix_ = child_.prefix
            # validate type ForeignAccountType
            self.validate_ForeignAccountType(self.SpecialTransitCurrencyAccount[-1])
        elif nodeName_ == 'RoubleCurrencyAccount':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'RoubleCurrencyAccount')
            value_ = self.gds_validate_string(value_, node, 'RoubleCurrencyAccount')
            self.RoubleCurrencyAccount = value_
            self.RoubleCurrencyAccount_nsprefix_ = child_.prefix
            # validate type AccountType
            self.validate_AccountType(self.RoubleCurrencyAccount)
        elif nodeName_ == 'BankPostalAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BankPostalAddress = obj_
            obj_.original_tagname_ = 'BankPostalAddress'
# end class PaymentRequisitionsType


class RussianInvoiceGoodsType(GeneratedsSuper):
    """RussianInvoiceGoodsType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    т
    о
    в
    а
    р
    а
    х
    с
    ч
    е
    т
    а
    -
    ф
    а
    к
    т
    у
    р
    ы
    GoodsDescription -- О
    п
    и
    с
    а
    н
    и
    е
    п
    о
    с
    т
    а
    в
    л
    я
    е
    м
    о
    г
    о
    т
    о
    в
    а
    р
    а
    (
    у
    с
    л
    у
    г
    и
    )
    GoodMarking -- А
    р
    т
    и
    к
    у
    л
    т
    о
    в
    а
    р
    а
    GoodsCode -- К
    о
    д
    т
    о
    в
    а
    р
    а
    п
    о
    Т
    Н
    В
    Э
    Д
    Е
    А
    Э
    С
    SupplementaryQualifierName -- Н
    а
    з
    в
    а
    н
    и
    е
    д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    о
    й
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    п
    р
    и
    в
    о
    з
    м
    о
    ж
    н
    о
    с
    т
    и
    е
    е
    у
    к
    а
    з
    а
    н
    и
    я
    GoodsQuantity -- К
    о
    л
    и
    ч
    е
    с
    т
    в
    о
    т
    о
    в
    а
    р
    а
    ,
    у
    с
    л
    у
    г
    и
    с
    х
    о
    д
    я
    и
    з
    п
    р
    и
    н
    я
    т
    ы
    х
    е
    д
    и
    н
    и
    ц
    и
    з
    м
    е
    р
    е
    н
    и
    я
    MeasureUnitQualifierName -- Н
    а
    з
    в
    а
    н
    и
    е
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    п
    р
    и
    в
    о
    з
    м
    о
    ж
    н
    о
    с
    т
    и
    е
    е
    у
    к
    а
    з
    а
    н
    и
    я
    GoodsPrice -- Ц
    е
    н
    а
    т
    о
    в
    а
    р
    а
    /
    у
    с
    л
    у
    г
    и
    GoodsCost -- С
    т
    о
    и
    м
    о
    с
    т
    ь
    в
    с
    е
    г
    о
    к
    о
    л
    и
    ч
    е
    с
    т
    в
    а
    п
    о
    с
    т
    а
    в
    л
    я
    е
    м
    о
    г
    о
    (
    о
    т
    г
    р
    у
    ж
    е
    н
    н
    о
    г
    о
    )
    п
    о
    с
    ч
    е
    т
    у
    -
    п
    р
    о
    ф
    о
    р
    м
    е
    т
    о
    в
    а
    р
    а
    (
    в
    ы
    п
    о
    л
    н
    е
    н
    н
    ы
    х
    р
    а
    б
    о
    т
    ,
    о
    к
    а
    з
    а
    н
    н
    ы
    х
    у
    с
    л
    у
    г
    )
    б
    е
    з
    н
    а
    л
    о
    г
    а
    Exise -- C
    у
    м
    м
    а
    а
    к
    ц
    и
    з
    а
    п
    о
    п
    о
    д
    а
    к
    ц
    и
    з
    н
    ы
    м
    т
    о
    в
    а
    р
    а
    м
    TaxRate -- Н
    а
    л
    о
    г
    о
    в
    а
    я
    с
    т
    а
    в
    к
    а
    TaxSum -- C
    у
    м
    м
    а
    н
    а
    л
    о
    г
    а
    ,
    п
    р
    е
    д
    ъ
    я
    в
    л
    я
    е
    м
    а
    я
    п
    о
    к
    у
    п
    а
    т
    е
    л
    ю
    т
    о
    в
    а
    р
    о
    в
    (
    р
    а
    б
    о
    т
    ,
    у
    с
    л
    у
    г
    ),
    о
    п
    р
    е
    д
    е
    л
    я
    е
    м
    а
    я
    и
    с
    х
    о
    д
    я
    и
    з
    п
    р
    и
    м
    е
    н
    я
    е
    м
    ы
    х
    н
    а
    л
    о
    г
    о
    в
    ы
    х
    с
    т
    а
    в
    о
    к
    TotalCost -- C
    т
    о
    и
    м
    о
    с
    т
    ь
    в
    с
    е
    г
    о
    к
    о
    л
    и
    ч
    е
    с
    т
    в
    а
    п
    о
    с
    т
    а
    в
    л
    я
    е
    м
    ы
    х
    (
    о
    т
    г
    р
    у
    ж
    е
    н
    н
    ы
    х
    )
    п
    о
    с
    ч
    е
    т
    у
    -
    п
    р
    о
    ф
    о
    р
    м
    е
    т
    о
    в
    а
    р
    о
    в
    (
    в
    ы
    п
    о
    л
    н
    е
    н
    н
    ы
    х
    р
    а
    б
    о
    т
    ,
    о
    к
    а
    з
    а
    н
    н
    ы
    х
    у
    с
    л
    у
    г
    )
    с
    у
    ч
    е
    т
    о
    м
    с
    у
    м
    м
    ы
    н
    а
    л
    о
    г
    а
    OriginCountryCode -- К
    о
    д
    с
    т
    р
    а
    н
    ы
    п
    р
    о
    и
    с
    х
    о
    ж
    д
    е
    н
    и
    я
    ,
    у
    к
    а
    з
    ы
    в
    а
    ю
    т
    с
    я
    в
    о
    т
    н
    о
    ш
    е
    н
    и
    и
    т
    о
    в
    а
    р
    о
    в
    ,
    с
    т
    р
    а
    н
    о
    й
    п
    р
    о
    и
    с
    х
    о
    ж
    д
    е
    н
    и
    я
    к
    о
    т
    о
    р
    ы
    х
    н
    е
    я
    в
    л
    я
    е
    т
    с
    я
    Р
    о
    с
    с
    и
    й
    с
    к
    а
    я
    Ф
    е
    д
    е
    р
    а
    ц
    и
    я
    .
    OriginA3CountryCode -- Б
    у
    к
    в
    е
    н
    н
    ы
    й
    к
    о
    д
    с
    т
    р
    а
    н
    ы
    п
    р
    о
    и
    с
    х
    о
    ж
    д
    е
    н
    и
    я
    ,
    у
    к
    а
    з
    ы
    в
    а
    ю
    т
    с
    я
    в
    о
    т
    н
    о
    ш
    е
    н
    и
    и
    т
    о
    в
    а
    р
    о
    в
    ,
    с
    т
    р
    а
    н
    о
    й
    п
    р
    о
    и
    с
    х
    о
    ж
    д
    е
    н
    и
    я
    к
    о
    т
    о
    р
    ы
    х
    н
    е
    я
    в
    л
    я
    е
    т
    с
    я
    Р
    о
    с
    с
    и
    й
    с
    к
    а
    я
    Ф
    е
    д
    е
    р
    а
    ц
    и
    я
    .
    GTDID -- Н
    о
    м
    е
    р
    Д
    Т
    AdditionalGoodsDescription -- Д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    ы
    е
    х
    а
    р
    а
    к
    т
    е
    р
    и
    с
    т
    и
    к
    и
    т
    о
    в
    а
    р
    о
    в
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GoodsDescription=None, GoodMarking=None, GoodsCode=None, SupplementaryQualifierName=None, GoodsQuantity=None, MeasureUnitQualifierName=None, GoodsPrice=None, GoodsCost=None, Exise=None, TaxRate=None, TaxSum=None, TotalCost=None, OriginCountryCode=None, OriginA3CountryCode=None, GTDID=None, AdditionalGoodsDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        if GoodsDescription is None:
            self.GoodsDescription = []
        else:
            self.GoodsDescription = GoodsDescription
        self.GoodsDescription_nsprefix_ = "clt_ru"
        self.GoodMarking = GoodMarking
        self.validate_GoodMarkingType(self.GoodMarking)
        self.GoodMarking_nsprefix_ = "clt_ru"
        self.GoodsCode = GoodsCode
        self.validate_GoodsNomenclatureCodeType(self.GoodsCode)
        self.GoodsCode_nsprefix_ = "clt_ru"
        self.SupplementaryQualifierName = SupplementaryQualifierName
        self.validate_MeasureUnitQualifierNameType(self.SupplementaryQualifierName)
        self.SupplementaryQualifierName_nsprefix_ = "clt_ru"
        self.GoodsQuantity = GoodsQuantity
        self.validate_QuantityBasisType(self.GoodsQuantity)
        self.GoodsQuantity_nsprefix_ = "clt_ru"
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
        self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        self.MeasureUnitQualifierName_nsprefix_ = "clt_ru"
        self.GoodsPrice = GoodsPrice
        self.validate_PriceType(self.GoodsPrice)
        self.GoodsPrice_nsprefix_ = "cltComFin_ru"
        self.GoodsCost = GoodsCost
        self.validate_AmountType(self.GoodsCost)
        self.GoodsCost_nsprefix_ = "clt_ru"
        self.Exise = Exise
        self.validate_AmountType(self.Exise)
        self.Exise_nsprefix_ = "clt_ru"
        self.TaxRate = TaxRate
        self.validate_ProcentNumericType(self.TaxRate)
        self.TaxRate_nsprefix_ = "clt_ru"
        self.TaxSum = TaxSum
        self.validate_AmountType(self.TaxSum)
        self.TaxSum_nsprefix_ = "clt_ru"
        self.TotalCost = TotalCost
        self.validate_AmountType(self.TotalCost)
        self.TotalCost_nsprefix_ = "clt_ru"
        self.OriginCountryCode = OriginCountryCode
        self.validate_CountryN3CodeType(self.OriginCountryCode)
        self.OriginCountryCode_nsprefix_ = "clt_ru"
        self.OriginA3CountryCode = OriginA3CountryCode
        self.validate_CountryA3CodeType(self.OriginA3CountryCode)
        self.OriginA3CountryCode_nsprefix_ = "clt_ru"
        self.GTDID = GTDID
        self.validate_GTDIDType(self.GTDID)
        self.GTDID_nsprefix_ = "cat_ru"
        self.AdditionalGoodsDescription = AdditionalGoodsDescription
        self.AdditionalGoodsDescription_nsprefix_ = "catComFin_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RussianInvoiceGoodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RussianInvoiceGoodsType.subclass:
            return RussianInvoiceGoodsType.subclass(*args_, **kwargs_)
        else:
            return RussianInvoiceGoodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GoodsDescription(self):
        return self.GoodsDescription
    def set_GoodsDescription(self, GoodsDescription):
        self.GoodsDescription = GoodsDescription
    def add_GoodsDescription(self, value):
        self.GoodsDescription.append(value)
    def insert_GoodsDescription_at(self, index, value):
        self.GoodsDescription.insert(index, value)
    def replace_GoodsDescription_at(self, index, value):
        self.GoodsDescription[index] = value
    def get_GoodMarking(self):
        return self.GoodMarking
    def set_GoodMarking(self, GoodMarking):
        self.GoodMarking = GoodMarking
    def get_GoodsCode(self):
        return self.GoodsCode
    def set_GoodsCode(self, GoodsCode):
        self.GoodsCode = GoodsCode
    def get_SupplementaryQualifierName(self):
        return self.SupplementaryQualifierName
    def set_SupplementaryQualifierName(self, SupplementaryQualifierName):
        self.SupplementaryQualifierName = SupplementaryQualifierName
    def get_GoodsQuantity(self):
        return self.GoodsQuantity
    def set_GoodsQuantity(self, GoodsQuantity):
        self.GoodsQuantity = GoodsQuantity
    def get_MeasureUnitQualifierName(self):
        return self.MeasureUnitQualifierName
    def set_MeasureUnitQualifierName(self, MeasureUnitQualifierName):
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
    def get_GoodsPrice(self):
        return self.GoodsPrice
    def set_GoodsPrice(self, GoodsPrice):
        self.GoodsPrice = GoodsPrice
    def get_GoodsCost(self):
        return self.GoodsCost
    def set_GoodsCost(self, GoodsCost):
        self.GoodsCost = GoodsCost
    def get_Exise(self):
        return self.Exise
    def set_Exise(self, Exise):
        self.Exise = Exise
    def get_TaxRate(self):
        return self.TaxRate
    def set_TaxRate(self, TaxRate):
        self.TaxRate = TaxRate
    def get_TaxSum(self):
        return self.TaxSum
    def set_TaxSum(self, TaxSum):
        self.TaxSum = TaxSum
    def get_TotalCost(self):
        return self.TotalCost
    def set_TotalCost(self, TotalCost):
        self.TotalCost = TotalCost
    def get_OriginCountryCode(self):
        return self.OriginCountryCode
    def set_OriginCountryCode(self, OriginCountryCode):
        self.OriginCountryCode = OriginCountryCode
    def get_OriginA3CountryCode(self):
        return self.OriginA3CountryCode
    def set_OriginA3CountryCode(self, OriginA3CountryCode):
        self.OriginA3CountryCode = OriginA3CountryCode
    def get_GTDID(self):
        return self.GTDID
    def set_GTDID(self, GTDID):
        self.GTDID = GTDID
    def get_AdditionalGoodsDescription(self):
        return self.AdditionalGoodsDescription
    def set_AdditionalGoodsDescription(self, AdditionalGoodsDescription):
        self.AdditionalGoodsDescription = AdditionalGoodsDescription
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_GoodMarkingType(self, value):
        result = True
        # Validate type GoodMarkingType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GoodMarkingType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on GoodMarkingType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_GoodsNomenclatureCodeType(self, value):
        result = True
        # Validate type GoodsNomenclatureCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_GoodsNomenclatureCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_GoodsNomenclatureCodeType_patterns_, ))
                result = False
        return result
    validate_GoodsNomenclatureCodeType_patterns_ = [['^(\\d{4,10})$']]
    def validate_MeasureUnitQualifierNameType(self, value):
        result = True
        # Validate type MeasureUnitQualifierNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MeasureUnitQualifierNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MeasureUnitQualifierNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_PriceType(self, value):
        result = True
        # Validate type PriceType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PriceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on PriceType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_AmountType(self, value):
        result = True
        # Validate type AmountType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on AmountType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ProcentNumericType(self, value):
        result = True
        # Validate type ProcentNumericType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_CountryN3CodeType(self, value):
        result = True
        # Validate type CountryN3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryN3CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryN3CodeType_patterns_, ))
                result = False
        return result
    validate_CountryN3CodeType_patterns_ = [['^(\\d{3})$']]
    def validate_CountryA3CodeType(self, value):
        result = True
        # Validate type CountryA3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryA3CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryA3CodeType_patterns_, ))
                result = False
        return result
    validate_CountryA3CodeType_patterns_ = [['^([A-Z]{3})$']]
    def validate_GTDIDType(self, value):
        result = True
        # Validate type GTDIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GTDIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on GTDIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.GoodsDescription or
            self.GoodMarking is not None or
            self.GoodsCode is not None or
            self.SupplementaryQualifierName is not None or
            self.GoodsQuantity is not None or
            self.MeasureUnitQualifierName is not None or
            self.GoodsPrice is not None or
            self.GoodsCost is not None or
            self.Exise is not None or
            self.TaxRate is not None or
            self.TaxSum is not None or
            self.TotalCost is not None or
            self.OriginCountryCode is not None or
            self.OriginA3CountryCode is not None or
            self.GTDID is not None or
            self.AdditionalGoodsDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='RussianInvoiceGoodsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RussianInvoiceGoodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RussianInvoiceGoodsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RussianInvoiceGoodsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RussianInvoiceGoodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='RussianInvoiceGoodsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='RussianInvoiceGoodsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GoodsDescription_ in self.GoodsDescription:
            namespaceprefix_ = self.GoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsDescription>%s</%sGoodsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(GoodsDescription_), input_name='GoodsDescription')), namespaceprefix_ , eol_))
        if self.GoodMarking is not None:
            namespaceprefix_ = self.GoodMarking_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodMarking_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodMarking>%s</%sGoodMarking>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodMarking), input_name='GoodMarking')), namespaceprefix_ , eol_))
        if self.GoodsCode is not None:
            namespaceprefix_ = self.GoodsCode_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsCode>%s</%sGoodsCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsCode), input_name='GoodsCode')), namespaceprefix_ , eol_))
        if self.SupplementaryQualifierName is not None:
            namespaceprefix_ = self.SupplementaryQualifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.SupplementaryQualifierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupplementaryQualifierName>%s</%sSupplementaryQualifierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SupplementaryQualifierName), input_name='SupplementaryQualifierName')), namespaceprefix_ , eol_))
        if self.GoodsQuantity is not None:
            namespaceprefix_ = self.GoodsQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsQuantity>%s</%sGoodsQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GoodsQuantity, input_name='GoodsQuantity'), namespaceprefix_ , eol_))
        if self.MeasureUnitQualifierName is not None:
            namespaceprefix_ = self.MeasureUnitQualifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureUnitQualifierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureUnitQualifierName>%s</%sMeasureUnitQualifierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasureUnitQualifierName), input_name='MeasureUnitQualifierName')), namespaceprefix_ , eol_))
        if self.GoodsPrice is not None:
            namespaceprefix_ = self.GoodsPrice_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsPrice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsPrice>%s</%sGoodsPrice>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GoodsPrice, input_name='GoodsPrice'), namespaceprefix_ , eol_))
        if self.GoodsCost is not None:
            namespaceprefix_ = self.GoodsCost_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsCost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsCost>%s</%sGoodsCost>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GoodsCost, input_name='GoodsCost'), namespaceprefix_ , eol_))
        if self.Exise is not None:
            namespaceprefix_ = self.Exise_nsprefix_ + ':' if (UseCapturedNS_ and self.Exise_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExise>%s</%sExise>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Exise, input_name='Exise'), namespaceprefix_ , eol_))
        if self.TaxRate is not None:
            namespaceprefix_ = self.TaxRate_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxRate>%s</%sTaxRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TaxRate, input_name='TaxRate'), namespaceprefix_ , eol_))
        if self.TaxSum is not None:
            namespaceprefix_ = self.TaxSum_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxSum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxSum>%s</%sTaxSum>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TaxSum, input_name='TaxSum'), namespaceprefix_ , eol_))
        if self.TotalCost is not None:
            namespaceprefix_ = self.TotalCost_nsprefix_ + ':' if (UseCapturedNS_ and self.TotalCost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTotalCost>%s</%sTotalCost>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TotalCost, input_name='TotalCost'), namespaceprefix_ , eol_))
        if self.OriginCountryCode is not None:
            namespaceprefix_ = self.OriginCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.OriginCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginCountryCode>%s</%sOriginCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OriginCountryCode), input_name='OriginCountryCode')), namespaceprefix_ , eol_))
        if self.OriginA3CountryCode is not None:
            namespaceprefix_ = self.OriginA3CountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.OriginA3CountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginA3CountryCode>%s</%sOriginA3CountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OriginA3CountryCode), input_name='OriginA3CountryCode')), namespaceprefix_ , eol_))
        if self.GTDID is not None:
            namespaceprefix_ = self.GTDID_nsprefix_ + ':' if (UseCapturedNS_ and self.GTDID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGTDID>%s</%sGTDID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GTDID), input_name='GTDID')), namespaceprefix_ , eol_))
        if self.AdditionalGoodsDescription is not None:
            namespaceprefix_ = self.AdditionalGoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.AdditionalGoodsDescription_nsprefix_) else ''
            self.AdditionalGoodsDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AdditionalGoodsDescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GoodsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsDescription')
            value_ = self.gds_validate_string(value_, node, 'GoodsDescription')
            self.GoodsDescription.append(value_)
            self.GoodsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.GoodsDescription[-1])
        elif nodeName_ == 'GoodMarking':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodMarking')
            value_ = self.gds_validate_string(value_, node, 'GoodMarking')
            self.GoodMarking = value_
            self.GoodMarking_nsprefix_ = child_.prefix
            # validate type GoodMarkingType
            self.validate_GoodMarkingType(self.GoodMarking)
        elif nodeName_ == 'GoodsCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'GoodsCode')
            value_ = self.gds_validate_string(value_, node, 'GoodsCode')
            self.GoodsCode = value_
            self.GoodsCode_nsprefix_ = child_.prefix
            # validate type GoodsNomenclatureCodeType
            self.validate_GoodsNomenclatureCodeType(self.GoodsCode)
        elif nodeName_ == 'SupplementaryQualifierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SupplementaryQualifierName')
            value_ = self.gds_validate_string(value_, node, 'SupplementaryQualifierName')
            self.SupplementaryQualifierName = value_
            self.SupplementaryQualifierName_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierNameType
            self.validate_MeasureUnitQualifierNameType(self.SupplementaryQualifierName)
        elif nodeName_ == 'GoodsQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GoodsQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GoodsQuantity')
            self.GoodsQuantity = fval_
            self.GoodsQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GoodsQuantity)
        elif nodeName_ == 'MeasureUnitQualifierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MeasureUnitQualifierName')
            value_ = self.gds_validate_string(value_, node, 'MeasureUnitQualifierName')
            self.MeasureUnitQualifierName = value_
            self.MeasureUnitQualifierName_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierNameType
            self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        elif nodeName_ == 'GoodsPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GoodsPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'GoodsPrice')
            self.GoodsPrice = fval_
            self.GoodsPrice_nsprefix_ = child_.prefix
            # validate type PriceType
            self.validate_PriceType(self.GoodsPrice)
        elif nodeName_ == 'GoodsCost' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GoodsCost')
            fval_ = self.gds_validate_decimal(fval_, node, 'GoodsCost')
            self.GoodsCost = fval_
            self.GoodsCost_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.GoodsCost)
        elif nodeName_ == 'Exise' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Exise')
            fval_ = self.gds_validate_decimal(fval_, node, 'Exise')
            self.Exise = fval_
            self.Exise_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.Exise)
        elif nodeName_ == 'TaxRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TaxRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'TaxRate')
            self.TaxRate = fval_
            self.TaxRate_nsprefix_ = child_.prefix
            # validate type ProcentNumericType
            self.validate_ProcentNumericType(self.TaxRate)
        elif nodeName_ == 'TaxSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TaxSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'TaxSum')
            self.TaxSum = fval_
            self.TaxSum_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.TaxSum)
        elif nodeName_ == 'TotalCost' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TotalCost')
            fval_ = self.gds_validate_decimal(fval_, node, 'TotalCost')
            self.TotalCost = fval_
            self.TotalCost_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.TotalCost)
        elif nodeName_ == 'OriginCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OriginCountryCode')
            value_ = self.gds_validate_string(value_, node, 'OriginCountryCode')
            self.OriginCountryCode = value_
            self.OriginCountryCode_nsprefix_ = child_.prefix
            # validate type CountryN3CodeType
            self.validate_CountryN3CodeType(self.OriginCountryCode)
        elif nodeName_ == 'OriginA3CountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'OriginA3CountryCode')
            value_ = self.gds_validate_string(value_, node, 'OriginA3CountryCode')
            self.OriginA3CountryCode = value_
            self.OriginA3CountryCode_nsprefix_ = child_.prefix
            # validate type CountryA3CodeType
            self.validate_CountryA3CodeType(self.OriginA3CountryCode)
        elif nodeName_ == 'GTDID':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'GTDID')
            value_ = self.gds_validate_string(value_, node, 'GTDID')
            self.GTDID = value_
            self.GTDID_nsprefix_ = child_.prefix
            # validate type GTDIDType
            self.validate_GTDIDType(self.GTDID)
        elif nodeName_ == 'AdditionalGoodsDescription':
            obj_ = AdditionalGoodsDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdditionalGoodsDescription = obj_
            obj_.original_tagname_ = 'AdditionalGoodsDescription'
# end class RussianInvoiceGoodsType


class ShortCompanyDescType(GeneratedsSuper):
    """ShortCompanyDescType -- Н
    а
    з
    в
    а
    н
    и
    е
    и
    а
    д
    р
    е
    с
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    Name -- Н
    а
    и
    м
    е
    н
    о
    в
    а
    н
    и
    е
    Address -- А
    д
    р
    е
    с
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Name=None, Address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.Name = Name
        self.validate_NameType(self.Name)
        self.Name_nsprefix_ = "clt_ru"
        self.Address = Address
        self.Address_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShortCompanyDescType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShortCompanyDescType.subclass:
            return ShortCompanyDescType.subclass(*args_, **kwargs_)
        else:
            return ShortCompanyDescType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def validate_NameType(self, value):
        result = True
        # Validate type NameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 150:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on NameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.Name is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='ShortCompanyDescType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShortCompanyDescType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShortCompanyDescType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShortCompanyDescType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShortCompanyDescType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ShortCompanyDescType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='ShortCompanyDescType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.Address is not None:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            self.Address.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type NameType
            self.validate_NameType(self.Name)
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class ShortCompanyDescType


class SpecificationGoodsType(GeneratedsSuper):
    """SpecificationGoodsType -- О
    п
    и
    с
    а
    н
    и
    е
    т
    о
    в
    а
    р
    о
    в
    и
    з
    с
    п
    е
    ц
    и
    ф
    и
    к
    а
    ц
    и
    и
    к
    к
    о
    н
    т
    р
    а
    к
    т
    у
    GoodMarking -- А
    р
    т
    и
    к
    у
    л
    т
    о
    в
    а
    р
    а
    GoodsDescription -- О
    п
    и
    с
    а
    н
    и
    е
    т
    о
    в
    а
    р
    а
    т
    е
    к
    с
    т
    о
    в
    о
    е
    GoodsQuantity -- К
    о
    л
    и
    ч
    е
    с
    т
    в
    о
    т
    о
    в
    а
    р
    а
    в
    е
    д
    и
    н
    и
    ц
    а
    х
    и
    з
    м
    е
    р
    е
    н
    и
    я
    MeasureUnitQualifierCode -- К
    о
    д
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    MeasureUnitQualifierName -- Н
    а
    з
    в
    а
    н
    и
    е
    е
    д
    и
    н
    и
    ц
    ы
    и
    з
    м
    е
    р
    е
    н
    и
    я
    Price -- Ц
    е
    н
    а
    т
    о
    в
    а
    р
    а
    GCost -- C
    т
    о
    и
    м
    о
    с
    т
    ь
    т
    о
    в
    а
    р
    а
    GoodsTNVEDCode -- К
    о
    д
    т
    о
    в
    а
    р
    а
    п
    о
    Т
    Н
    В
    Э
    Д
    Е
    А
    Э
    С
    CurrencyCode -- К
    о
    д
    в
    а
    л
    ю
    т
    ы
    к
    о
    н
    т
    р
    а
    к
    т
    а
    (
    ц
    е
    н
    ы
    )
    GoodsPlace -- О
    п
    и
    с
    а
    н
    и
    е
    г
    р
    у
    з
    о
    в
    ы
    х
    м
    е
    с
    т
    GoodsWeight -- В
    е
    с
    н
    е
    т
    т
    о
    ,
    б
    р
    у
    т
    т
    о
    т
    о
    в
    а
    р
    а
    в
    к
    г
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GoodMarking=None, GoodsDescription=None, GoodsQuantity=None, MeasureUnitQualifierCode=None, MeasureUnitQualifierName=None, Price=None, GCost=None, GoodsTNVEDCode=None, CurrencyCode=None, GoodsPlace=None, GoodsWeight=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.GoodMarking = GoodMarking
        self.validate_GoodMarkingType(self.GoodMarking)
        self.GoodMarking_nsprefix_ = "clt_ru"
        if GoodsDescription is None:
            self.GoodsDescription = []
        else:
            self.GoodsDescription = GoodsDescription
        self.GoodsDescription_nsprefix_ = "clt_ru"
        self.GoodsQuantity = GoodsQuantity
        self.validate_QuantityBasisType(self.GoodsQuantity)
        self.GoodsQuantity_nsprefix_ = "clt_ru"
        self.MeasureUnitQualifierCode = MeasureUnitQualifierCode
        self.validate_MeasureUnitQualifierCodeType(self.MeasureUnitQualifierCode)
        self.MeasureUnitQualifierCode_nsprefix_ = "clt_ru"
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
        self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        self.MeasureUnitQualifierName_nsprefix_ = "clt_ru"
        self.Price = Price
        self.validate_PriceType(self.Price)
        self.Price_nsprefix_ = "cltComFin_ru"
        self.GCost = GCost
        self.validate_PriceType(self.GCost)
        self.GCost_nsprefix_ = "cltComFin_ru"
        self.GoodsTNVEDCode = GoodsTNVEDCode
        self.validate_GoodsNomenclatureCodeType(self.GoodsTNVEDCode)
        self.GoodsTNVEDCode_nsprefix_ = "clt_ru"
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyA3CodeType(self.CurrencyCode)
        self.CurrencyCode_nsprefix_ = "clt_ru"
        self.GoodsPlace = GoodsPlace
        self.GoodsPlace_nsprefix_ = "catComFin_ru"
        self.GoodsWeight = GoodsWeight
        self.GoodsWeight_nsprefix_ = "catComFin_ru"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecificationGoodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecificationGoodsType.subclass:
            return SpecificationGoodsType.subclass(*args_, **kwargs_)
        else:
            return SpecificationGoodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GoodMarking(self):
        return self.GoodMarking
    def set_GoodMarking(self, GoodMarking):
        self.GoodMarking = GoodMarking
    def get_GoodsDescription(self):
        return self.GoodsDescription
    def set_GoodsDescription(self, GoodsDescription):
        self.GoodsDescription = GoodsDescription
    def add_GoodsDescription(self, value):
        self.GoodsDescription.append(value)
    def insert_GoodsDescription_at(self, index, value):
        self.GoodsDescription.insert(index, value)
    def replace_GoodsDescription_at(self, index, value):
        self.GoodsDescription[index] = value
    def get_GoodsQuantity(self):
        return self.GoodsQuantity
    def set_GoodsQuantity(self, GoodsQuantity):
        self.GoodsQuantity = GoodsQuantity
    def get_MeasureUnitQualifierCode(self):
        return self.MeasureUnitQualifierCode
    def set_MeasureUnitQualifierCode(self, MeasureUnitQualifierCode):
        self.MeasureUnitQualifierCode = MeasureUnitQualifierCode
    def get_MeasureUnitQualifierName(self):
        return self.MeasureUnitQualifierName
    def set_MeasureUnitQualifierName(self, MeasureUnitQualifierName):
        self.MeasureUnitQualifierName = MeasureUnitQualifierName
    def get_Price(self):
        return self.Price
    def set_Price(self, Price):
        self.Price = Price
    def get_GCost(self):
        return self.GCost
    def set_GCost(self, GCost):
        self.GCost = GCost
    def get_GoodsTNVEDCode(self):
        return self.GoodsTNVEDCode
    def set_GoodsTNVEDCode(self, GoodsTNVEDCode):
        self.GoodsTNVEDCode = GoodsTNVEDCode
    def get_CurrencyCode(self):
        return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode):
        self.CurrencyCode = CurrencyCode
    def get_GoodsPlace(self):
        return self.GoodsPlace
    def set_GoodsPlace(self, GoodsPlace):
        self.GoodsPlace = GoodsPlace
    def get_GoodsWeight(self):
        return self.GoodsWeight
    def set_GoodsWeight(self, GoodsWeight):
        self.GoodsWeight = GoodsWeight
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_GoodMarkingType(self, value):
        result = True
        # Validate type GoodMarkingType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GoodMarkingType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on GoodMarkingType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_MeasureUnitQualifierCodeType(self, value):
        result = True
        # Validate type MeasureUnitQualifierCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on MeasureUnitQualifierCodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_MeasureUnitQualifierNameType(self, value):
        result = True
        # Validate type MeasureUnitQualifierNameType, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MeasureUnitQualifierNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MeasureUnitQualifierNameType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_PriceType(self, value):
        result = True
        # Validate type PriceType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PriceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 25:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on PriceType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_GoodsNomenclatureCodeType(self, value):
        result = True
        # Validate type GoodsNomenclatureCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_GoodsNomenclatureCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_GoodsNomenclatureCodeType_patterns_, ))
                result = False
        return result
    validate_GoodsNomenclatureCodeType_patterns_ = [['^(\\d{4,10})$']]
    def validate_CurrencyA3CodeType(self, value):
        result = True
        # Validate type CurrencyA3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CurrencyA3CodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.GoodMarking is not None or
            self.GoodsDescription or
            self.GoodsQuantity is not None or
            self.MeasureUnitQualifierCode is not None or
            self.MeasureUnitQualifierName is not None or
            self.Price is not None or
            self.GCost is not None or
            self.GoodsTNVEDCode is not None or
            self.CurrencyCode is not None or
            self.GoodsPlace is not None or
            self.GoodsWeight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='SpecificationGoodsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpecificationGoodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpecificationGoodsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecificationGoodsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpecificationGoodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='SpecificationGoodsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cltComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0" ', name_='SpecificationGoodsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GoodMarking is not None:
            namespaceprefix_ = self.GoodMarking_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodMarking_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodMarking>%s</%sGoodMarking>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodMarking), input_name='GoodMarking')), namespaceprefix_ , eol_))
        for GoodsDescription_ in self.GoodsDescription:
            namespaceprefix_ = self.GoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsDescription>%s</%sGoodsDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(GoodsDescription_), input_name='GoodsDescription')), namespaceprefix_ , eol_))
        if self.GoodsQuantity is not None:
            namespaceprefix_ = self.GoodsQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsQuantity>%s</%sGoodsQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GoodsQuantity, input_name='GoodsQuantity'), namespaceprefix_ , eol_))
        if self.MeasureUnitQualifierCode is not None:
            namespaceprefix_ = self.MeasureUnitQualifierCode_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureUnitQualifierCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureUnitQualifierCode>%s</%sMeasureUnitQualifierCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasureUnitQualifierCode), input_name='MeasureUnitQualifierCode')), namespaceprefix_ , eol_))
        if self.MeasureUnitQualifierName is not None:
            namespaceprefix_ = self.MeasureUnitQualifierName_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureUnitQualifierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureUnitQualifierName>%s</%sMeasureUnitQualifierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasureUnitQualifierName), input_name='MeasureUnitQualifierName')), namespaceprefix_ , eol_))
        if self.Price is not None:
            namespaceprefix_ = self.Price_nsprefix_ + ':' if (UseCapturedNS_ and self.Price_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrice>%s</%sPrice>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Price, input_name='Price'), namespaceprefix_ , eol_))
        if self.GCost is not None:
            namespaceprefix_ = self.GCost_nsprefix_ + ':' if (UseCapturedNS_ and self.GCost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGCost>%s</%sGCost>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GCost, input_name='GCost'), namespaceprefix_ , eol_))
        if self.GoodsTNVEDCode is not None:
            namespaceprefix_ = self.GoodsTNVEDCode_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsTNVEDCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGoodsTNVEDCode>%s</%sGoodsTNVEDCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GoodsTNVEDCode), input_name='GoodsTNVEDCode')), namespaceprefix_ , eol_))
        if self.CurrencyCode is not None:
            namespaceprefix_ = self.CurrencyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrencyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), namespaceprefix_ , eol_))
        if self.GoodsPlace is not None:
            namespaceprefix_ = self.GoodsPlace_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsPlace_nsprefix_) else ''
            self.GoodsPlace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GoodsPlace', pretty_print=pretty_print)
        if self.GoodsWeight is not None:
            namespaceprefix_ = self.GoodsWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.GoodsWeight_nsprefix_) else ''
            self.GoodsWeight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GoodsWeight', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GoodMarking':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodMarking')
            value_ = self.gds_validate_string(value_, node, 'GoodMarking')
            self.GoodMarking = value_
            self.GoodMarking_nsprefix_ = child_.prefix
            # validate type GoodMarkingType
            self.validate_GoodMarkingType(self.GoodMarking)
        elif nodeName_ == 'GoodsDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GoodsDescription')
            value_ = self.gds_validate_string(value_, node, 'GoodsDescription')
            self.GoodsDescription.append(value_)
            self.GoodsDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.GoodsDescription[-1])
        elif nodeName_ == 'GoodsQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GoodsQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GoodsQuantity')
            self.GoodsQuantity = fval_
            self.GoodsQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GoodsQuantity)
        elif nodeName_ == 'MeasureUnitQualifierCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'MeasureUnitQualifierCode')
            value_ = self.gds_validate_string(value_, node, 'MeasureUnitQualifierCode')
            self.MeasureUnitQualifierCode = value_
            self.MeasureUnitQualifierCode_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierCodeType
            self.validate_MeasureUnitQualifierCodeType(self.MeasureUnitQualifierCode)
        elif nodeName_ == 'MeasureUnitQualifierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MeasureUnitQualifierName')
            value_ = self.gds_validate_string(value_, node, 'MeasureUnitQualifierName')
            self.MeasureUnitQualifierName = value_
            self.MeasureUnitQualifierName_nsprefix_ = child_.prefix
            # validate type MeasureUnitQualifierNameType
            self.validate_MeasureUnitQualifierNameType(self.MeasureUnitQualifierName)
        elif nodeName_ == 'Price' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Price')
            fval_ = self.gds_validate_decimal(fval_, node, 'Price')
            self.Price = fval_
            self.Price_nsprefix_ = child_.prefix
            # validate type PriceType
            self.validate_PriceType(self.Price)
        elif nodeName_ == 'GCost' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GCost')
            fval_ = self.gds_validate_decimal(fval_, node, 'GCost')
            self.GCost = fval_
            self.GCost_nsprefix_ = child_.prefix
            # validate type PriceType
            self.validate_PriceType(self.GCost)
        elif nodeName_ == 'GoodsTNVEDCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'GoodsTNVEDCode')
            value_ = self.gds_validate_string(value_, node, 'GoodsTNVEDCode')
            self.GoodsTNVEDCode = value_
            self.GoodsTNVEDCode_nsprefix_ = child_.prefix
            # validate type GoodsNomenclatureCodeType
            self.validate_GoodsNomenclatureCodeType(self.GoodsTNVEDCode)
        elif nodeName_ == 'CurrencyCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CurrencyCode')
            value_ = self.gds_validate_string(value_, node, 'CurrencyCode')
            self.CurrencyCode = value_
            self.CurrencyCode_nsprefix_ = child_.prefix
            # validate type CurrencyA3CodeType
            self.validate_CurrencyA3CodeType(self.CurrencyCode)
        elif nodeName_ == 'GoodsPlace':
            obj_ = GoodsPlaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GoodsPlace = obj_
            obj_.original_tagname_ = 'GoodsPlace'
        elif nodeName_ == 'GoodsWeight':
            obj_ = GoodsWeightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GoodsWeight = obj_
            obj_.original_tagname_ = 'GoodsWeight'
# end class SpecificationGoodsType


class TransportMeansType(GeneratedsSuper):
    """TransportMeansType -- О
    п
    и
    с
    а
    н
    и
    е
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    /
    к
    о
    н
    т
    е
    й
    н
    е
    р
    а
    д
    л
    я
    п
    е
    р
    е
    в
    о
    з
    к
    и
    т
    о
    в
    а
    р
    а
    Number -- Н
    о
    м
    е
    р
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    ModeCode -- К
    о
    д
    в
    и
    д
    а
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    NationalityCode -- К
    о
    д
    с
    т
    р
    а
    н
    ы
    п
    р
    и
    н
    а
    д
    л
    е
    ж
    н
    о
    с
    т
    и
    т
    р
    а
    н
    с
    п
    о
    р
    т
    а
    MoverIndicator -- П
    р
    и
    з
    н
    а
    к
    в
    е
    д
    у
    щ
    е
    г
    о
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Number=None, ModeCode=None, NationalityCode=None, MoverIndicator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        self.Number = Number
        self.validate_TransportMeansIDType(self.Number)
        self.Number_nsprefix_ = "clt_ru"
        self.ModeCode = ModeCode
        self.validate_TransportModeCodeType(self.ModeCode)
        self.ModeCode_nsprefix_ = "clt_ru"
        self.NationalityCode = NationalityCode
        self.validate_CountryN3CodeType(self.NationalityCode)
        self.NationalityCode_nsprefix_ = "clt_ru"
        self.MoverIndicator = MoverIndicator
        self.validate_IndicatorType(self.MoverIndicator)
        self.MoverIndicator_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportMeansType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportMeansType.subclass:
            return TransportMeansType.subclass(*args_, **kwargs_)
        else:
            return TransportMeansType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Number(self):
        return self.Number
    def set_Number(self, Number):
        self.Number = Number
    def get_ModeCode(self):
        return self.ModeCode
    def set_ModeCode(self, ModeCode):
        self.ModeCode = ModeCode
    def get_NationalityCode(self):
        return self.NationalityCode
    def set_NationalityCode(self, NationalityCode):
        self.NationalityCode = NationalityCode
    def get_MoverIndicator(self):
        return self.MoverIndicator
    def set_MoverIndicator(self, MoverIndicator):
        self.MoverIndicator = MoverIndicator
    def validate_TransportMeansIDType(self, value):
        result = True
        # Validate type TransportMeansIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TransportMeansIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TransportMeansIDType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TransportModeCodeType(self, value):
        result = True
        # Validate type TransportModeCodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TransportModeCodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_CountryN3CodeType(self, value):
        result = True
        # Validate type CountryN3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryN3CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryN3CodeType_patterns_, ))
                result = False
        return result
    validate_CountryN3CodeType_patterns_ = [['^(\\d{3})$']]
    def validate_IndicatorType(self, value):
        result = True
        # Validate type IndicatorType, a restriction on CategoryCust:IndicatorCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.Number is not None or
            self.ModeCode is not None or
            self.NationalityCode is not None or
            self.MoverIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportMeansType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransportMeansType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransportMeansType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransportMeansType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransportMeansType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='TransportMeansType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='TransportMeansType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Number is not None:
            namespaceprefix_ = self.Number_nsprefix_ + ':' if (UseCapturedNS_ and self.Number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumber>%s</%sNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')), namespaceprefix_ , eol_))
        if self.ModeCode is not None:
            namespaceprefix_ = self.ModeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ModeCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModeCode>%s</%sModeCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ModeCode), input_name='ModeCode')), namespaceprefix_ , eol_))
        if self.NationalityCode is not None:
            namespaceprefix_ = self.NationalityCode_nsprefix_ + ':' if (UseCapturedNS_ and self.NationalityCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNationalityCode>%s</%sNationalityCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NationalityCode), input_name='NationalityCode')), namespaceprefix_ , eol_))
        if self.MoverIndicator is not None:
            namespaceprefix_ = self.MoverIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.MoverIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMoverIndicator>%s</%sMoverIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.MoverIndicator, input_name='MoverIndicator'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Number':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'Number')
            value_ = self.gds_validate_string(value_, node, 'Number')
            self.Number = value_
            self.Number_nsprefix_ = child_.prefix
            # validate type TransportMeansIDType
            self.validate_TransportMeansIDType(self.Number)
        elif nodeName_ == 'ModeCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'ModeCode')
            value_ = self.gds_validate_string(value_, node, 'ModeCode')
            self.ModeCode = value_
            self.ModeCode_nsprefix_ = child_.prefix
            # validate type TransportModeCodeType
            self.validate_TransportModeCodeType(self.ModeCode)
        elif nodeName_ == 'NationalityCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'NationalityCode')
            value_ = self.gds_validate_string(value_, node, 'NationalityCode')
            self.NationalityCode = value_
            self.NationalityCode_nsprefix_ = child_.prefix
            # validate type CountryN3CodeType
            self.validate_CountryN3CodeType(self.NationalityCode)
        elif nodeName_ == 'MoverIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'MoverIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'MoverIndicator')
            self.MoverIndicator = ival_
            self.MoverIndicator_nsprefix_ = child_.prefix
            # validate type IndicatorType
            self.validate_IndicatorType(self.MoverIndicator)
# end class TransportMeansType


class SpecificationGoodsExtendedType(SpecificationGoodsType):
    """SpecificationGoodsExtendedType -- О
    п
    и
    с
    а
    н
    и
    е
    и
    д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    ы
    е
    х
    а
    р
    а
    к
    т
    е
    р
    и
    с
    т
    и
    к
    и
    т
    о
    в
    а
    р
    о
    в
    и
    з
    с
    п
    е
    ц
    и
    ф
    и
    к
    а
    ц
    и
    и
    к
    к
    о
    н
    т
    р
    а
    к
    т
    у
    AdditionalGoodsDescription -- Д
    о
    п
    о
    л
    н
    и
    т
    е
    л
    ь
    н
    ы
    е
    х
    а
    р
    а
    к
    т
    е
    р
    и
    с
    т
    и
    к
    и
    т
    о
    в
    а
    р
    о
    в
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SpecificationGoodsType
    def __init__(self, GoodMarking=None, GoodsDescription=None, GoodsQuantity=None, MeasureUnitQualifierCode=None, MeasureUnitQualifierName=None, Price=None, GCost=None, GoodsTNVEDCode=None, CurrencyCode=None, GoodsPlace=None, GoodsWeight=None, AdditionalGoodsDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        super(globals().get("SpecificationGoodsExtendedType"), self).__init__(GoodMarking, GoodsDescription, GoodsQuantity, MeasureUnitQualifierCode, MeasureUnitQualifierName, Price, GCost, GoodsTNVEDCode, CurrencyCode, GoodsPlace, GoodsWeight,  **kwargs_)
        self.AdditionalGoodsDescription = AdditionalGoodsDescription
        self.AdditionalGoodsDescription_nsprefix_ = "catComFin_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecificationGoodsExtendedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecificationGoodsExtendedType.subclass:
            return SpecificationGoodsExtendedType.subclass(*args_, **kwargs_)
        else:
            return SpecificationGoodsExtendedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AdditionalGoodsDescription(self):
        return self.AdditionalGoodsDescription
    def set_AdditionalGoodsDescription(self, AdditionalGoodsDescription):
        self.AdditionalGoodsDescription = AdditionalGoodsDescription
    def has__content(self):
        if (
            self.AdditionalGoodsDescription is not None or
            super(SpecificationGoodsExtendedType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0"', name_='SpecificationGoodsExtendedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpecificationGoodsExtendedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpecificationGoodsExtendedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecificationGoodsExtendedType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpecificationGoodsExtendedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='SpecificationGoodsExtendedType'):
        super(SpecificationGoodsExtendedType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecificationGoodsExtendedType')
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0"', name_='SpecificationGoodsExtendedType', fromsubclass_=False, pretty_print=True):
        super(SpecificationGoodsExtendedType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdditionalGoodsDescription is not None:
            namespaceprefix_ = self.AdditionalGoodsDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.AdditionalGoodsDescription_nsprefix_) else ''
            self.AdditionalGoodsDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AdditionalGoodsDescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SpecificationGoodsExtendedType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AdditionalGoodsDescription':
            obj_ = AdditionalGoodsDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdditionalGoodsDescription = obj_
            obj_.original_tagname_ = 'AdditionalGoodsDescription'
        super(SpecificationGoodsExtendedType, self)._buildChildren(child_, node, nodeName_, True)
# end class SpecificationGoodsExtendedType


class ContractDescriptionType(ImportContractTermsType):
    """ContractDescriptionType -- О
    п
    и
    с
    а
    н
    и
    е
    у
    с
    л
    о
    в
    и
    й
    к
    о
    н
    т
    р
    а
    к
    т
    а
    ExchangeClause -- С
    в
    е
    д
    е
    н
    и
    я
    о
    п
    р
    е
    д
    у
    с
    м
    о
    т
    р
    е
    н
    н
    о
    м
    у
    с
    л
    о
    в
    и
    я
    м
    и
    К
    о
    н
    т
    р
    а
    к
    т
    а
    п
    о
    р
    я
    д
    к
    е
    п
    е
    р
    е
    с
    ч
    е
    т
    а
    в
    а
    л
    ю
    т
    ы
    п
    л
    а
    т
    е
    ж
    а
    в
    в
    а
    л
    ю
    т
    у
    ц
    е
    н
    ы
      
    * ContractSubject -- П
      р
      е
      д
      м
      е
      т
      к
      о
      н
      т
      р
      а
      к
      т
      а
    * ContractTime -- С
      р
      о
      к
      д
      е
      й
      с
      т
      в
      и
      я
      к
      о
      н
      т
      р
      а
      к
      т
      а
      
    * AdditionalContractTime -- Д
      о
      п
      о
      л
      н
      и
      т
      е
      л
      ь
      н
      ы
      й
      с
      р
      о
      к
      д
      е
      й
      с
      т
      в
      и
      я
      к
      о
      н
      т
      р
      а
      к
      т
      а
      (
      п
      р
      и
      м
      е
      н
      я
      е
      т
      с
      я
      в
      с
      л
      у
      ч
      а
      е
      а
      в
      т
      о
      м
      а
      т
      и
      ч
      е
      с
      к
      о
      г
      о
      п
      р
      о
      л
      о
      н
      г
      и
      р
      о
      в
      а
      н
      и
      я
      )
    * OtherTerms -- П
      р
      о
      ч
      и
      е
      у
      с
      л
      о
      в
      и
      я
      с
      д
      е
      л
      к
      и
      .
    * ContractText -- Т
      е
      к
      с
      т
      к
      о
      н
      т
      р
      а
      к
      т
      а
    * DiscountPercentage -- Р
      а
      з
      м
      е
      р
      с
      к
      и
      д
      к
      и
      в
      п
      р
      о
      ц
      е
      н
      т
      а
      х
    * PaymentPeriod -- С
      р
      о
      к
      о
      п
      л
      а
      т
      ы
    * DealSign -- П
      р
      и
      з
      н
      а
      к
      с
      д
      е
      л
      к
      и
      к
      у
      п
      л
      и
      /
      п
      р
      о
      д
      а
      ж
      и
      (1 -
      к
      у
      п
      л
      я
      , 0 -
      п
      р
      о
      д
      а
      ж
      а
      )
    * PrepaySign -- П
      р
      и
      з
      н
      а
      к
      н
      а
      л
      и
      ч
      и
      я
      п
      р
      е
      д
      о
      п
      л
      а
      т
      ы
    * StockCategorySign -- П
      р
      и
      з
      н
      а
      к
      о
      т
      н
      е
      с
      е
      н
      и
      я
      т
      о
      в
      а
      р
      о
      в
      (
      п
      р
      е
      д
      м
      е
      т
      а
      к
      о
      н
      т
      р
      а
      к
      т
      а
      )
      к
      к
      а
      т
      е
      г
      о
      р
      и
      и
      б
      и
      р
      ж
      е
      в
      ы
      х
    * BuyerLimitationSign -- П
      р
      и
      з
      н
      а
      к
      н
      а
      л
      и
      ч
      и
      я
      о
      г
      р
      а
      н
      и
      ч
      е
      н
      и
      й
      в
      о
      т
      н
      о
      ш
      е
      н
      и
      и
      п
      р
      а
      в
      п
      о
      к
      у
      п
      а
      т
      е
      л
      я
    * InsuranceSign -- П
      р
      и
      з
      н
      а
      к
      н
      а
      л
      и
      ч
      и
      я
      с
      т
      р
      а
      х
      о
      в
      к
      и
      т
      о
      в
      а
      р
      о
      в
    * ChangeContract -- Н
      о
      м
      е
      р
      а
      и
      д
      а
      т
      ы
      и
      з
      м
      е
      н
      е
      н
      и
      й
      /
      д
      о
      п
      о
      л
      н
      е
      н
      и
      й
      к
      к
      о
      н
      т
      р
      а
      к
      т
      у
      .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ImportContractTermsType
    def __init__(self, Amount=None, Discount=None, CurrencyCode=None, PaymentModeCode=None, DueDateCode=None, LastDate=None, PaymentCurrencyCode=None, ExchangeClause=None, ContractSubject=None, ContractTime=None, AdditionalContractTime=None, OtherTerms=None, ContractText=None, DiscountPercentage=None, PaymentPeriod=None, DealSign=None, PrepaySign=None, StockCategorySign=None, BuyerLimitationSign=None, InsuranceSign=None, ChangeContract=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "catComFin_ru"
        super(globals().get("ContractDescriptionType"), self).__init__(Amount, Discount, CurrencyCode, PaymentModeCode, DueDateCode, LastDate, PaymentCurrencyCode,  **kwargs_)
        if ExchangeClause is None:
            self.ExchangeClause = []
        else:
            self.ExchangeClause = ExchangeClause
        self.ExchangeClause_nsprefix_ = "clt_ru"
        if ContractSubject is None:
            self.ContractSubject = []
        else:
            self.ContractSubject = ContractSubject
        self.ContractSubject_nsprefix_ = "clt_ru"
        if isinstance(ContractTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ContractTime, '%Y-%m-%d').date()
        else:
            initvalue_ = ContractTime
        self.ContractTime = initvalue_
        self.ContractTime_nsprefix_ = "clt_ru"
        if isinstance(AdditionalContractTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AdditionalContractTime, '%Y-%m-%d').date()
        else:
            initvalue_ = AdditionalContractTime
        self.AdditionalContractTime = initvalue_
        self.AdditionalContractTime_nsprefix_ = "clt_ru"
        if OtherTerms is None:
            self.OtherTerms = []
        else:
            self.OtherTerms = OtherTerms
        self.OtherTerms_nsprefix_ = "clt_ru"
        if ContractText is None:
            self.ContractText = []
        else:
            self.ContractText = ContractText
        self.ContractText_nsprefix_ = "clt_ru"
        self.DiscountPercentage = DiscountPercentage
        self.validate_ProcentNumericType(self.DiscountPercentage)
        self.DiscountPercentage_nsprefix_ = "clt_ru"
        self.PaymentPeriod = PaymentPeriod
        self.validate_Text50Type(self.PaymentPeriod)
        self.PaymentPeriod_nsprefix_ = "clt_ru"
        self.DealSign = DealSign
        self.validate_DigitalIndicatorType(self.DealSign)
        self.DealSign_nsprefix_ = "clt_ru"
        self.PrepaySign = PrepaySign
        self.validate_IndicatorType(self.PrepaySign)
        self.PrepaySign_nsprefix_ = "clt_ru"
        self.StockCategorySign = StockCategorySign
        self.validate_IndicatorType(self.StockCategorySign)
        self.StockCategorySign_nsprefix_ = "clt_ru"
        self.BuyerLimitationSign = BuyerLimitationSign
        self.validate_IndicatorType(self.BuyerLimitationSign)
        self.BuyerLimitationSign_nsprefix_ = "clt_ru"
        self.InsuranceSign = InsuranceSign
        self.validate_IndicatorType(self.InsuranceSign)
        self.InsuranceSign_nsprefix_ = "clt_ru"
        if ChangeContract is None:
            self.ChangeContract = []
        else:
            self.ChangeContract = ChangeContract
        self.ChangeContract_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractDescriptionType.subclass:
            return ContractDescriptionType.subclass(*args_, **kwargs_)
        else:
            return ContractDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ExchangeClause(self):
        return self.ExchangeClause
    def set_ExchangeClause(self, ExchangeClause):
        self.ExchangeClause = ExchangeClause
    def add_ExchangeClause(self, value):
        self.ExchangeClause.append(value)
    def insert_ExchangeClause_at(self, index, value):
        self.ExchangeClause.insert(index, value)
    def replace_ExchangeClause_at(self, index, value):
        self.ExchangeClause[index] = value
    def get_ContractSubject(self):
        return self.ContractSubject
    def set_ContractSubject(self, ContractSubject):
        self.ContractSubject = ContractSubject
    def add_ContractSubject(self, value):
        self.ContractSubject.append(value)
    def insert_ContractSubject_at(self, index, value):
        self.ContractSubject.insert(index, value)
    def replace_ContractSubject_at(self, index, value):
        self.ContractSubject[index] = value
    def get_ContractTime(self):
        return self.ContractTime
    def set_ContractTime(self, ContractTime):
        self.ContractTime = ContractTime
    def get_AdditionalContractTime(self):
        return self.AdditionalContractTime
    def set_AdditionalContractTime(self, AdditionalContractTime):
        self.AdditionalContractTime = AdditionalContractTime
    def get_OtherTerms(self):
        return self.OtherTerms
    def set_OtherTerms(self, OtherTerms):
        self.OtherTerms = OtherTerms
    def add_OtherTerms(self, value):
        self.OtherTerms.append(value)
    def insert_OtherTerms_at(self, index, value):
        self.OtherTerms.insert(index, value)
    def replace_OtherTerms_at(self, index, value):
        self.OtherTerms[index] = value
    def get_ContractText(self):
        return self.ContractText
    def set_ContractText(self, ContractText):
        self.ContractText = ContractText
    def add_ContractText(self, value):
        self.ContractText.append(value)
    def insert_ContractText_at(self, index, value):
        self.ContractText.insert(index, value)
    def replace_ContractText_at(self, index, value):
        self.ContractText[index] = value
    def get_DiscountPercentage(self):
        return self.DiscountPercentage
    def set_DiscountPercentage(self, DiscountPercentage):
        self.DiscountPercentage = DiscountPercentage
    def get_PaymentPeriod(self):
        return self.PaymentPeriod
    def set_PaymentPeriod(self, PaymentPeriod):
        self.PaymentPeriod = PaymentPeriod
    def get_DealSign(self):
        return self.DealSign
    def set_DealSign(self, DealSign):
        self.DealSign = DealSign
    def get_PrepaySign(self):
        return self.PrepaySign
    def set_PrepaySign(self, PrepaySign):
        self.PrepaySign = PrepaySign
    def get_StockCategorySign(self):
        return self.StockCategorySign
    def set_StockCategorySign(self, StockCategorySign):
        self.StockCategorySign = StockCategorySign
    def get_BuyerLimitationSign(self):
        return self.BuyerLimitationSign
    def set_BuyerLimitationSign(self, BuyerLimitationSign):
        self.BuyerLimitationSign = BuyerLimitationSign
    def get_InsuranceSign(self):
        return self.InsuranceSign
    def set_InsuranceSign(self, InsuranceSign):
        self.InsuranceSign = InsuranceSign
    def get_ChangeContract(self):
        return self.ChangeContract
    def set_ChangeContract(self, ChangeContract):
        self.ChangeContract = ChangeContract
    def add_ChangeContract(self, value):
        self.ChangeContract.append(value)
    def insert_ChangeContract_at(self, index, value):
        self.ChangeContract.insert(index, value)
    def replace_ChangeContract_at(self, index, value):
        self.ChangeContract[index] = value
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_ProcentNumericType(self, value):
        result = True
        # Validate type ProcentNumericType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DigitalIndicatorType(self, value):
        result = True
        # Validate type DigitalIndicatorType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on DigitalIndicatorType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_IndicatorType(self, value):
        result = True
        # Validate type IndicatorType, a restriction on CategoryCust:IndicatorCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.ExchangeClause or
            self.ContractSubject or
            self.ContractTime is not None or
            self.AdditionalContractTime is not None or
            self.OtherTerms or
            self.ContractText or
            self.DiscountPercentage is not None or
            self.PaymentPeriod is not None or
            self.DealSign is not None or
            self.PrepaySign is not None or
            self.StockCategorySign is not None or
            self.BuyerLimitationSign is not None or
            self.InsuranceSign is not None or
            self.ChangeContract or
            super(ContractDescriptionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='ContractDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContractDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContractDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractDescriptionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContractDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='catComFin_ru:', name_='ContractDescriptionType'):
        super(ContractDescriptionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractDescriptionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='catComFin_ru:', namespacedef_='xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='ContractDescriptionType', fromsubclass_=False, pretty_print=True):
        super(ContractDescriptionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExchangeClause_ in self.ExchangeClause:
            namespaceprefix_ = self.ExchangeClause_nsprefix_ + ':' if (UseCapturedNS_ and self.ExchangeClause_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExchangeClause>%s</%sExchangeClause>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ExchangeClause_), input_name='ExchangeClause')), namespaceprefix_ , eol_))
        for ContractSubject_ in self.ContractSubject:
            namespaceprefix_ = self.ContractSubject_nsprefix_ + ':' if (UseCapturedNS_ and self.ContractSubject_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContractSubject>%s</%sContractSubject>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ContractSubject_), input_name='ContractSubject')), namespaceprefix_ , eol_))
        if self.ContractTime is not None:
            namespaceprefix_ = self.ContractTime_nsprefix_ + ':' if (UseCapturedNS_ and self.ContractTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContractTime>%s</%sContractTime>%s' % (namespaceprefix_ , self.gds_format_date(self.ContractTime, input_name='ContractTime'), namespaceprefix_ , eol_))
        if self.AdditionalContractTime is not None:
            namespaceprefix_ = self.AdditionalContractTime_nsprefix_ + ':' if (UseCapturedNS_ and self.AdditionalContractTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdditionalContractTime>%s</%sAdditionalContractTime>%s' % (namespaceprefix_ , self.gds_format_date(self.AdditionalContractTime, input_name='AdditionalContractTime'), namespaceprefix_ , eol_))
        for OtherTerms_ in self.OtherTerms:
            namespaceprefix_ = self.OtherTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherTerms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherTerms>%s</%sOtherTerms>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(OtherTerms_), input_name='OtherTerms')), namespaceprefix_ , eol_))
        for ContractText_ in self.ContractText:
            namespaceprefix_ = self.ContractText_nsprefix_ + ':' if (UseCapturedNS_ and self.ContractText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContractText>%s</%sContractText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ContractText_), input_name='ContractText')), namespaceprefix_ , eol_))
        if self.DiscountPercentage is not None:
            namespaceprefix_ = self.DiscountPercentage_nsprefix_ + ':' if (UseCapturedNS_ and self.DiscountPercentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscountPercentage>%s</%sDiscountPercentage>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DiscountPercentage, input_name='DiscountPercentage'), namespaceprefix_ , eol_))
        if self.PaymentPeriod is not None:
            namespaceprefix_ = self.PaymentPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.PaymentPeriod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentPeriod>%s</%sPaymentPeriod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PaymentPeriod), input_name='PaymentPeriod')), namespaceprefix_ , eol_))
        if self.DealSign is not None:
            namespaceprefix_ = self.DealSign_nsprefix_ + ':' if (UseCapturedNS_ and self.DealSign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDealSign>%s</%sDealSign>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DealSign, input_name='DealSign'), namespaceprefix_ , eol_))
        if self.PrepaySign is not None:
            namespaceprefix_ = self.PrepaySign_nsprefix_ + ':' if (UseCapturedNS_ and self.PrepaySign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrepaySign>%s</%sPrepaySign>%s' % (namespaceprefix_ , self.gds_format_boolean(self.PrepaySign, input_name='PrepaySign'), namespaceprefix_ , eol_))
        if self.StockCategorySign is not None:
            namespaceprefix_ = self.StockCategorySign_nsprefix_ + ':' if (UseCapturedNS_ and self.StockCategorySign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStockCategorySign>%s</%sStockCategorySign>%s' % (namespaceprefix_ , self.gds_format_boolean(self.StockCategorySign, input_name='StockCategorySign'), namespaceprefix_ , eol_))
        if self.BuyerLimitationSign is not None:
            namespaceprefix_ = self.BuyerLimitationSign_nsprefix_ + ':' if (UseCapturedNS_ and self.BuyerLimitationSign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuyerLimitationSign>%s</%sBuyerLimitationSign>%s' % (namespaceprefix_ , self.gds_format_boolean(self.BuyerLimitationSign, input_name='BuyerLimitationSign'), namespaceprefix_ , eol_))
        if self.InsuranceSign is not None:
            namespaceprefix_ = self.InsuranceSign_nsprefix_ + ':' if (UseCapturedNS_ and self.InsuranceSign_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInsuranceSign>%s</%sInsuranceSign>%s' % (namespaceprefix_ , self.gds_format_boolean(self.InsuranceSign, input_name='InsuranceSign'), namespaceprefix_ , eol_))
        for ChangeContract_ in self.ChangeContract:
            namespaceprefix_ = self.ChangeContract_nsprefix_ + ':' if (UseCapturedNS_ and self.ChangeContract_nsprefix_) else ''
            ChangeContract_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChangeContract', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ContractDescriptionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ExchangeClause':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ExchangeClause')
            value_ = self.gds_validate_string(value_, node, 'ExchangeClause')
            self.ExchangeClause.append(value_)
            self.ExchangeClause_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.ExchangeClause[-1])
        elif nodeName_ == 'ContractSubject':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ContractSubject')
            value_ = self.gds_validate_string(value_, node, 'ContractSubject')
            self.ContractSubject.append(value_)
            self.ContractSubject_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.ContractSubject[-1])
        elif nodeName_ == 'ContractTime':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ContractTime = dval_
            self.ContractTime_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.ContractTime)
        elif nodeName_ == 'AdditionalContractTime':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AdditionalContractTime = dval_
            self.AdditionalContractTime_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.AdditionalContractTime)
        elif nodeName_ == 'OtherTerms':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OtherTerms')
            value_ = self.gds_validate_string(value_, node, 'OtherTerms')
            self.OtherTerms.append(value_)
            self.OtherTerms_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.OtherTerms[-1])
        elif nodeName_ == 'ContractText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ContractText')
            value_ = self.gds_validate_string(value_, node, 'ContractText')
            self.ContractText.append(value_)
            self.ContractText_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.ContractText[-1])
        elif nodeName_ == 'DiscountPercentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DiscountPercentage')
            fval_ = self.gds_validate_decimal(fval_, node, 'DiscountPercentage')
            self.DiscountPercentage = fval_
            self.DiscountPercentage_nsprefix_ = child_.prefix
            # validate type ProcentNumericType
            self.validate_ProcentNumericType(self.DiscountPercentage)
        elif nodeName_ == 'PaymentPeriod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PaymentPeriod')
            value_ = self.gds_validate_string(value_, node, 'PaymentPeriod')
            self.PaymentPeriod = value_
            self.PaymentPeriod_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.PaymentPeriod)
        elif nodeName_ == 'DealSign' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DealSign')
            fval_ = self.gds_validate_decimal(fval_, node, 'DealSign')
            self.DealSign = fval_
            self.DealSign_nsprefix_ = child_.prefix
            # validate type DigitalIndicatorType
            self.validate_DigitalIndicatorType(self.DealSign)
        elif nodeName_ == 'PrepaySign':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'PrepaySign')
            ival_ = self.gds_validate_boolean(ival_, node, 'PrepaySign')
            self.PrepaySign = ival_
            self.PrepaySign_nsprefix_ = child_.prefix
            # validate type IndicatorType
            self.validate_IndicatorType(self.PrepaySign)
        elif nodeName_ == 'StockCategorySign':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'StockCategorySign')
            ival_ = self.gds_validate_boolean(ival_, node, 'StockCategorySign')
            self.StockCategorySign = ival_
            self.StockCategorySign_nsprefix_ = child_.prefix
            # validate type IndicatorType
            self.validate_IndicatorType(self.StockCategorySign)
        elif nodeName_ == 'BuyerLimitationSign':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'BuyerLimitationSign')
            ival_ = self.gds_validate_boolean(ival_, node, 'BuyerLimitationSign')
            self.BuyerLimitationSign = ival_
            self.BuyerLimitationSign_nsprefix_ = child_.prefix
            # validate type IndicatorType
            self.validate_IndicatorType(self.BuyerLimitationSign)
        elif nodeName_ == 'InsuranceSign':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'InsuranceSign')
            ival_ = self.gds_validate_boolean(ival_, node, 'InsuranceSign')
            self.InsuranceSign = ival_
            self.InsuranceSign_nsprefix_ = child_.prefix
            # validate type IndicatorType
            self.validate_IndicatorType(self.InsuranceSign)
        elif nodeName_ == 'ChangeContract':
            class_obj_ = self.get_class_obj_(child_, DocumentBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChangeContract.append(obj_)
            obj_.original_tagname_ = 'ChangeContract'
        super(ContractDescriptionType, self)._buildChildren(child_, node, nodeName_, True)
# end class ContractDescriptionType


class OrganizationBackAddrType(OrganizationType):
    """OrganizationBackAddrType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    .
    Ю
    р
    и
    д
    и
    ч
    е
    с
    к
    и
    й
    и
    ф
    а
    к
    т
    и
    ч
    е
    с
    к
    и
    й
    а
    д
    р
    е
    с
    FactAddress -- Ф
    а
    к
    т
    и
    ч
    е
    с
    к
    и
    й
    а
    д
    р
    е
    с
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = OrganizationType
    def __init__(self, OrganizationName=None, ShortName=None, OrganizationLanguage=None, RFOrganizationFeatures=None, RKOrganizationFeatures=None, RBOrganizationFeatures=None, RAOrganizationFeatures=None, KGOrganizationFeatures=None, OKPOID=None, OKATOCode=None, Address=None, Contact=None, FactAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("OrganizationBackAddrType"), self).__init__(OrganizationName, ShortName, OrganizationLanguage, RFOrganizationFeatures, RKOrganizationFeatures, RBOrganizationFeatures, RAOrganizationFeatures, KGOrganizationFeatures, OKPOID, OKATOCode, Address, Contact,  **kwargs_)
        self.FactAddress = FactAddress
        self.FactAddress_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationBackAddrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationBackAddrType.subclass:
            return OrganizationBackAddrType.subclass(*args_, **kwargs_)
        else:
            return OrganizationBackAddrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FactAddress(self):
        return self.FactAddress
    def set_FactAddress(self, FactAddress):
        self.FactAddress = FactAddress
    def has__content(self):
        if (
            self.FactAddress is not None or
            super(OrganizationBackAddrType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"', name_='OrganizationBackAddrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationBackAddrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganizationBackAddrType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationBackAddrType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationBackAddrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='OrganizationBackAddrType'):
        super(OrganizationBackAddrType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationBackAddrType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"', name_='OrganizationBackAddrType', fromsubclass_=False, pretty_print=True):
        super(OrganizationBackAddrType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FactAddress is not None:
            namespaceprefix_ = self.FactAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.FactAddress_nsprefix_) else ''
            self.FactAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FactAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(OrganizationBackAddrType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FactAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FactAddress = obj_
            obj_.original_tagname_ = 'FactAddress'
        super(OrganizationBackAddrType, self)._buildChildren(child_, node, nodeName_, True)
# end class OrganizationBackAddrType


class DriverInformationType(PersonBaseType):
    """DriverInformationType -- И
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    о
    в
    о
    д
    и
    т
    е
    л
    я
    х
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    ы
    х
    с
    р
    е
    д
    с
    т
    в
    .
    З
    а
    п
    о
    л
    н
    я
    е
    т
    с
    я
    п
    р
    и
    т
    р
    а
    н
    з
    и
    т
    е
    т
    о
    в
    а
    р
    о
    в
    а
    в
    т
    о
    м
    о
    б
    и
    л
    ь
    н
    ы
    м
    т
    р
    а
    н
    с
    п
    о
    р
    т
    о
    м
    (
    и
    с
    п
    о
    л
    ь
    з
    у
    е
    т
    с
    я
    д
    о
    в
    е
    р
    с
    и
    и
    А
    Ф
    5.14.3)
    RegCountryCode -- К
    о
    д
    с
    т
    р
    а
    н
    ы
    р
    е
    г
    и
    с
    т
    р
    а
    ц
    и
    и
    в
    о
    д
    и
    т
    е
    л
    я
    т
    р
    а
    н
    с
    п
    о
    р
    т
    н
    о
    г
    о
    с
    р
    е
    д
    с
    т
    в
    а
    IdentityCard -- Д
    о
    к
    у
    м
    е
    н
    т
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    и
    й
    л
    и
    ч
    н
    о
    с
    т
    ь
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PersonBaseType
    def __init__(self, PersonSurname=None, PersonName=None, PersonMiddleName=None, PersonPost=None, RegCountryCode=None, IdentityCard=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("DriverInformationType"), self).__init__(PersonSurname, PersonName, PersonMiddleName, PersonPost,  **kwargs_)
        self.RegCountryCode = RegCountryCode
        self.validate_CountryA2CodeType(self.RegCountryCode)
        self.RegCountryCode_nsprefix_ = "clt_ru"
        self.IdentityCard = IdentityCard
        self.IdentityCard_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DriverInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DriverInformationType.subclass:
            return DriverInformationType.subclass(*args_, **kwargs_)
        else:
            return DriverInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RegCountryCode(self):
        return self.RegCountryCode
    def set_RegCountryCode(self, RegCountryCode):
        self.RegCountryCode = RegCountryCode
    def get_IdentityCard(self):
        return self.IdentityCard
    def set_IdentityCard(self, IdentityCard):
        self.IdentityCard = IdentityCard
    def validate_CountryA2CodeType(self, value):
        result = True
        # Validate type CountryA2CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryA2CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryA2CodeType_patterns_, ))
                result = False
        return result
    validate_CountryA2CodeType_patterns_ = [['^([A-Z]{2}|[0]{2}|[9]{2})$']]
    def has__content(self):
        if (
            self.RegCountryCode is not None or
            self.IdentityCard is not None or
            super(DriverInformationType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DriverInformationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DriverInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DriverInformationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DriverInformationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DriverInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='DriverInformationType'):
        super(DriverInformationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DriverInformationType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='DriverInformationType', fromsubclass_=False, pretty_print=True):
        super(DriverInformationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RegCountryCode is not None:
            namespaceprefix_ = self.RegCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.RegCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegCountryCode>%s</%sRegCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RegCountryCode), input_name='RegCountryCode')), namespaceprefix_ , eol_))
        if self.IdentityCard is not None:
            namespaceprefix_ = self.IdentityCard_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCard_nsprefix_) else ''
            self.IdentityCard.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IdentityCard', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DriverInformationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RegCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'RegCountryCode')
            value_ = self.gds_validate_string(value_, node, 'RegCountryCode')
            self.RegCountryCode = value_
            self.RegCountryCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.RegCountryCode)
        elif nodeName_ == 'IdentityCard':
            obj_ = IdentityCardType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IdentityCard = obj_
            obj_.original_tagname_ = 'IdentityCard'
        super(DriverInformationType, self)._buildChildren(child_, node, nodeName_, True)
# end class DriverInformationType


class CUOrganizationType(OrganizationBaseType):
    """CUOrganizationType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    (
    и
    с
    п
    о
    л
    ь
    з
    у
    е
    т
    с
    я
    д
    о
    в
    е
    р
    с
    и
    и
    А
    Ф
    5.14.3)
    Address -- А
    д
    р
    е
    с
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    IdentityCard -- Д
    о
    к
    у
    м
    е
    н
    т
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    и
    й
    л
    и
    ч
    н
    о
    с
    т
    ь
    Contact -- К
    о
    н
    т
    а
    к
    т
    н
    а
    я
    и
    н
    ф
    о
    р
    м
    а
    ц
    и
    я
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = OrganizationBaseType
    def __init__(self, OrganizationName=None, ShortName=None, OrganizationLanguage=None, RFOrganizationFeatures=None, RKOrganizationFeatures=None, RBOrganizationFeatures=None, RAOrganizationFeatures=None, KGOrganizationFeatures=None, Address=None, IdentityCard=None, Contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("CUOrganizationType"), self).__init__(OrganizationName, ShortName, OrganizationLanguage, RFOrganizationFeatures, RKOrganizationFeatures, RBOrganizationFeatures, RAOrganizationFeatures, KGOrganizationFeatures,  **kwargs_)
        self.Address = Address
        self.Address_nsprefix_ = "cat_ru"
        self.IdentityCard = IdentityCard
        self.IdentityCard_nsprefix_ = "cat_ru"
        self.Contact = Contact
        self.Contact_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUOrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUOrganizationType.subclass:
            return CUOrganizationType.subclass(*args_, **kwargs_)
        else:
            return CUOrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def get_IdentityCard(self):
        return self.IdentityCard
    def set_IdentityCard(self, IdentityCard):
        self.IdentityCard = IdentityCard
    def get_Contact(self):
        return self.Contact
    def set_Contact(self, Contact):
        self.Contact = Contact
    def has__content(self):
        if (
            self.Address is not None or
            self.IdentityCard is not None or
            self.Contact is not None or
            super(CUOrganizationType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"', name_='CUOrganizationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CUOrganizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CUOrganizationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUOrganizationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CUOrganizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CUOrganizationType'):
        super(CUOrganizationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUOrganizationType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"', name_='CUOrganizationType', fromsubclass_=False, pretty_print=True):
        super(CUOrganizationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            self.Address.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        if self.IdentityCard is not None:
            namespaceprefix_ = self.IdentityCard_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentityCard_nsprefix_) else ''
            self.IdentityCard.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IdentityCard', pretty_print=pretty_print)
        if self.Contact is not None:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            self.Contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CUOrganizationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Address':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'IdentityCard':
            obj_ = IdentityCardType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IdentityCard = obj_
            obj_.original_tagname_ = 'IdentityCard'
        elif nodeName_ == 'Contact':
            obj_ = ContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
        super(CUOrganizationType, self)._buildChildren(child_, node, nodeName_, True)
# end class CUOrganizationType


class CUCustomsType(CustomsType):
    """CUCustomsType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    т
    а
    м
    о
    ж
    е
    н
    н
    о
    м
    о
    р
    г
    а
    н
    е
    CustomsCountryCode -- К
    о
    д
    г
    о
    с
    у
    д
    а
    р
    с
    т
    в
    а
    -
    ч
    л
    е
    н
    а
    Е
    в
    р
    а
    з
    и
    й
    с
    к
    о
    г
    о
    э
    к
    о
    н
    о
    м
    и
    ч
    е
    с
    к
    о
    г
    о
    с
    о
    ю
    з
    а
    .
    Т
    р
    е
    х
    з
    н
    а
    ч
    н
    ы
    й
    ц
    и
    ф
    р
    о
    в
    о
    й
    к
    о
    д
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CustomsType
    def __init__(self, Code=None, OfficeName=None, CustomsCountryCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("CUCustomsType"), self).__init__(Code, OfficeName,  **kwargs_)
        self.CustomsCountryCode = CustomsCountryCode
        self.validate_CountryN3CodeType(self.CustomsCountryCode)
        self.CustomsCountryCode_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUCustomsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUCustomsType.subclass:
            return CUCustomsType.subclass(*args_, **kwargs_)
        else:
            return CUCustomsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomsCountryCode(self):
        return self.CustomsCountryCode
    def set_CustomsCountryCode(self, CustomsCountryCode):
        self.CustomsCountryCode = CustomsCountryCode
    def validate_CountryN3CodeType(self, value):
        result = True
        # Validate type CountryN3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryN3CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryN3CodeType_patterns_, ))
                result = False
        return result
    validate_CountryN3CodeType_patterns_ = [['^(\\d{3})$']]
    def has__content(self):
        if (
            self.CustomsCountryCode is not None or
            super(CUCustomsType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CUCustomsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CUCustomsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CUCustomsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUCustomsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CUCustomsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='CUCustomsType'):
        super(CUCustomsType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUCustomsType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='CUCustomsType', fromsubclass_=False, pretty_print=True):
        super(CUCustomsType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomsCountryCode is not None:
            namespaceprefix_ = self.CustomsCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomsCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomsCountryCode>%s</%sCustomsCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CustomsCountryCode), input_name='CustomsCountryCode')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CUCustomsType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomsCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CustomsCountryCode')
            value_ = self.gds_validate_string(value_, node, 'CustomsCountryCode')
            self.CustomsCountryCode = value_
            self.CustomsCountryCode_nsprefix_ = child_.prefix
            # validate type CountryN3CodeType
            self.validate_CountryN3CodeType(self.CustomsCountryCode)
        super(CUCustomsType, self)._buildChildren(child_, node, nodeName_, True)
# end class CUCustomsType


class AuthoritesDocumentType(DocumentBaseType):
    """AuthoritesDocumentType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    д
    о
    к
    у
    м
    е
    н
    т
    е
    ,
    у
    д
    о
    с
    т
    о
    в
    е
    р
    я
    ю
    щ
    е
    м
    п
    о
    л
    н
    о
    м
    о
    ч
    и
    я
    ComplationAuthorityDate -- Д
    а
    т
    а
    о
    к
    о
    н
    ч
    а
    н
    и
    я
    п
    о
    л
    н
    о
    м
    о
    ч
    и
    й
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DocumentBaseType
    def __init__(self, PrDocumentName=None, PrDocumentNumber=None, PrDocumentDate=None, ComplationAuthorityDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat_ru"
        super(globals().get("AuthoritesDocumentType"), self).__init__(PrDocumentName, PrDocumentNumber, PrDocumentDate,  **kwargs_)
        if isinstance(ComplationAuthorityDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ComplationAuthorityDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ComplationAuthorityDate
        self.ComplationAuthorityDate = initvalue_
        self.ComplationAuthorityDate_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthoritesDocumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthoritesDocumentType.subclass:
            return AuthoritesDocumentType.subclass(*args_, **kwargs_)
        else:
            return AuthoritesDocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ComplationAuthorityDate(self):
        return self.ComplationAuthorityDate
    def set_ComplationAuthorityDate(self, ComplationAuthorityDate):
        self.ComplationAuthorityDate = ComplationAuthorityDate
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.ComplationAuthorityDate is not None or
            super(AuthoritesDocumentType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AuthoritesDocumentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AuthoritesDocumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AuthoritesDocumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AuthoritesDocumentType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AuthoritesDocumentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cat_ru:', name_='AuthoritesDocumentType'):
        super(AuthoritesDocumentType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AuthoritesDocumentType')
    def _exportChildren(self, outfile, level, namespaceprefix_='cat_ru:', namespacedef_='xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='AuthoritesDocumentType', fromsubclass_=False, pretty_print=True):
        super(AuthoritesDocumentType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComplationAuthorityDate is not None:
            namespaceprefix_ = self.ComplationAuthorityDate_nsprefix_ + ':' if (UseCapturedNS_ and self.ComplationAuthorityDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplationAuthorityDate>%s</%sComplationAuthorityDate>%s' % (namespaceprefix_ , self.gds_format_date(self.ComplationAuthorityDate, input_name='ComplationAuthorityDate'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AuthoritesDocumentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ComplationAuthorityDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ComplationAuthorityDate = dval_
            self.ComplationAuthorityDate_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.ComplationAuthorityDate)
        super(AuthoritesDocumentType, self)._buildChildren(child_, node, nodeName_, True)
# end class AuthoritesDocumentType


class InvoiceParticipantInfType(InvoiceParticipantType):
    """InvoiceParticipantInfType -- С
    в
    е
    д
    е
    н
    и
    я
    о
    б
    у
    ч
    а
    с
    т
    н
    и
    к
    а
    х
    с
    д
    е
    л
    к
    и
    п
    о
    к
    у
    п
    л
    и
    -
    п
    р
    о
    д
    а
    ж
    и
    (
    п
    р
    о
    д
    а
    в
    е
    ц
    и
    л
    и
    п
    о
    к
    у
    п
    а
    т
    е
    л
    ь
    )
    PaymentRequisitions -- П
    л
    а
    т
    е
    ж
    н
    ы
    е
    р
    е
    к
    в
    и
    з
    и
    т
    ы
    о
    р
    г
    а
    н
    и
    з
    а
    ц
    и
    и
    PostalAddress -- О
    п
    и
    с
    а
    н
    и
    е
    а
    д
    р
    е
    с
    а
    у
    ч
    а
    с
    т
    н
    и
    к
    а
    (
    а
    д
    р
    е
    с
    д
    о
    с
    т
    а
    в
    к
    и
    п
    о
    ч
    т
    о
    в
    о
    й
    к
    о
    р
    р
    е
    с
    п
    о
    н
    д
    е
    н
    ц
    и
    и
    )
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InvoiceParticipantType
    def __init__(self, CompanyID=None, KPPCode=None, Name=None, Phone=None, PaymentRequisitions=None, PostalAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inv"
        super(globals().get("InvoiceParticipantInfType"), self).__init__(CompanyID, KPPCode, Name, Phone,  **kwargs_)
        if PaymentRequisitions is None:
            self.PaymentRequisitions = []
        else:
            self.PaymentRequisitions = PaymentRequisitions
        self.PaymentRequisitions_nsprefix_ = "catComFin_ru"
        self.PostalAddress = PostalAddress
        self.PostalAddress_nsprefix_ = "cat_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceParticipantInfType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceParticipantInfType.subclass:
            return InvoiceParticipantInfType.subclass(*args_, **kwargs_)
        else:
            return InvoiceParticipantInfType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PaymentRequisitions(self):
        return self.PaymentRequisitions
    def set_PaymentRequisitions(self, PaymentRequisitions):
        self.PaymentRequisitions = PaymentRequisitions
    def add_PaymentRequisitions(self, value):
        self.PaymentRequisitions.append(value)
    def insert_PaymentRequisitions_at(self, index, value):
        self.PaymentRequisitions.insert(index, value)
    def replace_PaymentRequisitions_at(self, index, value):
        self.PaymentRequisitions[index] = value
    def get_PostalAddress(self):
        return self.PostalAddress
    def set_PostalAddress(self, PostalAddress):
        self.PostalAddress = PostalAddress
    def has__content(self):
        if (
            self.PaymentRequisitions or
            self.PostalAddress is not None or
            super(InvoiceParticipantInfType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0" xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='InvoiceParticipantInfType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceParticipantInfType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceParticipantInfType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceParticipantInfType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceParticipantInfType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceParticipantInfType'):
        super(InvoiceParticipantInfType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceParticipantInfType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0" xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0" ', name_='InvoiceParticipantInfType', fromsubclass_=False, pretty_print=True):
        super(InvoiceParticipantInfType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PaymentRequisitions_ in self.PaymentRequisitions:
            namespaceprefix_ = self.PaymentRequisitions_nsprefix_ + ':' if (UseCapturedNS_ and self.PaymentRequisitions_nsprefix_) else ''
            PaymentRequisitions_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PaymentRequisitions', pretty_print=pretty_print)
        if self.PostalAddress is not None:
            namespaceprefix_ = self.PostalAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.PostalAddress_nsprefix_) else ''
            self.PostalAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PostalAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InvoiceParticipantInfType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PaymentRequisitions':
            obj_ = PaymentRequisitionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PaymentRequisitions.append(obj_)
            obj_.original_tagname_ = 'PaymentRequisitions'
        elif nodeName_ == 'PostalAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PostalAddress = obj_
            obj_.original_tagname_ = 'PostalAddress'
        super(InvoiceParticipantInfType, self)._buildChildren(child_, node, nodeName_, True)
# end class InvoiceParticipantInfType


class InvoiceDeliveryTermsType(ContractDeliveryTermsType):
    """InvoiceDeliveryTermsType -- О
    п
    и
    с
    а
    н
    и
    е
    у
    с
    л
    о
    в
    и
    й
    п
    о
    с
    т
    а
    в
    к
    и
    в
    и
    н
    в
    о
    й
    с
    е
    DispatchCountryCode -- К
    о
    д
    с
    т
    р
    а
    н
    ы
    о
    т
    п
    р
    а
    в
    л
    е
    н
    и
    я
      
    * TradingCountryCode -- К
      о
      д
      т
      о
      р
      г
      у
      ю
      щ
      е
      й
      с
      т
      р
      а
      н
      ы
    * DestinationCountryCode -- К
      о
      д
      с
      т
      р
      а
      н
      ы
      н
      а
      з
      н
      а
      ч
      е
      н
      и
      я
    * Deadline -- С
      р
      о
      к
      д
      о
      с
      т
      а
      в
      к
      и
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ContractDeliveryTermsType
    def __init__(self, DeliveryPlace=None, DeliveryTermsNumericCode=None, DeliveryTermsStringCode=None, TermsDescription=None, InvoiceSaleTerms=None, DispatchCountryCode=None, TradingCountryCode=None, DestinationCountryCode=None, Deadline=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inv"
        super(globals().get("InvoiceDeliveryTermsType"), self).__init__(DeliveryPlace, DeliveryTermsNumericCode, DeliveryTermsStringCode, TermsDescription, InvoiceSaleTerms,  **kwargs_)
        self.DispatchCountryCode = DispatchCountryCode
        self.validate_CountryA2CodeType(self.DispatchCountryCode)
        self.DispatchCountryCode_nsprefix_ = "clt_ru"
        self.TradingCountryCode = TradingCountryCode
        self.validate_CountryA2CodeType(self.TradingCountryCode)
        self.TradingCountryCode_nsprefix_ = "clt_ru"
        self.DestinationCountryCode = DestinationCountryCode
        self.validate_CountryA2CodeType(self.DestinationCountryCode)
        self.DestinationCountryCode_nsprefix_ = "clt_ru"
        if isinstance(Deadline, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Deadline, '%Y-%m-%d').date()
        else:
            initvalue_ = Deadline
        self.Deadline = initvalue_
        self.Deadline_nsprefix_ = "clt_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceDeliveryTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceDeliveryTermsType.subclass:
            return InvoiceDeliveryTermsType.subclass(*args_, **kwargs_)
        else:
            return InvoiceDeliveryTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DispatchCountryCode(self):
        return self.DispatchCountryCode
    def set_DispatchCountryCode(self, DispatchCountryCode):
        self.DispatchCountryCode = DispatchCountryCode
    def get_TradingCountryCode(self):
        return self.TradingCountryCode
    def set_TradingCountryCode(self, TradingCountryCode):
        self.TradingCountryCode = TradingCountryCode
    def get_DestinationCountryCode(self):
        return self.DestinationCountryCode
    def set_DestinationCountryCode(self, DestinationCountryCode):
        self.DestinationCountryCode = DestinationCountryCode
    def get_Deadline(self):
        return self.Deadline
    def set_Deadline(self, Deadline):
        self.Deadline = Deadline
    def validate_CountryA2CodeType(self, value):
        result = True
        # Validate type CountryA2CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryA2CodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryA2CodeType_patterns_, ))
                result = False
        return result
    validate_CountryA2CodeType_patterns_ = [['^([A-Z]{2}|[0]{2}|[9]{2})$']]
    def validate_DateCustType(self, value):
        result = True
        # Validate type DateCustType, a restriction on CategoryCust:DateCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.DispatchCountryCode is not None or
            self.TradingCountryCode is not None or
            self.DestinationCountryCode is not None or
            self.Deadline is not None or
            super(InvoiceDeliveryTermsType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='InvoiceDeliveryTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceDeliveryTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceDeliveryTermsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDeliveryTermsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceDeliveryTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceDeliveryTermsType'):
        super(InvoiceDeliveryTermsType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDeliveryTermsType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0" ', name_='InvoiceDeliveryTermsType', fromsubclass_=False, pretty_print=True):
        super(InvoiceDeliveryTermsType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DispatchCountryCode is not None:
            namespaceprefix_ = self.DispatchCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DispatchCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDispatchCountryCode>%s</%sDispatchCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DispatchCountryCode), input_name='DispatchCountryCode')), namespaceprefix_ , eol_))
        if self.TradingCountryCode is not None:
            namespaceprefix_ = self.TradingCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.TradingCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTradingCountryCode>%s</%sTradingCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TradingCountryCode), input_name='TradingCountryCode')), namespaceprefix_ , eol_))
        if self.DestinationCountryCode is not None:
            namespaceprefix_ = self.DestinationCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DestinationCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationCountryCode>%s</%sDestinationCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DestinationCountryCode), input_name='DestinationCountryCode')), namespaceprefix_ , eol_))
        if self.Deadline is not None:
            namespaceprefix_ = self.Deadline_nsprefix_ + ':' if (UseCapturedNS_ and self.Deadline_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeadline>%s</%sDeadline>%s' % (namespaceprefix_ , self.gds_format_date(self.Deadline, input_name='Deadline'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InvoiceDeliveryTermsType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DispatchCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DispatchCountryCode')
            value_ = self.gds_validate_string(value_, node, 'DispatchCountryCode')
            self.DispatchCountryCode = value_
            self.DispatchCountryCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.DispatchCountryCode)
        elif nodeName_ == 'TradingCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TradingCountryCode')
            value_ = self.gds_validate_string(value_, node, 'TradingCountryCode')
            self.TradingCountryCode = value_
            self.TradingCountryCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.TradingCountryCode)
        elif nodeName_ == 'DestinationCountryCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'DestinationCountryCode')
            value_ = self.gds_validate_string(value_, node, 'DestinationCountryCode')
            self.DestinationCountryCode = value_
            self.DestinationCountryCode_nsprefix_ = child_.prefix
            # validate type CountryA2CodeType
            self.validate_CountryA2CodeType(self.DestinationCountryCode)
        elif nodeName_ == 'Deadline':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Deadline = dval_
            self.Deadline_nsprefix_ = child_.prefix
            # validate type DateCustType
            self.validate_DateCustType(self.Deadline)
        super(InvoiceDeliveryTermsType, self)._buildChildren(child_, node, nodeName_, True)
# end class InvoiceDeliveryTermsType


class InvoiceType(BaseDocType):
    """InvoiceType --Инвойс
      
    * DocumentModeID -- Идентификатор вида документа.
    * CurrencyRate -- Установленный курс иностранной валюты инвойса на дату инвойса. 
                    Указывается, если инвойс в иностранной валюте, курс  которой не равен курсы ЦБ.
    * CurrencyCode -- Код иностранной валюты инвойса. 
    * PlacesQuantity -- Общее количество грузовых мест товара
    * PlacesDescription -- Описание вида грузовых мест (коробок, упаковок, паллет и т.д.)
    * GrossWeightQuantity -- Общий вес брутто товаров (если в описании товаров нет данных, то значение вводится вручную - иначе - сумма веса брутто по товарам)
    * NetWeightQuantity -- Общий вес нетто товаров (если в описании товаров нет данных, то значение вводится вручную - иначе - сумма веса нетто по товарам)
    * GCost -- Общая стоимость товаров по инвойсу
    * Discount -- Общая сумма скидки по инвойсу
    * DiscountPercentage -- Общая сумма скидки по инвойсу, %
    * TransportCharges -- Общая сумма транспортных расходов по инвойсу
    * InsuranceCharges -- Общая сумма расходов по страхованию по инвойсу
    * OtherCharges -- Сумма прочих расходов по инвойсу
    * TotalCost -- Общая стоимость по инвойсу с учетом расходов и скидки
    * PaymentPeriod -- Срок оплаты
    * Buyer -- Сведения о покупателе
    * Seler -- Сведения о продавце
    * Consignor -- Грузоотправитель и его адрес
    * Consignee -- Грузополучатель
    * InvoiceGoods -- Сведения о товарах инвойса
    * DeliveryTerms -- Описание условий поставки
    * TransportMeans -- Описание транспортного средства для перевозки товаров
    * Registration -- Регистрационные данные инвойса
    * Contract --Дата и номер контракта
    * Enclosure -- Дата и номер дополнений, изменений, приложений, спецификаций
    * Mark -- Отметки о прохождении товарами таможенного и иных видов государственного контроля.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDocType
    def __init__(self, DocumentID=None, RefDocumentID=None, INNSign=None, MCD_ID=None, DocumentModeID='1002007E', CurrencyRate=None, CurrencyCode=None, PlacesQuantity=None, PlacesDescription=None, GrossWeightQuantity=None, NetWeightQuantity=None, GCost=None, Discount=None, DiscountPercentage=None, TransportCharges=None, InsuranceCharges=None, OtherCharges=None, TotalCost=None, PaymentPeriod=None, Buyer=None, Seler=None, Consignor=None, Consignee=None, InvoiceGoods=None, DeliveryTerms=None, TransportMeans=None, Registration=None, Contract=None, Enclosure=None, Mark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inv"
        super(globals().get("InvoiceType"), self).__init__(DocumentID, RefDocumentID, INNSign, MCD_ID,  **kwargs_)
        self.DocumentModeID = _cast(None, DocumentModeID)
        self.DocumentModeID_nsprefix_ = None
        self.CurrencyRate = CurrencyRate
        self.validate_CurrencyRateType(self.CurrencyRate)
        self.CurrencyRate_nsprefix_ = "clt_ru"
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyA3CodeType(self.CurrencyCode)
        self.CurrencyCode_nsprefix_ = "clt_ru"
        self.PlacesQuantity = PlacesQuantity
        self.validate_Count8Type(self.PlacesQuantity)
        self.PlacesQuantity_nsprefix_ = "clt_ru"
        self.PlacesDescription = PlacesDescription
        self.validate_FreeText250Type(self.PlacesDescription)
        self.PlacesDescription_nsprefix_ = "clt_ru"
        self.GrossWeightQuantity = GrossWeightQuantity
        self.validate_QuantityBasisType(self.GrossWeightQuantity)
        self.GrossWeightQuantity_nsprefix_ = "clt_ru"
        self.NetWeightQuantity = NetWeightQuantity
        self.validate_QuantityBasisType(self.NetWeightQuantity)
        self.NetWeightQuantity_nsprefix_ = "clt_ru"
        self.GCost = GCost
        self.validate_AmountType(self.GCost)
        self.GCost_nsprefix_ = "clt_ru"
        self.Discount = Discount
        self.validate_AmountType(self.Discount)
        self.Discount_nsprefix_ = "clt_ru"
        self.DiscountPercentage = DiscountPercentage
        self.validate_ProcentNumericType(self.DiscountPercentage)
        self.DiscountPercentage_nsprefix_ = "clt_ru"
        self.TransportCharges = TransportCharges
        self.validate_AmountType(self.TransportCharges)
        self.TransportCharges_nsprefix_ = "clt_ru"
        self.InsuranceCharges = InsuranceCharges
        self.validate_AmountType(self.InsuranceCharges)
        self.InsuranceCharges_nsprefix_ = "clt_ru"
        self.OtherCharges = OtherCharges
        self.validate_AmountType(self.OtherCharges)
        self.OtherCharges_nsprefix_ = "clt_ru"
        self.TotalCost = TotalCost
        self.validate_AmountType(self.TotalCost)
        self.TotalCost_nsprefix_ = "clt_ru"
        self.PaymentPeriod = PaymentPeriod
        self.validate_Text50Type(self.PaymentPeriod)
        self.PaymentPeriod_nsprefix_ = "clt_ru"
        self.Buyer = Buyer
        self.Buyer_nsprefix_ = "inv"
        self.Seler = Seler
        self.Seler_nsprefix_ = "inv"
        self.Consignor = Consignor
        self.Consignor_nsprefix_ = "cat_ru"
        self.Consignee = Consignee
        self.Consignee_nsprefix_ = "cat_ru"
        if InvoiceGoods is None:
            self.InvoiceGoods = []
        else:
            self.InvoiceGoods = InvoiceGoods
        self.InvoiceGoods_nsprefix_ = "catComFin_ru"
        self.DeliveryTerms = DeliveryTerms
        self.DeliveryTerms_nsprefix_ = "inv"
        if TransportMeans is None:
            self.TransportMeans = []
        else:
            self.TransportMeans = TransportMeans
        self.TransportMeans_nsprefix_ = "catComFin_ru"
        self.Registration = Registration
        self.Registration_nsprefix_ = "cat_ru"
        self.Contract = Contract
        self.Contract_nsprefix_ = "cat_ru"
        if Enclosure is None:
            self.Enclosure = []
        else:
            self.Enclosure = Enclosure
        self.Enclosure_nsprefix_ = "cat_ru"
        self.Mark = Mark
        self.Mark_nsprefix_ = "catComFin_ru"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceType.subclass:
            return InvoiceType.subclass(*args_, **kwargs_)
        else:
            return InvoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CurrencyRate(self):
        return self.CurrencyRate
    def set_CurrencyRate(self, CurrencyRate):
        self.CurrencyRate = CurrencyRate
    def get_CurrencyCode(self):
        return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode):
        self.CurrencyCode = CurrencyCode
    def get_PlacesQuantity(self):
        return self.PlacesQuantity
    def set_PlacesQuantity(self, PlacesQuantity):
        self.PlacesQuantity = PlacesQuantity
    def get_PlacesDescription(self):
        return self.PlacesDescription
    def set_PlacesDescription(self, PlacesDescription):
        self.PlacesDescription = PlacesDescription
    def get_GrossWeightQuantity(self):
        return self.GrossWeightQuantity
    def set_GrossWeightQuantity(self, GrossWeightQuantity):
        self.GrossWeightQuantity = GrossWeightQuantity
    def get_NetWeightQuantity(self):
        return self.NetWeightQuantity
    def set_NetWeightQuantity(self, NetWeightQuantity):
        self.NetWeightQuantity = NetWeightQuantity
    def get_GCost(self):
        return self.GCost
    def set_GCost(self, GCost):
        self.GCost = GCost
    def get_Discount(self):
        return self.Discount
    def set_Discount(self, Discount):
        self.Discount = Discount
    def get_DiscountPercentage(self):
        return self.DiscountPercentage
    def set_DiscountPercentage(self, DiscountPercentage):
        self.DiscountPercentage = DiscountPercentage
    def get_TransportCharges(self):
        return self.TransportCharges
    def set_TransportCharges(self, TransportCharges):
        self.TransportCharges = TransportCharges
    def get_InsuranceCharges(self):
        return self.InsuranceCharges
    def set_InsuranceCharges(self, InsuranceCharges):
        self.InsuranceCharges = InsuranceCharges
    def get_OtherCharges(self):
        return self.OtherCharges
    def set_OtherCharges(self, OtherCharges):
        self.OtherCharges = OtherCharges
    def get_TotalCost(self):
        return self.TotalCost
    def set_TotalCost(self, TotalCost):
        self.TotalCost = TotalCost
    def get_PaymentPeriod(self):
        return self.PaymentPeriod
    def set_PaymentPeriod(self, PaymentPeriod):
        self.PaymentPeriod = PaymentPeriod
    def get_Buyer(self):
        return self.Buyer
    def set_Buyer(self, Buyer):
        self.Buyer = Buyer
    def get_Seler(self):
        return self.Seler
    def set_Seler(self, Seler):
        self.Seler = Seler
    def get_Consignor(self):
        return self.Consignor
    def set_Consignor(self, Consignor):
        self.Consignor = Consignor
    def get_Consignee(self):
        return self.Consignee
    def set_Consignee(self, Consignee):
        self.Consignee = Consignee
    def get_InvoiceGoods(self):
        return self.InvoiceGoods
    def set_InvoiceGoods(self, InvoiceGoods):
        self.InvoiceGoods = InvoiceGoods
    def add_InvoiceGoods(self, value):
        self.InvoiceGoods.append(value)
    def insert_InvoiceGoods_at(self, index, value):
        self.InvoiceGoods.insert(index, value)
    def replace_InvoiceGoods_at(self, index, value):
        self.InvoiceGoods[index] = value
    def get_DeliveryTerms(self):
        return self.DeliveryTerms
    def set_DeliveryTerms(self, DeliveryTerms):
        self.DeliveryTerms = DeliveryTerms
    def get_TransportMeans(self):
        return self.TransportMeans
    def set_TransportMeans(self, TransportMeans):
        self.TransportMeans = TransportMeans
    def add_TransportMeans(self, value):
        self.TransportMeans.append(value)
    def insert_TransportMeans_at(self, index, value):
        self.TransportMeans.insert(index, value)
    def replace_TransportMeans_at(self, index, value):
        self.TransportMeans[index] = value
    def get_Registration(self):
        return self.Registration
    def set_Registration(self, Registration):
        self.Registration = Registration
    def get_Contract(self):
        return self.Contract
    def set_Contract(self, Contract):
        self.Contract = Contract
    def get_Enclosure(self):
        return self.Enclosure
    def set_Enclosure(self, Enclosure):
        self.Enclosure = Enclosure
    def add_Enclosure(self, value):
        self.Enclosure.append(value)
    def insert_Enclosure_at(self, index, value):
        self.Enclosure.insert(index, value)
    def replace_Enclosure_at(self, index, value):
        self.Enclosure[index] = value
    def get_Mark(self):
        return self.Mark
    def set_Mark(self, Mark):
        self.Mark = Mark
    def get_DocumentModeID(self):
        return self.DocumentModeID
    def set_DocumentModeID(self, DocumentModeID):
        self.DocumentModeID = DocumentModeID
    def validate_CurrencyRateType(self, value):
        result = True
        # Validate type CurrencyRateType, a restriction on CategoryCust:QuantityCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CurrencyRateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 11:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on CurrencyRateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_CurrencyA3CodeType(self, value):
        result = True
        # Validate type CurrencyA3CodeType, a restriction on CategoryCust:CodeCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CurrencyA3CodeType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_Count8Type(self, value):
        result = True
        # Validate type Count8Type, a restriction on CategoryCust:IntegerCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Count8Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on Count8Type' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_FreeText250Type(self, value):
        result = True
        # Validate type FreeText250Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 250:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FreeText250Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FreeText250Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityBasisType(self, value):
        result = True
        # Validate type QuantityBasisType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 24:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityBasisType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_AmountType(self, value):
        result = True
        # Validate type AmountType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on AmountType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ProcentNumericType(self, value):
        result = True
        # Validate type ProcentNumericType, a restriction on CategoryCust:NumericCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ProcentNumericType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_Text50Type(self, value):
        result = True
        # Validate type Text50Type, a restriction on CategoryCust:TextCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Text50Type' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on Text50Type' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DocumentModeIDType(self, value):
        # Validate type clt_ru:DocumentModeIDType, a restriction on CategoryCust:IdentifierCategoriesCust.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DocumentModeIDType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DocumentModeIDType' % {"value" : value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.CurrencyRate is not None or
            self.CurrencyCode is not None or
            self.PlacesQuantity is not None or
            self.PlacesDescription is not None or
            self.GrossWeightQuantity is not None or
            self.NetWeightQuantity is not None or
            self.GCost is not None or
            self.Discount is not None or
            self.DiscountPercentage is not None or
            self.TransportCharges is not None or
            self.InsuranceCharges is not None or
            self.OtherCharges is not None or
            self.TotalCost is not None or
            self.PaymentPeriod is not None or
            self.Buyer is not None or
            self.Seler is not None or
            self.Consignor is not None or
            self.Consignee is not None or
            self.InvoiceGoods or
            self.DeliveryTerms is not None or
            self.TransportMeans or
            self.Registration is not None or
            self.Contract is not None or
            self.Enclosure or
            self.Mark is not None or
            super(InvoiceType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"  xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" ', name_='InvoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceType'):
        super(InvoiceType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceType')
        if self.DocumentModeID is not None and 'DocumentModeID' not in already_processed:
            already_processed.add('DocumentModeID')
            outfile.write(' DocumentModeID=%s' % (quote_attrib(self.DocumentModeID), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0" xmlns:clt_ru="urn:customs.ru:CommonLeafTypes:5.10.0"  xmlns:cat_ru="urn:customs.ru:CommonAggregateTypes:5.22.0"  xmlns:catComFin_ru="urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0" ', name_='InvoiceType', fromsubclass_=False, pretty_print=True):
        super(InvoiceType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyRate is not None:
            namespaceprefix_ = self.CurrencyRate_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrencyRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyRate>%s</%sCurrencyRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.CurrencyRate, input_name='CurrencyRate'), namespaceprefix_ , eol_))
        if self.CurrencyCode is not None:
            namespaceprefix_ = self.CurrencyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrencyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrencyCode>%s</%sCurrencyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), namespaceprefix_ , eol_))
        if self.PlacesQuantity is not None:
            namespaceprefix_ = self.PlacesQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.PlacesQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlacesQuantity>%s</%sPlacesQuantity>%s' % (namespaceprefix_ , self.gds_format_integer(self.PlacesQuantity, input_name='PlacesQuantity'), namespaceprefix_ , eol_))
        if self.PlacesDescription is not None:
            namespaceprefix_ = self.PlacesDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.PlacesDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlacesDescription>%s</%sPlacesDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PlacesDescription), input_name='PlacesDescription')), namespaceprefix_ , eol_))
        if self.GrossWeightQuantity is not None:
            namespaceprefix_ = self.GrossWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.GrossWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGrossWeightQuantity>%s</%sGrossWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GrossWeightQuantity, input_name='GrossWeightQuantity'), namespaceprefix_ , eol_))
        if self.NetWeightQuantity is not None:
            namespaceprefix_ = self.NetWeightQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.NetWeightQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetWeightQuantity>%s</%sNetWeightQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.NetWeightQuantity, input_name='NetWeightQuantity'), namespaceprefix_ , eol_))
        if self.GCost is not None:
            namespaceprefix_ = self.GCost_nsprefix_ + ':' if (UseCapturedNS_ and self.GCost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGCost>%s</%sGCost>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GCost, input_name='GCost'), namespaceprefix_ , eol_))
        if self.Discount is not None:
            namespaceprefix_ = self.Discount_nsprefix_ + ':' if (UseCapturedNS_ and self.Discount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscount>%s</%sDiscount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.Discount, input_name='Discount'), namespaceprefix_ , eol_))
        if self.DiscountPercentage is not None:
            namespaceprefix_ = self.DiscountPercentage_nsprefix_ + ':' if (UseCapturedNS_ and self.DiscountPercentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscountPercentage>%s</%sDiscountPercentage>%s' % (namespaceprefix_ , self.gds_format_decimal(self.DiscountPercentage, input_name='DiscountPercentage'), namespaceprefix_ , eol_))
        if self.TransportCharges is not None:
            namespaceprefix_ = self.TransportCharges_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportCharges_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransportCharges>%s</%sTransportCharges>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TransportCharges, input_name='TransportCharges'), namespaceprefix_ , eol_))
        if self.InsuranceCharges is not None:
            namespaceprefix_ = self.InsuranceCharges_nsprefix_ + ':' if (UseCapturedNS_ and self.InsuranceCharges_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInsuranceCharges>%s</%sInsuranceCharges>%s' % (namespaceprefix_ , self.gds_format_decimal(self.InsuranceCharges, input_name='InsuranceCharges'), namespaceprefix_ , eol_))
        if self.OtherCharges is not None:
            namespaceprefix_ = self.OtherCharges_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherCharges_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCharges>%s</%sOtherCharges>%s' % (namespaceprefix_ , self.gds_format_decimal(self.OtherCharges, input_name='OtherCharges'), namespaceprefix_ , eol_))
        if self.TotalCost is not None:
            namespaceprefix_ = self.TotalCost_nsprefix_ + ':' if (UseCapturedNS_ and self.TotalCost_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTotalCost>%s</%sTotalCost>%s' % (namespaceprefix_ , self.gds_format_decimal(self.TotalCost, input_name='TotalCost'), namespaceprefix_ , eol_))
        if self.PaymentPeriod is not None:
            namespaceprefix_ = self.PaymentPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.PaymentPeriod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPaymentPeriod>%s</%sPaymentPeriod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PaymentPeriod), input_name='PaymentPeriod')), namespaceprefix_ , eol_))
        if self.Buyer is not None:
            namespaceprefix_ = self.Buyer_nsprefix_ + ':' if (UseCapturedNS_ and self.Buyer_nsprefix_) else ''
            self.Buyer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Buyer', pretty_print=pretty_print)
        if self.Seler is not None:
            namespaceprefix_ = self.Seler_nsprefix_ + ':' if (UseCapturedNS_ and self.Seler_nsprefix_) else ''
            self.Seler.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Seler', pretty_print=pretty_print)
        if self.Consignor is not None:
            namespaceprefix_ = self.Consignor_nsprefix_ + ':' if (UseCapturedNS_ and self.Consignor_nsprefix_) else ''
            self.Consignor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Consignor', pretty_print=pretty_print)
        if self.Consignee is not None:
            namespaceprefix_ = self.Consignee_nsprefix_ + ':' if (UseCapturedNS_ and self.Consignee_nsprefix_) else ''
            self.Consignee.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Consignee', pretty_print=pretty_print)
        for InvoiceGoods_ in self.InvoiceGoods:
            namespaceprefix_ = self.InvoiceGoods_nsprefix_ + ':' if (UseCapturedNS_ and self.InvoiceGoods_nsprefix_) else ''
            InvoiceGoods_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InvoiceGoods', pretty_print=pretty_print)
        if self.DeliveryTerms is not None:
            namespaceprefix_ = self.DeliveryTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveryTerms_nsprefix_) else ''
            self.DeliveryTerms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DeliveryTerms', pretty_print=pretty_print)
        for TransportMeans_ in self.TransportMeans:
            namespaceprefix_ = self.TransportMeans_nsprefix_ + ':' if (UseCapturedNS_ and self.TransportMeans_nsprefix_) else ''
            TransportMeans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TransportMeans', pretty_print=pretty_print)
        if self.Registration is not None:
            namespaceprefix_ = self.Registration_nsprefix_ + ':' if (UseCapturedNS_ and self.Registration_nsprefix_) else ''
            self.Registration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Registration', pretty_print=pretty_print)
        if self.Contract is not None:
            namespaceprefix_ = self.Contract_nsprefix_ + ':' if (UseCapturedNS_ and self.Contract_nsprefix_) else ''
            self.Contract.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contract', pretty_print=pretty_print)
        for Enclosure_ in self.Enclosure:
            namespaceprefix_ = self.Enclosure_nsprefix_ + ':' if (UseCapturedNS_ and self.Enclosure_nsprefix_) else ''
            Enclosure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Enclosure', pretty_print=pretty_print)
        if self.Mark is not None:
            namespaceprefix_ = self.Mark_nsprefix_ + ':' if (UseCapturedNS_ and self.Mark_nsprefix_) else ''
            self.Mark.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Mark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DocumentModeID', node)
        if value is not None and 'DocumentModeID' not in already_processed:
            already_processed.add('DocumentModeID')
            self.DocumentModeID = value
            self.DocumentModeID = ' '.join(self.DocumentModeID.split())
            self.validate_DocumentModeIDType(self.DocumentModeID)    # validate type DocumentModeIDType
        super(InvoiceType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CurrencyRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'CurrencyRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'CurrencyRate')
            self.CurrencyRate = fval_
            self.CurrencyRate_nsprefix_ = child_.prefix
            # validate type CurrencyRateType
            self.validate_CurrencyRateType(self.CurrencyRate)
        elif nodeName_ == 'CurrencyCode':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'CurrencyCode')
            value_ = self.gds_validate_string(value_, node, 'CurrencyCode')
            self.CurrencyCode = value_
            self.CurrencyCode_nsprefix_ = child_.prefix
            # validate type CurrencyA3CodeType
            self.validate_CurrencyA3CodeType(self.CurrencyCode)
        elif nodeName_ == 'PlacesQuantity' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PlacesQuantity')
            ival_ = self.gds_validate_integer(ival_, node, 'PlacesQuantity')
            self.PlacesQuantity = ival_
            self.PlacesQuantity_nsprefix_ = child_.prefix
            # validate type Count8Type
            self.validate_Count8Type(self.PlacesQuantity)
        elif nodeName_ == 'PlacesDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PlacesDescription')
            value_ = self.gds_validate_string(value_, node, 'PlacesDescription')
            self.PlacesDescription = value_
            self.PlacesDescription_nsprefix_ = child_.prefix
            # validate type FreeText250Type
            self.validate_FreeText250Type(self.PlacesDescription)
        elif nodeName_ == 'GrossWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GrossWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'GrossWeightQuantity')
            self.GrossWeightQuantity = fval_
            self.GrossWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.GrossWeightQuantity)
        elif nodeName_ == 'NetWeightQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'NetWeightQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'NetWeightQuantity')
            self.NetWeightQuantity = fval_
            self.NetWeightQuantity_nsprefix_ = child_.prefix
            # validate type QuantityBasisType
            self.validate_QuantityBasisType(self.NetWeightQuantity)
        elif nodeName_ == 'GCost' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GCost')
            fval_ = self.gds_validate_decimal(fval_, node, 'GCost')
            self.GCost = fval_
            self.GCost_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.GCost)
        elif nodeName_ == 'Discount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'Discount')
            fval_ = self.gds_validate_decimal(fval_, node, 'Discount')
            self.Discount = fval_
            self.Discount_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.Discount)
        elif nodeName_ == 'DiscountPercentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'DiscountPercentage')
            fval_ = self.gds_validate_decimal(fval_, node, 'DiscountPercentage')
            self.DiscountPercentage = fval_
            self.DiscountPercentage_nsprefix_ = child_.prefix
            # validate type ProcentNumericType
            self.validate_ProcentNumericType(self.DiscountPercentage)
        elif nodeName_ == 'TransportCharges' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TransportCharges')
            fval_ = self.gds_validate_decimal(fval_, node, 'TransportCharges')
            self.TransportCharges = fval_
            self.TransportCharges_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.TransportCharges)
        elif nodeName_ == 'InsuranceCharges' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'InsuranceCharges')
            fval_ = self.gds_validate_decimal(fval_, node, 'InsuranceCharges')
            self.InsuranceCharges = fval_
            self.InsuranceCharges_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.InsuranceCharges)
        elif nodeName_ == 'OtherCharges' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'OtherCharges')
            fval_ = self.gds_validate_decimal(fval_, node, 'OtherCharges')
            self.OtherCharges = fval_
            self.OtherCharges_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.OtherCharges)
        elif nodeName_ == 'TotalCost' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'TotalCost')
            fval_ = self.gds_validate_decimal(fval_, node, 'TotalCost')
            self.TotalCost = fval_
            self.TotalCost_nsprefix_ = child_.prefix
            # validate type AmountType
            self.validate_AmountType(self.TotalCost)
        elif nodeName_ == 'PaymentPeriod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PaymentPeriod')
            value_ = self.gds_validate_string(value_, node, 'PaymentPeriod')
            self.PaymentPeriod = value_
            self.PaymentPeriod_nsprefix_ = child_.prefix
            # validate type Text50Type
            self.validate_Text50Type(self.PaymentPeriod)
        elif nodeName_ == 'Buyer':
            obj_ = InvoiceParticipantInfType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Buyer = obj_
            obj_.original_tagname_ = 'Buyer'
        elif nodeName_ == 'Seler':
            obj_ = InvoiceParticipantInfType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Seler = obj_
            obj_.original_tagname_ = 'Seler'
        elif nodeName_ == 'Consignor':
            class_obj_ = self.get_class_obj_(child_, OrganizationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Consignor = obj_
            obj_.original_tagname_ = 'Consignor'
        elif nodeName_ == 'Consignee':
            class_obj_ = self.get_class_obj_(child_, OrganizationType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Consignee = obj_
            obj_.original_tagname_ = 'Consignee'
        elif nodeName_ == 'InvoiceGoods':
            obj_ = InvoiceGoodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InvoiceGoods.append(obj_)
            obj_.original_tagname_ = 'InvoiceGoods'
        elif nodeName_ == 'DeliveryTerms':
            obj_ = InvoiceDeliveryTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DeliveryTerms = obj_
            obj_.original_tagname_ = 'DeliveryTerms'
        elif nodeName_ == 'TransportMeans':
            obj_ = TransportMeansType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TransportMeans.append(obj_)
            obj_.original_tagname_ = 'TransportMeans'
        elif nodeName_ == 'Registration':
            class_obj_ = self.get_class_obj_(child_, DocumentBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Registration = obj_
            obj_.original_tagname_ = 'Registration'
        elif nodeName_ == 'Contract':
            class_obj_ = self.get_class_obj_(child_, DocumentBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contract = obj_
            obj_.original_tagname_ = 'Contract'
        elif nodeName_ == 'Enclosure':
            class_obj_ = self.get_class_obj_(child_, DocumentBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Enclosure.append(obj_)
            obj_.original_tagname_ = 'Enclosure'
        elif nodeName_ == 'Mark':
            obj_ = MarkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Mark = obj_
            obj_.original_tagname_ = 'Mark'
        super(InvoiceType, self)._buildChildren(child_, node, nodeName_, True)
# end class InvoiceType


#
# End data representation classes.
#


GDSClassesMapping = {
    'Invoice': InvoiceType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'InvoiceType'
        rootClass = InvoiceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'InvoiceType'
        rootClass = InvoiceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'InvoiceType'
        rootClass = InvoiceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:inv="urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'InvoiceType'
        rootClass = InvoiceType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from invoice import *\n\n')
        sys.stdout.write('import invoice as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
    "{urn:customs.ru:CommonAggregateTypes:5.22.0}GTDIDType": "GTDIDType1",
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'urn:customs.ru:Categories:3.0.0': [('BinaryDataCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('CodeCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('DateCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('DateTimeCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('IdentifierCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('IndicatorCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('IntegerCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('NumericCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('QuantityCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('TextCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('TimeCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST'),
                                     ('YearCategoriesCust',
                                      'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CategoriesCust.xsd',
                                      'ST')],
 'urn:customs.ru:CommonAggregateTypes:5.22.0': [('AddressType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('AuthoritesDocumentType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('AutomobileBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('BankInformationType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('BaseDocType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CUBranchDescriptionType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CUCustomsType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CUOrganizationType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CUTransportMeansType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CargoBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('ContactType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CustomsPersonType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('CustomsType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('DeliveryTermsRUType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('DeliveryTermsType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('DimensionsType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('DocumentBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('DriverInformationType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('GTDID5Type',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('GTDID6Type',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('GTDIDType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('GoodsBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('ITNKZType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('IdentityCardType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('KGOrganizationFeaturesType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('OrganizationBackAddrType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('OrganizationBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('OrganizationType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('OrganizationWBankType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('PersonBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('PersonSignatureType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('RAOrganizationFeaturesType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('RBOrganizationFeaturesType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('RFOrganizationFeaturesType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('RKOrganizationFeaturesType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('SupplementaryQuantityType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('TransportGoodsBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('TransportMeansBaseType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT'),
                                                ('TransportMeansPassportType',
                                                 'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonAggregateTypesCust.xsd',
                                                 'CT')],
 'urn:customs.ru:CommonLeafTypes:5.10.0': [('AccountType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('AmountType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ArchStatusCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ArchiveDeclarantIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ArchiveDocumentIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ArchiveIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('BICIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('BINType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('BankMFOType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CUCustomsPaymentCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CUCustomsProcedureType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CUGoodsNomenclatuerCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CityNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code10Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code13Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code14Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code15Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code2Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code3Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code4Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code5Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code6Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code8Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Code9Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable10Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable11Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable14Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable18Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable20Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable2Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable3Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable4Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable5Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable6Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable7Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CodeVariable8Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ContainerIdentityType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count10Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count19Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count2Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count3Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count4Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count5Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count6Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Count8Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CountryA2CodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CountryA3CodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CountryN3CodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CountryNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CurrencyA3CodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CurrencyN3CodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CurrencyNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CurrencyRateType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CustomsCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CustomsDocumentCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CustomsOfficeNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('CustomsPaymentCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DateCustType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DateTimeCustType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DateYearCustType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DeliveryTermsNumericCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DigitalIndicatorType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DocumentCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DocumentIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DocumentModeIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DocumentNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('DocumentNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('EngineIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('EnginePowerQuanityType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('EngineVolumeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ForeignAccountType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('FreeText250Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('FreeText500Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('GTDIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('GoodMarkingType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('GoodsNomenclatuerAddCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('GoodsNomenclatureCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IINType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('INNIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ITNReservType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ITNType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IdentityCardCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IdentityCardNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IdentityCardNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IdentityCardSeriesType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IncotermsDeliveryStringCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('IndicatorType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('KGINNIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('KGOKPOIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('KPPCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('LNPIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('LanguageCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('LetterIndicatorType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('MarkCarCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('MarkCarNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('MeasureUnitQualifierCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('MeasureUnitQualifierNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('MonthYearType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('NameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Numeric1Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('OGRNIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('OKATOCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('OKPOIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('OverallDimensionType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PackageCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PackagesQuantityType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PakageNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PhoneNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PlaceNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PostType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PostalCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('PrecedingDocumentNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ProcentNumericType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity11Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity14point2Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity18point3Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity2Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity3Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity4Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity4point2Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity5Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Quantity8Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('QuantityBasis0Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('QuantityBasisType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('RNNIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('RailwayStationCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('RegionCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('RegionType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('SWIFTIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('SeriesCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ServiceModeCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('SheetNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('ShortNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('SocialServiceCertificateType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('SocialServiceNumberType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('StreetHouseType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TINType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TIRHolderIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TNVEDContractType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TaxOrganIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TerritoryCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text10Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text150Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text3MB',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text40Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text4Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text50Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('Text5Type',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TimeCustType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransitDirectionCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportCategoryCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportMeansColorCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportMeansIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportModeCodeType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportNameType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportPassportIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('TransportStateSignIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('UNNType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('UNPTtype',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('VINIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('VisualIdentifierCIMType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('WarehouseLicenceIDType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST'),
                                           ('WeighQuantityType',
                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommonLeafTypesCust.xsd',
                                            'ST')],
 'urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonAgregateTypesCust:5.22.0': [('AdditionalGoodsDescriptionType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('BankMarkType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('BankType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ContractDeliveryTermsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ContractDescriptionType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ContractRegistrationType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ContractSpecificationType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('CustomerType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('DepartmentalInfoType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ForeignPersonType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('GoodsPlaceType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('GoodsWeightType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ImportContractTermsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('InvoiceGoodsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('InvoiceParticipantType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('InvoiceSaleTermsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('MarkType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('OtherChargesType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('PartPaymentType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('PayCustomerType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('PaymentRequisitionsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('RussianInvoiceGoodsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('ShortCompanyDescType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('SpecificationGoodsExtendedType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('SpecificationGoodsType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT'),
                                                                                                           ('TransportMeansType',
                                                                                                            'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonAggregateTypesCust.xsd',
                                                                                                            'CT')],
 'urn:customs.ru:Information:CommercialFinanceDocuments:CommercialFinanceCommonLeafTypesCust:5.8.0': [('CBCType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('CertificateSeriesCodeType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('CorrAccountType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('DueDateCodeType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('InvoiceCurrencyRateType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('PaymentModeCodeType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('PriceType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('MoreAccuratePriceType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('SaleTermsCodeType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('TaxDocDateCodeTextType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('TaxDocIDTextType',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST'),
                                                                                                      ('Text100Type',
                                                                                                       'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0/CommercialFinanceCommonLeafTypesCust.xsd',
                                                                                                       'ST')],
 'urn:customs.ru:Information:CommercialFinanceDocuments:Invoice:5.22.0': [('InvoiceType',
                                                                           'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0\\Invoice.xsd',
                                                                           'CT'),
                                                                          ('InvoiceDeliveryTermsType',
                                                                           'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0\\Invoice.xsd',
                                                                           'CT'),
                                                                          ('InvoiceParticipantInfType',
                                                                           'C:\\Users\\1\\PythonApp\\generateDS-2.43.3\\customs\\Schemas_out_5_23_0\\Invoice.xsd',
                                                                           'CT')]}

__all__ = [
    "AdditionalGoodsDescriptionType",
    "AddressType",
    "AuthoritesDocumentType",
    "AutomobileBaseType",
    "BankInformationType",
    "BankMarkType",
    "BankType",
    "BaseDocType",
    "CUBranchDescriptionType",
    "CUCustomsType",
    "CUOrganizationType",
    "CUTransportMeansType",
    "CargoBaseType",
    "ContactType",
    "ContractDeliveryTermsType",
    "ContractDescriptionType",
    "ContractRegistrationType",
    "ContractSpecificationType",
    "CustomerType",
    "CustomsPersonType",
    "CustomsType",
    "DeliveryTermsRUType",
    "DeliveryTermsType",
    "DepartmentalInfoType",
    "DimensionsType",
    "DocumentBaseType",
    "DriverInformationType",
    "ForeignPersonType",
    "GTDID5Type",
    "GTDID6Type",
    "GTDIDType1",
    "GoodsBaseType",
    "GoodsPlaceType",
    "GoodsWeightType",
    "ITNKZType",
    "IdentityCardType",
    "ImportContractTermsType",
    "InvoiceDeliveryTermsType",
    "InvoiceGoodsType",
    "InvoiceParticipantInfType",
    "InvoiceParticipantType",
    "InvoiceSaleTermsType",
    "InvoiceType",
    "KGOrganizationFeaturesType",
    "MarkType",
    "OrganizationBackAddrType",
    "OrganizationBaseType",
    "OrganizationType",
    "OrganizationWBankType",
    "OtherChargesType",
    "PartPaymentType",
    "PayCustomerType",
    "PaymentRequisitionsType",
    "PersonBaseType",
    "PersonSignatureType",
    "RAOrganizationFeaturesType",
    "RBOrganizationFeaturesType",
    "RFOrganizationFeaturesType",
    "RKOrganizationFeaturesType",
    "RussianInvoiceGoodsType",
    "ShortCompanyDescType",
    "SpecificationGoodsExtendedType",
    "SpecificationGoodsType",
    "SupplementaryQuantityType",
    "TransportGoodsBaseType",
    "TransportMeansBaseType",
    "TransportMeansPassportType",
    "TransportMeansType"
]
